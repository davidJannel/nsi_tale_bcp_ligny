{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Le programme officiel \u2693\ufe0e Attention seuls les chapitres abord\u00e9s avec la mention BAC seront \u00e9valu\u00e9s \u00e0 l'\u00e9preuve \u00e9crite. Chapitres et th\u00e8mes abord\u00e9s : \u2693\ufe0e CH1 : Mise au point des programmes - Gestion des bugs (BAC) CH2 : R\u00e9cursivit\u00e9 (BAC) CH3 : Structures de donn\u00e9es (BAC)","title":"index"},{"location":"#le-programme-officiel","text":"Attention seuls les chapitres abord\u00e9s avec la mention BAC seront \u00e9valu\u00e9s \u00e0 l'\u00e9preuve \u00e9crite.","title":"Le programme officiel"},{"location":"#chapitres-et-themes-abordes","text":"CH1 : Mise au point des programmes - Gestion des bugs (BAC) CH2 : R\u00e9cursivit\u00e9 (BAC) CH3 : Structures de donn\u00e9es (BAC)","title":"Chapitres et th\u00e8mes abord\u00e9s :"},{"location":"a_propos/","text":"\u00c9crire de maths : \u2693\ufe0e \\[x = \\dfrac{y}{2 \\times z}\\]","title":"\u00c9crire de maths :"},{"location":"a_propos/#ecrire-de-maths","text":"\\[x = \\dfrac{y}{2 \\times z}\\]","title":"\u00c9crire de maths :"},{"location":"CH1_map/cours/","text":"CH1 : Mise au point des programmes - Gestion des bugs \u2693\ufe0e Programme officiel \"La mise au point du programme doit permettre au programme de r\u00e9pondre \u00e0 une sp\u00e9cification, durant cette phase, le programmeur se doit de savoir r\u00e9pondre aux causes typiques de bugs.\" 1. Conventions syntaxiques \u2693\ufe0e La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits : 1.1 Les espaces \u2693\ufe0e \u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/ 1.2 Les conventions de nommage \u2693\ufe0e \u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. (cf : cours de Mme Desmarest) # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass 2. Les erreurs courantes en Python - Savoir lire ses erreurs et corriger son code \u2693\ufe0e Lorsqu'on ex\u00e9cute un programme, il peut fonctionner comme pr\u00e9vu, mais il peut \u00e9galement \"planter\", ou bien ne plus s'arr\u00eater (boucler ind\u00e9finiment). Les sources possibles d'erreurs dans un programme sont nombreuses. En fonction des erreurs rencontr\u00e9es, Python affiche des erreurs sp\u00e9cifiques qui vous aident \u00e0 comprendre quel est le probl\u00e8me dans votre programme. 2.1 Analyser le traceback \u2693\ufe0e Le traceback est l\u2019ensemble des lignes a\ufb00ich\u00e9es par l\u2019interpr\u00e9teur Python lorsqu\u2019une exception est lev\u00e9e. Comprendre le traceback est tr\u00e8s utile pour trouver rapidement une faute et l\u2019expliquer. Voici un exemple de traceback a\ufb00ich\u00e9 lors de l\u2019ex\u00e9cution d\u2019un code: 1 2 3 4 5 6 7 8 def moyenne ( t ): n = len ( t ) s = 0 for i in range ( n ): s = s + t [ i ] return s / n print ( moyenne ([])) >>> % Run moyenne . py Traceback ( most recent call last ): File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 8 , in < module > print ( moyenne ([])) File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 6 , in moyenne return s / n ZeroDivisionError : division by zero Ce traceback est constitu\u00e9 d\u2019une liste de lignes en d\u00e9faut (il y en a 2 ici), puis d\u2019un message qui pr\u00e9cise letype d\u2019exception (c\u2019est la derni\u00e8re ligne). En lisant le traceback de haut en bas, on avance dans le temps. Ce qui s\u2019est produit en dernier est donc \u00e0 la fin du traceback. En le lisant de haut en bas, on note (notez la correspondance entre ce qui est indiqu\u00e9 ci-dessous et le contenudu traceback) : ex\u00e9cution de la ligne 8 \u00ab print(moyenne([])) \u00bb. On entre dans la fonction moyenne qui a provoqu\u00e9 l\u2019ex\u00e9cution de la ligne 6 \u00ab return s / n \u00bb, qui a donc provoqu\u00e9 la lev\u00e9e d\u2019exceptionZeroDivisionError: division by zero La plupart du temps, la lecture des trois derni\u00e8res lignes du traceback permet de cerner le probl\u00e8me : Ici, on effectue une divison par 0. Cela s'est produit lors du renvoie du calcul de s par n. Calcul qui est fait \u00e0 la ligne 6. Cette erreur n'est lev\u00e9e uniquement parceque on a fait appel \u00e0 la fonction moyenne sur un tableau vide. La fonction par elle m\u00eame est correcte. Il faut juste faire attention et pr\u00e9ciser \u00e0 l'utilisateur que la fonction doit \u00eatre appel\u00e9e avec des tableaux non vides. Pour \u00e9viter ces erreurs, il est donc important de : - savoir lire le traceback. - pr\u00e9voir des jeux de tests. - sp\u00e9cifier la fonction pour pouvoir b\u00e9n\u00e9ficier d'une aide \u00e0 l'utilisation de celle-ci. 2.2 Quelques erreurs courantes \u2693\ufe0e Voici quelques erreurs courantes que vous devez apprendre \u00e0 reconnaitre parmi les nombreuses exceptions de Python. Type d'erreur Objet Python Erreurs courantes Exemple Erreurs de syntaxe SyntaxError Erreur de parenth\u00e8se, : manquant avant un bloc d'instruction ... len(t)) Erreurs d'indexation IndexError Acc\u00e8s \u00e0 un index non pr\u00e9sent dans une liste, ou un tuple, str... t = [2, 3] puis print(t[2]) Erreurs de nom NameError Nom de fonction ou de variable mal orthographi\u00e9. print(Bonjour) ou prin(\"Bonjour\") Erreurs d'indentation IndentationError Indentation oubli\u00e9e, ou trop grande, les blocs sont alors mal d\u00e9limit\u00e9s. Erreurs de type TypeError Op\u00e9ration impossible entre deux types(str - int). Conversion de type impossible. '3' * '5' ** Exercices :** Identifier le type d'erreur dans les exerices ci-dessous et corriger les. Question 1 code solution On d\u00e9sire afficher les \u00e9l\u00e9ments de la liste. 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 4 : print ( lst [ i ]) i = i + 1 IndexError : la liste ne contient que 3 \u00e9l\u00e9ments 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 3 : print ( lst [ i ]) i = i + 1 On rapelle qu'il est pr\u00e9f\u00e9rable de parcourir une liste (tableau) en utilisant une boucle for. Exercice 2 code solution 1 2 3 a = 2 b = \"Une fois sur \" print ( b + a ) TypeError : On ne peut pas concat\u00e9ner une chaine de caract\u00e8res avec un int. 1 2 3 a = \"2\" b = \"Une fois sur \" print ( b + a ) ou alors 1 2 3 a = 2 b = \"Une fois sur \" print ( b + str ( a )) Exercice 3 code solution Afficher la somme de tous les \u00e9l\u00e9ments de la liste. 1 2 3 4 l = [ 0 , 4 , 8 , 5 ] for v in l : s = s + v print ( s ) NameError : la variable s n'est pas initialis\u00e9e avant la boucle. L'expression s + v ne peut \u00eatre calcul\u00e9e. ` 1 2 3 4 5 l = [ 0 , 4 , 8 , 5 ] s = 0 # par exemple for v in l : s = s + v print ( s ) Exercice 4 code solution Afficher les \u00e9l\u00e9ments de la liste 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) IndentationError : il manque l'indentation avant le print. ` 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) Exercice 5 code solution Afficher la plus petite valeur contenue dans la liste 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini mini = liste [ i ] print ( mini ) SyntaxError : il manque : dans la condition (ligne 4) 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini : mini = liste [ i ] print ( mini ) Remarques Attention, si l'interpr\u00e9teur Python ne renvoie pas d'erreur, cela ne signifie pas pour autant que votre code est correct. Dans l'exemple de la fonction moyenne qui doit renvoyer la moyenne des valeurs contenues dans un tableau, la fonction fait correctement le travail mais elle ne fonctionne pas sur une liste vide, ou sur une liste qui ne contiendrait pas uniquement des valeurs num\u00e9riques. D'autres erreurs peuvent \u00eatre non affich\u00e9es dans l'interpr\u00e9teur. Par exemple : des instructions conditionnelles qui oublient des cas, des mauvaises conditions ... des boucles qui ne se terminent pas : cas de la boucle while des effets de bords : on modifie une variable globale \u00e0 l'int\u00e9rieur d'une fonction. Il est donc important avant de coder de sp\u00e9cifier une fonction, de docummenter si n\u00e9cessaire une partie du code, de pr\u00e9voir des jeux de tests. Tester, debugger, font partie des bonnes pratiques du programmeur. \u00c7a s'appelle mettre au point du code. 3. Documenter et sp\u00e9cifier \u2693\ufe0e 3.1 Commenter son code ? (ou pas) \u2693\ufe0e Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires. 3.2 Le cas particulier des docstrings \u2693\ufe0e 3.2.1 Que sont les docstrings ? \u2693\ufe0e Les docstrings sont des commentaires normalis\u00e9s pour les fonctions, qui peuvent \u00eatre consult\u00e9s en console. Exemples : Nous connaissons la fonction len() qui permet par exemple de conna\u00eetre la longueur d'une liste pass\u00e9e en param\u00e8tre. Si nous tapons en console la commande print(len.__doc__) , nous aurons la description de cette fonction. >>> len . __doc__ 'Return the number of items in a container.' Il est aussi possible d'acc\u00e9der \u00e0 la docstring d'une fonction f par la commande help(f) : >>> help ( len ) Help on built - in function len in module builtins : len ( obj , / ) Return the number of items in a container . De m\u00eame pour la fonction range : >>> print ( range . __doc__ ) range ( stop ) -> range object range ( start , stop [, step ]) -> range object Return an object that produces a sequence of integers from start ( inclusive ) to stop ( exclusive ) by step . range ( i , j ) produces i , i + 1 , i + 2 , ... , j - 1. start defaults to 0 , and stop is omitted ! range ( 4 ) produces 0 , 1 , 2 , 3. These are exactly the valid indices for a list of 4 elements . When step is given , it specifies the increment ( or decrement ) . Le r\u00e9sultat de la commande help(range) est trop long pour \u00eatre repris ici, mais on y retrouve bien la docstring de la fonction range . 3.2.2 Cr\u00e9er ses propres docstrings \u2693\ufe0e Il suffit pour cela de commencer la fonction \u00e0 documenter par une ou plusieurs phrases entre triples quotes : def capital_apres_n_annees ( capital , taux , nombre_annees ) : \"\"\" Renvoie le capital apr\u00e8s n ann\u00e9es. input : capital : valeur initiale (float) taux : taux d'int\u00e9r\u00eat (float) (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d'ann\u00e9es de placement du capital (int) output : capital apr\u00e8s n ann\u00e9es (float) \"\"\" return capital * ( 1 + taux ) ** nombre_annees Ainsi, un utilisateur pourra trouver en console le mode d'emploi de notre fonction : >>> help ( capital_apres_n_annees ) Help on function capital_apres_n_annees in module __main__ : capital_apres_n_annees ( capital , taux , nombre_annees ) Renvoie le capital apr\u00e8s n ann\u00e9es . capital : valeur initiale taux : taux d 'int\u00e9r\u00eat exprim\u00e9 en nombre d\u00e9cimal (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d 'ann\u00e9es de placement du capital Comme on le voit, tout cela est tr\u00e8s \u00abverbeux\u00bb. Cela peut nous para\u00eetre largement superflu puisque nos codes d\u00e9passent rarement quelques dizaines de lignes et sont lus par rarement plus de 2 personnes. Mais dans la vraie vie des d\u00e9veloppeurs, il est primordial qu'un code soit clair et document\u00e9. \u00c0 retenir des commentaires quand cela est nec\u00e9ssaire des noms de variable explicites une sp\u00e9cification des fonctions avec une docstring sous le mod\u00e8le suivant : def ma_fonction (): \"\"\" que renvoie ma_fonction input : arguments, type output : valeur de sortie, type \"\"\" votre code 4. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code \u2693\ufe0e La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici . 5. Les tests \u2693\ufe0e 5.1 Pourquoi des tests ? \u2693\ufe0e Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok 5.2 Revoil\u00e0 les assert \u2693\ufe0e Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00e9nonc\u00e9 solution \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste d'entiers liste , suppos\u00e9e non vide, pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) . def test_maxi (): assert maxi ([ 5 ]) == 5 assert maxi ([ - 1 , 5 , 4 , 0 ]) == 5 assert maxi ([ 8 , 7 , 6 , 2 ]) == 8 assert maxi ([ - 1 , - 5 , 0 ]) == 0 def maxi ( liste ): \"\"\" revoie le maximum d'une liste d'entier non vide input : liste (list) d'entiers output : maximum (int) \"\"\" maximum = liste [ 0 ] for elt in liste : if elt > maximum : maximum = elt return maximum 5.3 Le module doctest \u2693\ufe0e Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. On peut, au lieu d'utiliser doctest dans la console Python, placer \u00e0 la fin du fichier le code suivant : if __name__ == '__main__' : import doctest doctest . testmod () Le resultat des tests, si ils ne passent pas, se fera dans l'interpr\u00e9teur \u00e0 chaque execution du code. 5.3 \u00c0 propos des tests \u2693\ufe0e Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...","title":"CH1 : Mise au point des programmes"},{"location":"CH1_map/cours/#ch1-mise-au-point-des-programmes-gestion-des-bugs","text":"Programme officiel \"La mise au point du programme doit permettre au programme de r\u00e9pondre \u00e0 une sp\u00e9cification, durant cette phase, le programmeur se doit de savoir r\u00e9pondre aux causes typiques de bugs.\"","title":"CH1 : Mise au point des programmes - Gestion des bugs"},{"location":"CH1_map/cours/#1-conventions-syntaxiques","text":"La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits :","title":"1. Conventions syntaxiques"},{"location":"CH1_map/cours/#11-les-espaces","text":"\u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/","title":"1.1 Les espaces"},{"location":"CH1_map/cours/#12-les-conventions-de-nommage","text":"\u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. (cf : cours de Mme Desmarest) # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass","title":"1.2 Les conventions de nommage"},{"location":"CH1_map/cours/#2-les-erreurs-courantes-en-python-savoir-lire-ses-erreurs-et-corriger-son-code","text":"Lorsqu'on ex\u00e9cute un programme, il peut fonctionner comme pr\u00e9vu, mais il peut \u00e9galement \"planter\", ou bien ne plus s'arr\u00eater (boucler ind\u00e9finiment). Les sources possibles d'erreurs dans un programme sont nombreuses. En fonction des erreurs rencontr\u00e9es, Python affiche des erreurs sp\u00e9cifiques qui vous aident \u00e0 comprendre quel est le probl\u00e8me dans votre programme.","title":"2. Les erreurs courantes en Python - Savoir lire ses erreurs et corriger son code"},{"location":"CH1_map/cours/#21-analyser-le-traceback","text":"Le traceback est l\u2019ensemble des lignes a\ufb00ich\u00e9es par l\u2019interpr\u00e9teur Python lorsqu\u2019une exception est lev\u00e9e. Comprendre le traceback est tr\u00e8s utile pour trouver rapidement une faute et l\u2019expliquer. Voici un exemple de traceback a\ufb00ich\u00e9 lors de l\u2019ex\u00e9cution d\u2019un code: 1 2 3 4 5 6 7 8 def moyenne ( t ): n = len ( t ) s = 0 for i in range ( n ): s = s + t [ i ] return s / n print ( moyenne ([])) >>> % Run moyenne . py Traceback ( most recent call last ): File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 8 , in < module > print ( moyenne ([])) File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 6 , in moyenne return s / n ZeroDivisionError : division by zero Ce traceback est constitu\u00e9 d\u2019une liste de lignes en d\u00e9faut (il y en a 2 ici), puis d\u2019un message qui pr\u00e9cise letype d\u2019exception (c\u2019est la derni\u00e8re ligne). En lisant le traceback de haut en bas, on avance dans le temps. Ce qui s\u2019est produit en dernier est donc \u00e0 la fin du traceback. En le lisant de haut en bas, on note (notez la correspondance entre ce qui est indiqu\u00e9 ci-dessous et le contenudu traceback) : ex\u00e9cution de la ligne 8 \u00ab print(moyenne([])) \u00bb. On entre dans la fonction moyenne qui a provoqu\u00e9 l\u2019ex\u00e9cution de la ligne 6 \u00ab return s / n \u00bb, qui a donc provoqu\u00e9 la lev\u00e9e d\u2019exceptionZeroDivisionError: division by zero La plupart du temps, la lecture des trois derni\u00e8res lignes du traceback permet de cerner le probl\u00e8me : Ici, on effectue une divison par 0. Cela s'est produit lors du renvoie du calcul de s par n. Calcul qui est fait \u00e0 la ligne 6. Cette erreur n'est lev\u00e9e uniquement parceque on a fait appel \u00e0 la fonction moyenne sur un tableau vide. La fonction par elle m\u00eame est correcte. Il faut juste faire attention et pr\u00e9ciser \u00e0 l'utilisateur que la fonction doit \u00eatre appel\u00e9e avec des tableaux non vides. Pour \u00e9viter ces erreurs, il est donc important de : - savoir lire le traceback. - pr\u00e9voir des jeux de tests. - sp\u00e9cifier la fonction pour pouvoir b\u00e9n\u00e9ficier d'une aide \u00e0 l'utilisation de celle-ci.","title":"2.1 Analyser le traceback"},{"location":"CH1_map/cours/#22-quelques-erreurs-courantes","text":"Voici quelques erreurs courantes que vous devez apprendre \u00e0 reconnaitre parmi les nombreuses exceptions de Python. Type d'erreur Objet Python Erreurs courantes Exemple Erreurs de syntaxe SyntaxError Erreur de parenth\u00e8se, : manquant avant un bloc d'instruction ... len(t)) Erreurs d'indexation IndexError Acc\u00e8s \u00e0 un index non pr\u00e9sent dans une liste, ou un tuple, str... t = [2, 3] puis print(t[2]) Erreurs de nom NameError Nom de fonction ou de variable mal orthographi\u00e9. print(Bonjour) ou prin(\"Bonjour\") Erreurs d'indentation IndentationError Indentation oubli\u00e9e, ou trop grande, les blocs sont alors mal d\u00e9limit\u00e9s. Erreurs de type TypeError Op\u00e9ration impossible entre deux types(str - int). Conversion de type impossible. '3' * '5' ** Exercices :** Identifier le type d'erreur dans les exerices ci-dessous et corriger les. Question 1 code solution On d\u00e9sire afficher les \u00e9l\u00e9ments de la liste. 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 4 : print ( lst [ i ]) i = i + 1 IndexError : la liste ne contient que 3 \u00e9l\u00e9ments 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 3 : print ( lst [ i ]) i = i + 1 On rapelle qu'il est pr\u00e9f\u00e9rable de parcourir une liste (tableau) en utilisant une boucle for. Exercice 2 code solution 1 2 3 a = 2 b = \"Une fois sur \" print ( b + a ) TypeError : On ne peut pas concat\u00e9ner une chaine de caract\u00e8res avec un int. 1 2 3 a = \"2\" b = \"Une fois sur \" print ( b + a ) ou alors 1 2 3 a = 2 b = \"Une fois sur \" print ( b + str ( a )) Exercice 3 code solution Afficher la somme de tous les \u00e9l\u00e9ments de la liste. 1 2 3 4 l = [ 0 , 4 , 8 , 5 ] for v in l : s = s + v print ( s ) NameError : la variable s n'est pas initialis\u00e9e avant la boucle. L'expression s + v ne peut \u00eatre calcul\u00e9e. ` 1 2 3 4 5 l = [ 0 , 4 , 8 , 5 ] s = 0 # par exemple for v in l : s = s + v print ( s ) Exercice 4 code solution Afficher les \u00e9l\u00e9ments de la liste 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) IndentationError : il manque l'indentation avant le print. ` 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) Exercice 5 code solution Afficher la plus petite valeur contenue dans la liste 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini mini = liste [ i ] print ( mini ) SyntaxError : il manque : dans la condition (ligne 4) 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini : mini = liste [ i ] print ( mini ) Remarques Attention, si l'interpr\u00e9teur Python ne renvoie pas d'erreur, cela ne signifie pas pour autant que votre code est correct. Dans l'exemple de la fonction moyenne qui doit renvoyer la moyenne des valeurs contenues dans un tableau, la fonction fait correctement le travail mais elle ne fonctionne pas sur une liste vide, ou sur une liste qui ne contiendrait pas uniquement des valeurs num\u00e9riques. D'autres erreurs peuvent \u00eatre non affich\u00e9es dans l'interpr\u00e9teur. Par exemple : des instructions conditionnelles qui oublient des cas, des mauvaises conditions ... des boucles qui ne se terminent pas : cas de la boucle while des effets de bords : on modifie une variable globale \u00e0 l'int\u00e9rieur d'une fonction. Il est donc important avant de coder de sp\u00e9cifier une fonction, de docummenter si n\u00e9cessaire une partie du code, de pr\u00e9voir des jeux de tests. Tester, debugger, font partie des bonnes pratiques du programmeur. \u00c7a s'appelle mettre au point du code.","title":"2.2 Quelques erreurs courantes"},{"location":"CH1_map/cours/#3-documenter-et-specifier","text":"","title":"3. Documenter et sp\u00e9cifier"},{"location":"CH1_map/cours/#31-commenter-son-code-ou-pas","text":"Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires.","title":"3.1 Commenter son code ? (ou pas)"},{"location":"CH1_map/cours/#32-le-cas-particulier-des-docstrings","text":"","title":"3.2 Le cas particulier des docstrings"},{"location":"CH1_map/cours/#4-la-programmation-defensive-des-assert-pour-securiser-le-code","text":"La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici .","title":"4. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code"},{"location":"CH1_map/cours/#5-les-tests","text":"","title":"5. Les tests"},{"location":"CH1_map/cours/#51-pourquoi-des-tests","text":"Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok","title":"5.1 Pourquoi des tests ?"},{"location":"CH1_map/cours/#52-revoila-les-assert","text":"Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00e9nonc\u00e9 solution \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste d'entiers liste , suppos\u00e9e non vide, pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) . def test_maxi (): assert maxi ([ 5 ]) == 5 assert maxi ([ - 1 , 5 , 4 , 0 ]) == 5 assert maxi ([ 8 , 7 , 6 , 2 ]) == 8 assert maxi ([ - 1 , - 5 , 0 ]) == 0 def maxi ( liste ): \"\"\" revoie le maximum d'une liste d'entier non vide input : liste (list) d'entiers output : maximum (int) \"\"\" maximum = liste [ 0 ] for elt in liste : if elt > maximum : maximum = elt return maximum","title":"5.2 Revoil\u00e0 les assert"},{"location":"CH1_map/cours/#53-le-module-doctest","text":"Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. On peut, au lieu d'utiliser doctest dans la console Python, placer \u00e0 la fin du fichier le code suivant : if __name__ == '__main__' : import doctest doctest . testmod () Le resultat des tests, si ils ne passent pas, se fera dans l'interpr\u00e9teur \u00e0 chaque execution du code.","title":"5.3 Le module doctest"},{"location":"CH1_map/cours/#53-a-propos-des-tests","text":"Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...","title":"5.3 \u00c0 propos des tests"},{"location":"CH2_recursivite/cours/","text":"CH2 : La r\u00e9cursivit\u00e9 \u2693\ufe0e Programme officiel 1. Premi\u00e8re approche \u2693\ufe0e 1.1. D\u00e9finition \u2693\ufe0e Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition. 1.2 Un tr\u00e8s mauvais exemple \u2693\ufe0e C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : >>> prems () La sortie en console sera celle-ci : un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie . 1.3 La mauvaise r\u00e9putation \u2693\ufe0e Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association. 2. La r\u00e9cursivit\u00e9, \u00e7a marche ! \u2693\ufe0e Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat. 2.1 La r\u00e9cursivit\u00e9 en BD : \u2693\ufe0e Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb : 2.2 Enfin un bon exemple \u2693\ufe0e Exemple fondateur n\u00b01 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: $$ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1$$ Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp() . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec() . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 ) 3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9 \u2693\ufe0e 3.1 Notion de pile \u2693\ufe0e Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile, seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci : 3.2 Limitation de la taille de la pile \u2693\ufe0e Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? mystere ( 2962 ) --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ). 4. Exemples de r\u00e9cursivit\u00e9 double \u2693\ufe0e 4.1 La suite de Fibonnaci \u2693\ufe0e Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonnaci. 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois... 4.2 Comparaison des performances \u2693\ufe0e Exercice \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonnaci. 1 2 3 4 5 6 7 8 def fibo_imperatif ( n ): a = 0 b = 1 for k in range ( n - 1 ): t = b b = a + b a = t return b Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . % timeit fibo_imperatif ( 20 ) 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit fibo_recursif ( 20 ) 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef) 5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle \u2693\ufe0e Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )","title":"CH2 : La r\u00e9cursivit\u00e9"},{"location":"CH2_recursivite/cours/#ch2-la-recursivite","text":"Programme officiel","title":"CH2 : La r\u00e9cursivit\u00e9"},{"location":"CH2_recursivite/cours/#1-premiere-approche","text":"","title":"1. Premi\u00e8re approche"},{"location":"CH2_recursivite/cours/#11-definition","text":"Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition.","title":"1.1. D\u00e9finition"},{"location":"CH2_recursivite/cours/#12-un-tres-mauvais-exemple","text":"C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : >>> prems () La sortie en console sera celle-ci : un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie .","title":"1.2 Un tr\u00e8s mauvais exemple"},{"location":"CH2_recursivite/cours/#13-la-mauvaise-reputation","text":"Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association.","title":"1.3 La mauvaise r\u00e9putation"},{"location":"CH2_recursivite/cours/#2-la-recursivite-ca-marche","text":"Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat.","title":"2. La r\u00e9cursivit\u00e9, \u00e7a marche !"},{"location":"CH2_recursivite/cours/#21-la-recursivite-en-bd","text":"Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb :","title":"2.1 La r\u00e9cursivit\u00e9 en BD :"},{"location":"CH2_recursivite/cours/#22-enfin-un-bon-exemple","text":"Exemple fondateur n\u00b01 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: $$ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1$$ Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp() . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec() . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 )","title":"2.2 Enfin un bon exemple"},{"location":"CH2_recursivite/cours/#3-le-mecanisme-interne-de-la-recursivite","text":"","title":"3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9"},{"location":"CH2_recursivite/cours/#31-notion-de-pile","text":"Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile, seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci :","title":"3.1 Notion de pile"},{"location":"CH2_recursivite/cours/#32-limitation-de-la-taille-de-la-pile","text":"Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? mystere ( 2962 ) --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ).","title":"3.2 Limitation de la taille de la pile"},{"location":"CH2_recursivite/cours/#4-exemples-de-recursivite-double","text":"","title":"4. Exemples de r\u00e9cursivit\u00e9 double"},{"location":"CH2_recursivite/cours/#41-la-suite-de-fibonnaci","text":"Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonnaci. 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois...","title":"4.1 La suite de Fibonnaci"},{"location":"CH2_recursivite/cours/#42-comparaison-des-performances","text":"Exercice \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonnaci. 1 2 3 4 5 6 7 8 def fibo_imperatif ( n ): a = 0 b = 1 for k in range ( n - 1 ): t = b b = a + b a = t return b Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . % timeit fibo_imperatif ( 20 ) 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit fibo_recursif ( 20 ) 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef)","title":"4.2 Comparaison des performances"},{"location":"CH2_recursivite/cours/#5-annexe-dessins-recursifs-grace-au-module-turtle","text":"Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )","title":"5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle"},{"location":"CH3_TDA/cours/","text":"CH3 : Structures de donn\u00e9es \u2693\ufe0e Programme officiel Le langage Python dispose, comme tous les langages de haut niveau, d'un ensemble de types simples et de types structur\u00e9s vus dans le programme de premi\u00e8re : nombres, bool\u00e9ens, cha\u00eenes de caract\u00e8res, tuples, tableaux, dictionnaires ... Ces types de bases sont appell\u00e9s types concrets . Cette ann\u00e9e, comme nous allons manipuler des donn\u00e9es plus complexes que des simples nombres, on va cr\u00e9er des structures de donn\u00e9es plus complexes. Pour d\u00e9finir ces structures, on utilise des types abstraits de donn\u00e9es . 1. Type abstrait de donn\u00e9es \u2693\ufe0e 1.1 Interface \u2693\ufe0e Un type abstrait est caract\u00e9ris\u00e9 par une interface de programmation . L'interface, c'est l'ensemble des op\u00e9rations qui vont permettre de manipuler les donn\u00e9es. On distingue : - les constructeurs qui permettent de cr\u00e9er une nouvelle structure de donn\u00e9es. - les op\u00e9rateurs qui permettent de modifier la structure. On peut par exemple ajouter ou retirer des donn\u00e9es. - les accesseurs qui donnent des informations sur la structure. Par exemple, donner le nombre d'\u00e9l\u00e9ments dans la structure. - les it\u00e9rateurs qui permettent d'\u00e9num\u00e9rer les \u00e9l\u00e9ments de la structure. 1.2 Impl\u00e9mentation \u2693\ufe0e Impl\u00e9menter un type abstrait, c'est coder les diff\u00e9rentes op\u00e9rations qui r\u00e9pondent \u00e0 sp\u00e9cification de l'interface. Il est possible de r\u00e9aliser plusieurs impl\u00e9mentations diff\u00e9rentes pour r\u00e9pondre \u00e0 la m\u00eame sp\u00e9cification. Certaines impl\u00e9mentation vont \u00eatre plus rapides, moins gourmandes en espace m\u00e9moire, plus adapt\u00e9es \u00e0 la taille des donn\u00e9es ... Du concret pour mieux comprendre : INTERFACE vs IMPL\u00c9MENTATION On peut choisir comme image une machine \u00e0 caf\u00e9 \u00e0 capsule, dans laquelle on peut distinguer : L'interface On distinge ici : les boutons, le levier, les petites lumi\u00e8res ... C'est la partie utilisateur . L'impl\u00e9mentation Sur ce sch\u00e9ma apparaissent : les \u00e9lectrovannes, la pompe, le bloc de chauffe, voire le d\u00e9roulement des op\u00e9rations ... C'est la partie constructeur . Pas besoin de savoir comment fonctionne la machine \u00e0 l'int\u00e9rieur (impl\u00e9mentation), pour se faire un caf\u00e9 (interface)... Dans notre programme de terminale, on va pr\u00e9senter plusieurs types abstraits comme : les listes (Ne pas confondre avec le type list de Python), les piles, les files ... On va apprendre \u00e0 utiliser ces types, puis on les impl\u00e9mentera de diff\u00e9rentes fa\u00e7on. 1.3 Exemple des tableaux \u2693\ufe0e En premi\u00e8re, on utilise des objets de type list pour manipuler des donn\u00e9es. Le type list est un type concret du langage Python. Par abus de langage on appelle cela des listes mais en fait ce sont des tableaux dynamiques . L'interface de ce type serait : Op\u00e9rations Exemple(s) complexit\u00e9 Constructeurs l = [] ou l = list() O(1) accesseurs len(l) O(1) l[i] O(1) op\u00e9rateurs l[i] = x O(1) l.append(x) O(1) l.insert(i, x) O(n) l.pop() O(1) del l[i] O(n) it\u00e9rateurs for elt in l O(n) Exercice 1 \u00c9nonc\u00e9 Solution Donner le contenu de la variable l apr\u00e8s avoir executer les instructions ci-dessous : >>> l = list () >>> l . append ( 4 ) >>> l . append ( 6 ) >>> l . insert ( 0 , 6 ) >>> l . pop () >>> l [ 0 ] = 2 >>> l . append ( 3 ) [ 2 , 4 , 3 ] L\u00e0 encore pas besoin de comprendre comment cela fonction. Il suffit juste d'utiliser l'interface. 1.4 Exemples de types abstraits \u2693\ufe0e Voici les diff\u00e9rents types abstraits que l'on va \u00e9tudier cette ann\u00e9e. 2. Les listes \u2693\ufe0e 3. Les piles \u2693\ufe0e 4. Les files \u2693\ufe0e 5. Les dictionnaires \u2693\ufe0e 5.1 tableau associatif \u2693\ufe0e Les dictionnaires ont d\u00e9j\u00e0 \u00e9t\u00e9 \u00e9tudi\u00e9s en classe de premi\u00e8re. Pour rappel, ce type de donn\u00e9es, aussi appel\u00e9 tableau associatif , permet de stocker des valeurs et d'y acc\u00e9der au moyen d'une cl\u00e9 , contrairement au tableau qui permet d'acc\u00e9der \u00e0 une donn\u00e9e au moyen d'un indice . On parle d'association cl\u00e9: valeur . Le langage Python fournit directement le type structur\u00e9 dict qui impl\u00e9mente un dictionnaire. Constructeur : d = dict() ou d = {} , cr\u00e9ation d'un dictionnaire nomm\u00e9 d . op\u00e9rateur : d[cle] = valeur , ajouter une association cle: valeur dans d . accesseur : d[cle] , lire la valeur associ\u00e9e \u00e0 cle dans d . it\u00e9rateur : for cle in d , \u00e9num\u00e8rer toutes les cl\u00e9s de d . Exemple >>> dico = dict () >>> dico [ \"nom\" ] = \"Jannel\" >>> dico [ \"prenom\" ] = \"David\" >>> print ( f : \" {dico[\"nom\"]} {dico[\"prenom\"]} \" ) Jannel David La recherche dans un dictionnaire est optimis\u00e9e pour s'effectuer sur les cl\u00e9s et non sur les valeurs. Par exemple avec le dictionnaire que nous avons cr\u00e9\u00e9 pr\u00e9c\u00e9demment dans l'exemple, la commande \"Nom\" in dico renverra True alors que \"Jannel\" in dico renverra False . Dans un dictionnaire, les cl\u00e9s et les valeurs ne jouent donc pas du tout le m\u00eame r\u00f4le et ne sont pas interchangeables. 5.2 Tables de hachage et cl\u00e9s \u2693\ufe0e Une cl\u00e9 peut \u00eatre d'un autre type que cha\u00eene de caract\u00e8re, du moment que c'est un objet non mutable , c'est \u00e0 dire qui ne peut pas \u00eatre modifi\u00e9. Une cl\u00e9 ne peut pas \u00eatre une liste par exemple car une liste est un objet mutable que l'on peut modifier, par exemple au travers de la m\u00e9thode .append(). Regardons ce qui se passe si on essaye de d\u00e9finir une cl\u00e9 de type list pour un dictionnaire : >>> dico [[ 2 , 1 ]] = \"blablabla ...\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unhashable type : 'list' Le type list n'est pas pas hashable . Mais qu'est-ce que le hachage ? 5.3 Impl\u00e9mentation d'un type dictionnaire \u00e0 l'aide d'une table de hachage \u2693\ufe0e Pr\u00e9sentation du probl\u00e8me \u2693\ufe0e Ici on ne veut pas utiliser directement le type dict de Python. Une impl\u00e9mentation simple consiste \u00e0 cr\u00e9er une liste de tuples (cle, valeur) . Le probl\u00e8me de cette impl\u00e9mentation est dans l'efficacit\u00e9 de la recherche d'une cl\u00e9. On doit parcourir la totalit\u00e9 de la liste au pire des cas et donc la compl\u00e9xit\u00e9 est lin\u00e9aire O(n). Une impl\u00e9mentation plus efficace est donc de continuer \u00e0 utiliser un tableau et \u00e0 transformer la cl\u00e9 en un indice \u00e0 l'aide d'une fonction de hachage. \u00c7a a l'avantage de trouver directement une cl\u00e9 dans le tableau. La fonction de hachage transforme la cl\u00e9 en un indice et il suffit donc de lire la donn\u00e9e stock\u00e9e dans le tableau \u00e0 l'indice correspondant. La complexit\u00e9 de la recherche est donc O(1). Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier table_hachage_cours.py . La fonction de hachage \u2693\ufe0e Si on prend pour cl\u00e9 une chaine de caract\u00e8re, une fonction de hachage peut consister \u00e0 additionner le code ascii de chaque caract\u00e8re, modulo la taille du tableau. HTAILLE = 109 # taille de la table de hachage def hachage ( cle ): code = 0 for car in cle : code = code + ord ( car ) return code % HTAILLE Question \u00c9nonc\u00e9 R\u00e9ponse Quel soucis peut appa\u00eetre avec une telle fonction de hachage ? Il est possible que deux cl\u00e9s diff\u00e9rentes aient le m\u00eame code de hachage. On appelle cela une collision . Une m\u00e9thode pour traiter ces collisions, consiste \u00e0 stocker dans chaque \u00e9l\u00e9ment de la table de hachage, une liste des tuples (cle, valeur) qui on le m\u00eame code de hachage. C'est cette impl\u00e9mentation qui vous est propos\u00e9e ci-dessous. Le constructeur : Cr\u00e9ation du dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 R\u00e9ponse Cr\u00e9er une fonction creer_dico qui ne prend pas d'argument et qui renvoie un tableau contenant HTAILLE cases remplies avec None . def creer_dico (): return [ None ] * HTAILLE Un op\u00e9rateur : Ajouter une entr\u00e9e dans le dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction ajouter qui prend en arguments dico , cle et valeur et qui ajoute le couple (cle, valeur) dans le dictionnaire dico . Utiliser les op\u00e9rations sp\u00e9cifi\u00e9es dans l'interface des listes donn\u00e9es en cours. L'interface et ses op\u00e9rations doivent \u00eatre import\u00e9es dans votre fichier. Les entr\u00e9es de la table de hachage \u00e9tant des listes, il faut penser \u00e0 cr\u00e9er une nouvelle liste si elle n'existe pas avant d'ajouter le tuple au dictionnaire. def ajouter_cle ( dico , cle , valeur ): h = hachage ( cle ) if dico [ h ] == None : dico [ h ] = creer_liste () dico [ h ] = inserer (( cle , valeur ), dico [ h ]) return dico Un accesseur : lire la valeur associ\u00e9e \u00e0 un cl\u00e9 du dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction valeur_cle qui prend en arguments dico et cle . Et qui retourne la valeur associ\u00e9e \u00e0 la cl\u00e9 dans le dictionnaire dico . V\u00e9rifier que le r\u00e9sultat de la fonction de hachage, appliqu\u00e9e \u00e0 la cl\u00e9, correspond \u00e0 une liste sinon retourner None . La fonction elements_liste permet de r\u00e9cup\u00e9rer une liste de tous les tuples pr\u00e9sents dans une liste. def valeur_cle ( dico , cle ): h = hachage ( cle ) if dico [ h ] == None : return None else : for ( c , v ) in elements_liste ( dico [ h ]): if c == cle : return v return None Un it\u00e9rateur : lister les cl\u00e9s pr\u00e9sentes dans un dictionnaire \u2693\ufe0e \u00c9tendre l'interface : \u2693\ufe0e L'objectif est d'ajouter une fonction permettant de connaitre le nombre d'\u00e9l\u00e9ments (couples) pr\u00e9sents dans le dictionnaire. Utiliser l'interface : \u2693\ufe0e Cr\u00e9er une fonction moyenne qui retourne la moyenne des notes pr\u00e9sentes dans un dictionnaire ou les cl\u00e9s seraient des noms d'\u00e9l\u00e8ves et la valeur associ\u00e9e la note.","title":"CH3 : Structures de donn\u00e9es"},{"location":"CH3_TDA/cours/#ch3-structures-de-donnees","text":"Programme officiel Le langage Python dispose, comme tous les langages de haut niveau, d'un ensemble de types simples et de types structur\u00e9s vus dans le programme de premi\u00e8re : nombres, bool\u00e9ens, cha\u00eenes de caract\u00e8res, tuples, tableaux, dictionnaires ... Ces types de bases sont appell\u00e9s types concrets . Cette ann\u00e9e, comme nous allons manipuler des donn\u00e9es plus complexes que des simples nombres, on va cr\u00e9er des structures de donn\u00e9es plus complexes. Pour d\u00e9finir ces structures, on utilise des types abstraits de donn\u00e9es .","title":"CH3 : Structures de donn\u00e9es"},{"location":"CH3_TDA/cours/#1-type-abstrait-de-donnees","text":"","title":"1. Type abstrait de donn\u00e9es"},{"location":"CH3_TDA/cours/#11-interface","text":"Un type abstrait est caract\u00e9ris\u00e9 par une interface de programmation . L'interface, c'est l'ensemble des op\u00e9rations qui vont permettre de manipuler les donn\u00e9es. On distingue : - les constructeurs qui permettent de cr\u00e9er une nouvelle structure de donn\u00e9es. - les op\u00e9rateurs qui permettent de modifier la structure. On peut par exemple ajouter ou retirer des donn\u00e9es. - les accesseurs qui donnent des informations sur la structure. Par exemple, donner le nombre d'\u00e9l\u00e9ments dans la structure. - les it\u00e9rateurs qui permettent d'\u00e9num\u00e9rer les \u00e9l\u00e9ments de la structure.","title":"1.1 Interface"},{"location":"CH3_TDA/cours/#12-implementation","text":"Impl\u00e9menter un type abstrait, c'est coder les diff\u00e9rentes op\u00e9rations qui r\u00e9pondent \u00e0 sp\u00e9cification de l'interface. Il est possible de r\u00e9aliser plusieurs impl\u00e9mentations diff\u00e9rentes pour r\u00e9pondre \u00e0 la m\u00eame sp\u00e9cification. Certaines impl\u00e9mentation vont \u00eatre plus rapides, moins gourmandes en espace m\u00e9moire, plus adapt\u00e9es \u00e0 la taille des donn\u00e9es ... Du concret pour mieux comprendre : INTERFACE vs IMPL\u00c9MENTATION On peut choisir comme image une machine \u00e0 caf\u00e9 \u00e0 capsule, dans laquelle on peut distinguer : L'interface On distinge ici : les boutons, le levier, les petites lumi\u00e8res ... C'est la partie utilisateur . L'impl\u00e9mentation Sur ce sch\u00e9ma apparaissent : les \u00e9lectrovannes, la pompe, le bloc de chauffe, voire le d\u00e9roulement des op\u00e9rations ... C'est la partie constructeur . Pas besoin de savoir comment fonctionne la machine \u00e0 l'int\u00e9rieur (impl\u00e9mentation), pour se faire un caf\u00e9 (interface)... Dans notre programme de terminale, on va pr\u00e9senter plusieurs types abstraits comme : les listes (Ne pas confondre avec le type list de Python), les piles, les files ... On va apprendre \u00e0 utiliser ces types, puis on les impl\u00e9mentera de diff\u00e9rentes fa\u00e7on.","title":"1.2 Impl\u00e9mentation"},{"location":"CH3_TDA/cours/#13-exemple-des-tableaux","text":"En premi\u00e8re, on utilise des objets de type list pour manipuler des donn\u00e9es. Le type list est un type concret du langage Python. Par abus de langage on appelle cela des listes mais en fait ce sont des tableaux dynamiques . L'interface de ce type serait : Op\u00e9rations Exemple(s) complexit\u00e9 Constructeurs l = [] ou l = list() O(1) accesseurs len(l) O(1) l[i] O(1) op\u00e9rateurs l[i] = x O(1) l.append(x) O(1) l.insert(i, x) O(n) l.pop() O(1) del l[i] O(n) it\u00e9rateurs for elt in l O(n) Exercice 1 \u00c9nonc\u00e9 Solution Donner le contenu de la variable l apr\u00e8s avoir executer les instructions ci-dessous : >>> l = list () >>> l . append ( 4 ) >>> l . append ( 6 ) >>> l . insert ( 0 , 6 ) >>> l . pop () >>> l [ 0 ] = 2 >>> l . append ( 3 ) [ 2 , 4 , 3 ] L\u00e0 encore pas besoin de comprendre comment cela fonction. Il suffit juste d'utiliser l'interface.","title":"1.3 Exemple des tableaux"},{"location":"CH3_TDA/cours/#14-exemples-de-types-abstraits","text":"Voici les diff\u00e9rents types abstraits que l'on va \u00e9tudier cette ann\u00e9e.","title":"1.4 Exemples de types abstraits"},{"location":"CH3_TDA/cours/#2-les-listes","text":"","title":"2. Les listes"},{"location":"CH3_TDA/cours/#3-les-piles","text":"","title":"3. Les piles"},{"location":"CH3_TDA/cours/#4-les-files","text":"","title":"4. Les files"},{"location":"CH3_TDA/cours/#5-les-dictionnaires","text":"","title":"5. Les dictionnaires"},{"location":"CH3_TDA/cours/#51-tableau-associatif","text":"Les dictionnaires ont d\u00e9j\u00e0 \u00e9t\u00e9 \u00e9tudi\u00e9s en classe de premi\u00e8re. Pour rappel, ce type de donn\u00e9es, aussi appel\u00e9 tableau associatif , permet de stocker des valeurs et d'y acc\u00e9der au moyen d'une cl\u00e9 , contrairement au tableau qui permet d'acc\u00e9der \u00e0 une donn\u00e9e au moyen d'un indice . On parle d'association cl\u00e9: valeur . Le langage Python fournit directement le type structur\u00e9 dict qui impl\u00e9mente un dictionnaire. Constructeur : d = dict() ou d = {} , cr\u00e9ation d'un dictionnaire nomm\u00e9 d . op\u00e9rateur : d[cle] = valeur , ajouter une association cle: valeur dans d . accesseur : d[cle] , lire la valeur associ\u00e9e \u00e0 cle dans d . it\u00e9rateur : for cle in d , \u00e9num\u00e8rer toutes les cl\u00e9s de d . Exemple >>> dico = dict () >>> dico [ \"nom\" ] = \"Jannel\" >>> dico [ \"prenom\" ] = \"David\" >>> print ( f : \" {dico[\"nom\"]} {dico[\"prenom\"]} \" ) Jannel David La recherche dans un dictionnaire est optimis\u00e9e pour s'effectuer sur les cl\u00e9s et non sur les valeurs. Par exemple avec le dictionnaire que nous avons cr\u00e9\u00e9 pr\u00e9c\u00e9demment dans l'exemple, la commande \"Nom\" in dico renverra True alors que \"Jannel\" in dico renverra False . Dans un dictionnaire, les cl\u00e9s et les valeurs ne jouent donc pas du tout le m\u00eame r\u00f4le et ne sont pas interchangeables.","title":"5.1 tableau associatif"},{"location":"CH3_TDA/cours/#52-tables-de-hachage-et-cles","text":"Une cl\u00e9 peut \u00eatre d'un autre type que cha\u00eene de caract\u00e8re, du moment que c'est un objet non mutable , c'est \u00e0 dire qui ne peut pas \u00eatre modifi\u00e9. Une cl\u00e9 ne peut pas \u00eatre une liste par exemple car une liste est un objet mutable que l'on peut modifier, par exemple au travers de la m\u00e9thode .append(). Regardons ce qui se passe si on essaye de d\u00e9finir une cl\u00e9 de type list pour un dictionnaire : >>> dico [[ 2 , 1 ]] = \"blablabla ...\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unhashable type : 'list' Le type list n'est pas pas hashable . Mais qu'est-ce que le hachage ?","title":"5.2 Tables de hachage et cl\u00e9s"},{"location":"CH3_TDA/cours/#53-implementation-dun-type-dictionnaire-a-laide-dune-table-de-hachage","text":"","title":"5.3 Impl\u00e9mentation d'un type dictionnaire \u00e0 l'aide d'une table de hachage"}]}