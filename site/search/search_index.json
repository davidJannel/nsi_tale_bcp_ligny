{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Le programme officiel \u2693\ufe0e Attention seuls les chapitres abord\u00e9s avec la mention BAC seront \u00e9valu\u00e9s \u00e0 l'\u00e9preuve \u00e9crite. Chapitres et th\u00e8mes abord\u00e9s : \u2693\ufe0e CH1 : Mise au point des programmes - Gestion des bugs (BAC) CH2 : R\u00e9cursivit\u00e9 (BAC) CH3 : Structures de donn\u00e9es - Listes et dictionnaires (BAC) CH4 : Piles et files (BAC) R\u00e9f\u00e9rences : \u2693\ufe0e Livre Hachette - NSI Sp\u00e9cialit\u00e9 terminale Glassus David Roche xyz ...","title":"index"},{"location":"#le-programme-officiel","text":"Attention seuls les chapitres abord\u00e9s avec la mention BAC seront \u00e9valu\u00e9s \u00e0 l'\u00e9preuve \u00e9crite.","title":"Le programme officiel"},{"location":"#chapitres-et-themes-abordes","text":"CH1 : Mise au point des programmes - Gestion des bugs (BAC) CH2 : R\u00e9cursivit\u00e9 (BAC) CH3 : Structures de donn\u00e9es - Listes et dictionnaires (BAC) CH4 : Piles et files (BAC)","title":"Chapitres et th\u00e8mes abord\u00e9s :"},{"location":"#references","text":"Livre Hachette - NSI Sp\u00e9cialit\u00e9 terminale Glassus David Roche xyz ...","title":"R\u00e9f\u00e9rences :"},{"location":"a_propos/","text":"\u00c9crire de maths : \u2693\ufe0e \\[x = \\dfrac{y}{2 \\times z}\\]","title":"\u00c9crire de maths :"},{"location":"a_propos/#ecrire-de-maths","text":"\\[x = \\dfrac{y}{2 \\times z}\\]","title":"\u00c9crire de maths :"},{"location":"CH1_map/cours/","text":"CH1 : Mise au point des programmes - Gestion des bugs \u2693\ufe0e Programme officiel \"La mise au point du programme doit permettre au programme de r\u00e9pondre \u00e0 une sp\u00e9cification, durant cette phase, le programmeur se doit de savoir r\u00e9pondre aux causes typiques de bugs.\" 1. Conventions syntaxiques \u2693\ufe0e La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits : 1.1 Les espaces \u2693\ufe0e \u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/ 1.2 Les conventions de nommage \u2693\ufe0e \u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. (cf : cours de Mme Desmarest) # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass 2. Les erreurs courantes en Python - Savoir lire ses erreurs et corriger son code \u2693\ufe0e Lorsqu'on ex\u00e9cute un programme, il peut fonctionner comme pr\u00e9vu, mais il peut \u00e9galement \"planter\", ou bien ne plus s'arr\u00eater (boucler ind\u00e9finiment). Les sources possibles d'erreurs dans un programme sont nombreuses. En fonction des erreurs rencontr\u00e9es, Python affiche des erreurs sp\u00e9cifiques qui vous aident \u00e0 comprendre quel est le probl\u00e8me dans votre programme. 2.1 Analyser le traceback \u2693\ufe0e Le traceback est l\u2019ensemble des lignes a\ufb00ich\u00e9es par l\u2019interpr\u00e9teur Python lorsqu\u2019une exception est lev\u00e9e. Comprendre le traceback est tr\u00e8s utile pour trouver rapidement une faute et l\u2019expliquer. Voici un exemple de traceback a\ufb00ich\u00e9 lors de l\u2019ex\u00e9cution d\u2019un code: 1 2 3 4 5 6 7 8 def moyenne ( t ): n = len ( t ) s = 0 for i in range ( n ): s = s + t [ i ] return s / n print ( moyenne ([])) >>> % Run moyenne . py Traceback ( most recent call last ): File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 8 , in < module > print ( moyenne ([])) File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 6 , in moyenne return s / n ZeroDivisionError : division by zero Ce traceback est constitu\u00e9 d\u2019une liste de lignes en d\u00e9faut (il y en a 2 ici), puis d\u2019un message qui pr\u00e9cise letype d\u2019exception (c\u2019est la derni\u00e8re ligne). En lisant le traceback de haut en bas, on avance dans le temps. Ce qui s\u2019est produit en dernier est donc \u00e0 la fin du traceback. En le lisant de haut en bas, on note (notez la correspondance entre ce qui est indiqu\u00e9 ci-dessous et le contenudu traceback) : ex\u00e9cution de la ligne 8 \u00ab print(moyenne([])) \u00bb. On entre dans la fonction moyenne qui a provoqu\u00e9 l\u2019ex\u00e9cution de la ligne 6 \u00ab return s / n \u00bb, qui a donc provoqu\u00e9 la lev\u00e9e d\u2019exceptionZeroDivisionError: division by zero La plupart du temps, la lecture des trois derni\u00e8res lignes du traceback permet de cerner le probl\u00e8me : Ici, on effectue une divison par 0. Cela s'est produit lors du renvoie du calcul de s par n. Calcul qui est fait \u00e0 la ligne 6. Cette erreur n'est lev\u00e9e uniquement parceque on a fait appel \u00e0 la fonction moyenne sur un tableau vide. La fonction par elle m\u00eame est correcte. Il faut juste faire attention et pr\u00e9ciser \u00e0 l'utilisateur que la fonction doit \u00eatre appel\u00e9e avec des tableaux non vides. Pour \u00e9viter ces erreurs, il est donc important de : - savoir lire le traceback. - pr\u00e9voir des jeux de tests. - sp\u00e9cifier la fonction pour pouvoir b\u00e9n\u00e9ficier d'une aide \u00e0 l'utilisation de celle-ci. 2.2 Quelques erreurs courantes \u2693\ufe0e Voici quelques erreurs courantes que vous devez apprendre \u00e0 reconnaitre parmi les nombreuses exceptions de Python. Type d'erreur Objet Python Erreurs courantes Exemple Erreurs de syntaxe SyntaxError Erreur de parenth\u00e8se, : manquant avant un bloc d'instruction ... len(t)) Erreurs d'indexation IndexError Acc\u00e8s \u00e0 un index non pr\u00e9sent dans une liste, ou un tuple, str... t = [2, 3] puis print(t[2]) Erreurs de nom NameError Nom de fonction ou de variable mal orthographi\u00e9. print(Bonjour) ou prin(\"Bonjour\") Erreurs d'indentation IndentationError Indentation oubli\u00e9e, ou trop grande, les blocs sont alors mal d\u00e9limit\u00e9s. Erreurs de type TypeError Op\u00e9ration impossible entre deux types(str - int). Conversion de type impossible. '3' * '5' ** Exercices :** Identifier le type d'erreur dans les exerices ci-dessous et corriger les. Question 1 code solution On d\u00e9sire afficher les \u00e9l\u00e9ments de la liste. 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 4 : print ( lst [ i ]) i = i + 1 IndexError : la liste ne contient que 3 \u00e9l\u00e9ments 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 3 : print ( lst [ i ]) i = i + 1 On rapelle qu'il est pr\u00e9f\u00e9rable de parcourir une liste (tableau) en utilisant une boucle for. Exercice 2 code solution 1 2 3 a = 2 b = \"Une fois sur \" print ( b + a ) TypeError : On ne peut pas concat\u00e9ner une chaine de caract\u00e8res avec un int. 1 2 3 a = \"2\" b = \"Une fois sur \" print ( b + a ) ou alors 1 2 3 a = 2 b = \"Une fois sur \" print ( b + str ( a )) Exercice 3 code solution Afficher la somme de tous les \u00e9l\u00e9ments de la liste. 1 2 3 4 l = [ 0 , 4 , 8 , 5 ] for v in l : s = s + v print ( s ) NameError : la variable s n'est pas initialis\u00e9e avant la boucle. L'expression s + v ne peut \u00eatre calcul\u00e9e. ` 1 2 3 4 5 l = [ 0 , 4 , 8 , 5 ] s = 0 # par exemple for v in l : s = s + v print ( s ) Exercice 4 code solution Afficher les \u00e9l\u00e9ments de la liste 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) IndentationError : il manque l'indentation avant le print. ` 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) Exercice 5 code solution Afficher la plus petite valeur contenue dans la liste 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini mini = liste [ i ] print ( mini ) SyntaxError : il manque : dans la condition (ligne 4) 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini : mini = liste [ i ] print ( mini ) Remarques Attention, si l'interpr\u00e9teur Python ne renvoie pas d'erreur, cela ne signifie pas pour autant que votre code est correct. Dans l'exemple de la fonction moyenne qui doit renvoyer la moyenne des valeurs contenues dans un tableau, la fonction fait correctement le travail mais elle ne fonctionne pas sur une liste vide, ou sur une liste qui ne contiendrait pas uniquement des valeurs num\u00e9riques. D'autres erreurs peuvent \u00eatre non affich\u00e9es dans l'interpr\u00e9teur. Par exemple : des instructions conditionnelles qui oublient des cas, des mauvaises conditions ... des boucles qui ne se terminent pas : cas de la boucle while des effets de bords : on modifie une variable globale \u00e0 l'int\u00e9rieur d'une fonction. Il est donc important avant de coder de sp\u00e9cifier une fonction, de docummenter si n\u00e9cessaire une partie du code, de pr\u00e9voir des jeux de tests. Tester, debugger, font partie des bonnes pratiques du programmeur. \u00c7a s'appelle mettre au point du code. 3. Documenter et sp\u00e9cifier \u2693\ufe0e 3.1 Commenter son code ? (ou pas) \u2693\ufe0e Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires. 3.2 Le cas particulier des docstrings \u2693\ufe0e 3.2.1 Que sont les docstrings ? \u2693\ufe0e Les docstrings sont des commentaires normalis\u00e9s pour les fonctions, qui peuvent \u00eatre consult\u00e9s en console. Exemples : Nous connaissons la fonction len() qui permet par exemple de conna\u00eetre la longueur d'une liste pass\u00e9e en param\u00e8tre. Si nous tapons en console la commande print(len.__doc__) , nous aurons la description de cette fonction. >>> len . __doc__ 'Return the number of items in a container.' Il est aussi possible d'acc\u00e9der \u00e0 la docstring d'une fonction f par la commande help(f) : >>> help ( len ) Help on built - in function len in module builtins : len ( obj , / ) Return the number of items in a container . De m\u00eame pour la fonction range : >>> print ( range . __doc__ ) range ( stop ) -> range object range ( start , stop [, step ]) -> range object Return an object that produces a sequence of integers from start ( inclusive ) to stop ( exclusive ) by step . range ( i , j ) produces i , i + 1 , i + 2 , ... , j - 1. start defaults to 0 , and stop is omitted ! range ( 4 ) produces 0 , 1 , 2 , 3. These are exactly the valid indices for a list of 4 elements . When step is given , it specifies the increment ( or decrement ) . Le r\u00e9sultat de la commande help(range) est trop long pour \u00eatre repris ici, mais on y retrouve bien la docstring de la fonction range . 3.2.2 Cr\u00e9er ses propres docstrings \u2693\ufe0e Il suffit pour cela de commencer la fonction \u00e0 documenter par une ou plusieurs phrases entre triples quotes : def capital_apres_n_annees ( capital , taux , nombre_annees ) : \"\"\" Renvoie le capital apr\u00e8s n ann\u00e9es. input : capital : valeur initiale (float) taux : taux d'int\u00e9r\u00eat (float) (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d'ann\u00e9es de placement du capital (int) output : capital apr\u00e8s n ann\u00e9es (float) \"\"\" return capital * ( 1 + taux ) ** nombre_annees Ainsi, un utilisateur pourra trouver en console le mode d'emploi de notre fonction : >>> help ( capital_apres_n_annees ) Help on function capital_apres_n_annees in module __main__ : capital_apres_n_annees ( capital , taux , nombre_annees ) Renvoie le capital apr\u00e8s n ann\u00e9es . capital : valeur initiale taux : taux d 'int\u00e9r\u00eat exprim\u00e9 en nombre d\u00e9cimal (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d 'ann\u00e9es de placement du capital Comme on le voit, tout cela est tr\u00e8s \u00abverbeux\u00bb. Cela peut nous para\u00eetre largement superflu puisque nos codes d\u00e9passent rarement quelques dizaines de lignes et sont lus par rarement plus de 2 personnes. Mais dans la vraie vie des d\u00e9veloppeurs, il est primordial qu'un code soit clair et document\u00e9. \u00c0 retenir des commentaires quand cela est nec\u00e9ssaire des noms de variable explicites une sp\u00e9cification des fonctions avec une docstring sous le mod\u00e8le suivant : def ma_fonction (): \"\"\" que renvoie ma_fonction input : arguments, type output : valeur de sortie, type \"\"\" votre code 4. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code \u2693\ufe0e La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici . 5. Les tests \u2693\ufe0e 5.1 Pourquoi des tests ? \u2693\ufe0e Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok 5.2 Revoil\u00e0 les assert \u2693\ufe0e Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00e9nonc\u00e9 solution \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste d'entiers liste , suppos\u00e9e non vide, pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) . def test_maxi (): assert maxi ([ 5 ]) == 5 assert maxi ([ - 1 , 5 , 4 , 0 ]) == 5 assert maxi ([ 8 , 7 , 6 , 2 ]) == 8 assert maxi ([ - 1 , - 5 , 0 ]) == 0 def maxi ( liste ): \"\"\" revoie le maximum d'une liste d'entier non vide input : liste (list) d'entiers output : maximum (int) \"\"\" maximum = liste [ 0 ] for elt in liste : if elt > maximum : maximum = elt return maximum 5.3 Le module doctest \u2693\ufe0e Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. On peut, au lieu d'utiliser doctest dans la console Python, placer \u00e0 la fin du fichier le code suivant : if __name__ == '__main__' : import doctest doctest . testmod () Le resultat des tests, si ils ne passent pas, se fera dans l'interpr\u00e9teur \u00e0 chaque execution du code. 5.3 \u00c0 propos des tests \u2693\ufe0e Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...","title":"CH1 : Mise au point des programmes"},{"location":"CH1_map/cours/#ch1-mise-au-point-des-programmes-gestion-des-bugs","text":"Programme officiel \"La mise au point du programme doit permettre au programme de r\u00e9pondre \u00e0 une sp\u00e9cification, durant cette phase, le programmeur se doit de savoir r\u00e9pondre aux causes typiques de bugs.\"","title":"CH1 : Mise au point des programmes - Gestion des bugs"},{"location":"CH1_map/cours/#1-conventions-syntaxiques","text":"La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits :","title":"1. Conventions syntaxiques"},{"location":"CH1_map/cours/#11-les-espaces","text":"\u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/","title":"1.1 Les espaces"},{"location":"CH1_map/cours/#12-les-conventions-de-nommage","text":"\u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. (cf : cours de Mme Desmarest) # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass","title":"1.2 Les conventions de nommage"},{"location":"CH1_map/cours/#2-les-erreurs-courantes-en-python-savoir-lire-ses-erreurs-et-corriger-son-code","text":"Lorsqu'on ex\u00e9cute un programme, il peut fonctionner comme pr\u00e9vu, mais il peut \u00e9galement \"planter\", ou bien ne plus s'arr\u00eater (boucler ind\u00e9finiment). Les sources possibles d'erreurs dans un programme sont nombreuses. En fonction des erreurs rencontr\u00e9es, Python affiche des erreurs sp\u00e9cifiques qui vous aident \u00e0 comprendre quel est le probl\u00e8me dans votre programme.","title":"2. Les erreurs courantes en Python - Savoir lire ses erreurs et corriger son code"},{"location":"CH1_map/cours/#21-analyser-le-traceback","text":"Le traceback est l\u2019ensemble des lignes a\ufb00ich\u00e9es par l\u2019interpr\u00e9teur Python lorsqu\u2019une exception est lev\u00e9e. Comprendre le traceback est tr\u00e8s utile pour trouver rapidement une faute et l\u2019expliquer. Voici un exemple de traceback a\ufb00ich\u00e9 lors de l\u2019ex\u00e9cution d\u2019un code: 1 2 3 4 5 6 7 8 def moyenne ( t ): n = len ( t ) s = 0 for i in range ( n ): s = s + t [ i ] return s / n print ( moyenne ([])) >>> % Run moyenne . py Traceback ( most recent call last ): File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 8 , in < module > print ( moyenne ([])) File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 6 , in moyenne return s / n ZeroDivisionError : division by zero Ce traceback est constitu\u00e9 d\u2019une liste de lignes en d\u00e9faut (il y en a 2 ici), puis d\u2019un message qui pr\u00e9cise letype d\u2019exception (c\u2019est la derni\u00e8re ligne). En lisant le traceback de haut en bas, on avance dans le temps. Ce qui s\u2019est produit en dernier est donc \u00e0 la fin du traceback. En le lisant de haut en bas, on note (notez la correspondance entre ce qui est indiqu\u00e9 ci-dessous et le contenudu traceback) : ex\u00e9cution de la ligne 8 \u00ab print(moyenne([])) \u00bb. On entre dans la fonction moyenne qui a provoqu\u00e9 l\u2019ex\u00e9cution de la ligne 6 \u00ab return s / n \u00bb, qui a donc provoqu\u00e9 la lev\u00e9e d\u2019exceptionZeroDivisionError: division by zero La plupart du temps, la lecture des trois derni\u00e8res lignes du traceback permet de cerner le probl\u00e8me : Ici, on effectue une divison par 0. Cela s'est produit lors du renvoie du calcul de s par n. Calcul qui est fait \u00e0 la ligne 6. Cette erreur n'est lev\u00e9e uniquement parceque on a fait appel \u00e0 la fonction moyenne sur un tableau vide. La fonction par elle m\u00eame est correcte. Il faut juste faire attention et pr\u00e9ciser \u00e0 l'utilisateur que la fonction doit \u00eatre appel\u00e9e avec des tableaux non vides. Pour \u00e9viter ces erreurs, il est donc important de : - savoir lire le traceback. - pr\u00e9voir des jeux de tests. - sp\u00e9cifier la fonction pour pouvoir b\u00e9n\u00e9ficier d'une aide \u00e0 l'utilisation de celle-ci.","title":"2.1 Analyser le traceback"},{"location":"CH1_map/cours/#22-quelques-erreurs-courantes","text":"Voici quelques erreurs courantes que vous devez apprendre \u00e0 reconnaitre parmi les nombreuses exceptions de Python. Type d'erreur Objet Python Erreurs courantes Exemple Erreurs de syntaxe SyntaxError Erreur de parenth\u00e8se, : manquant avant un bloc d'instruction ... len(t)) Erreurs d'indexation IndexError Acc\u00e8s \u00e0 un index non pr\u00e9sent dans une liste, ou un tuple, str... t = [2, 3] puis print(t[2]) Erreurs de nom NameError Nom de fonction ou de variable mal orthographi\u00e9. print(Bonjour) ou prin(\"Bonjour\") Erreurs d'indentation IndentationError Indentation oubli\u00e9e, ou trop grande, les blocs sont alors mal d\u00e9limit\u00e9s. Erreurs de type TypeError Op\u00e9ration impossible entre deux types(str - int). Conversion de type impossible. '3' * '5' ** Exercices :** Identifier le type d'erreur dans les exerices ci-dessous et corriger les. Question 1 code solution On d\u00e9sire afficher les \u00e9l\u00e9ments de la liste. 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 4 : print ( lst [ i ]) i = i + 1 IndexError : la liste ne contient que 3 \u00e9l\u00e9ments 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 3 : print ( lst [ i ]) i = i + 1 On rapelle qu'il est pr\u00e9f\u00e9rable de parcourir une liste (tableau) en utilisant une boucle for. Exercice 2 code solution 1 2 3 a = 2 b = \"Une fois sur \" print ( b + a ) TypeError : On ne peut pas concat\u00e9ner une chaine de caract\u00e8res avec un int. 1 2 3 a = \"2\" b = \"Une fois sur \" print ( b + a ) ou alors 1 2 3 a = 2 b = \"Une fois sur \" print ( b + str ( a )) Exercice 3 code solution Afficher la somme de tous les \u00e9l\u00e9ments de la liste. 1 2 3 4 l = [ 0 , 4 , 8 , 5 ] for v in l : s = s + v print ( s ) NameError : la variable s n'est pas initialis\u00e9e avant la boucle. L'expression s + v ne peut \u00eatre calcul\u00e9e. ` 1 2 3 4 5 l = [ 0 , 4 , 8 , 5 ] s = 0 # par exemple for v in l : s = s + v print ( s ) Exercice 4 code solution Afficher les \u00e9l\u00e9ments de la liste 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) IndentationError : il manque l'indentation avant le print. ` 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) Exercice 5 code solution Afficher la plus petite valeur contenue dans la liste 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini mini = liste [ i ] print ( mini ) SyntaxError : il manque : dans la condition (ligne 4) 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini : mini = liste [ i ] print ( mini ) Remarques Attention, si l'interpr\u00e9teur Python ne renvoie pas d'erreur, cela ne signifie pas pour autant que votre code est correct. Dans l'exemple de la fonction moyenne qui doit renvoyer la moyenne des valeurs contenues dans un tableau, la fonction fait correctement le travail mais elle ne fonctionne pas sur une liste vide, ou sur une liste qui ne contiendrait pas uniquement des valeurs num\u00e9riques. D'autres erreurs peuvent \u00eatre non affich\u00e9es dans l'interpr\u00e9teur. Par exemple : des instructions conditionnelles qui oublient des cas, des mauvaises conditions ... des boucles qui ne se terminent pas : cas de la boucle while des effets de bords : on modifie une variable globale \u00e0 l'int\u00e9rieur d'une fonction. Il est donc important avant de coder de sp\u00e9cifier une fonction, de docummenter si n\u00e9cessaire une partie du code, de pr\u00e9voir des jeux de tests. Tester, debugger, font partie des bonnes pratiques du programmeur. \u00c7a s'appelle mettre au point du code.","title":"2.2 Quelques erreurs courantes"},{"location":"CH1_map/cours/#3-documenter-et-specifier","text":"","title":"3. Documenter et sp\u00e9cifier"},{"location":"CH1_map/cours/#31-commenter-son-code-ou-pas","text":"Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires.","title":"3.1 Commenter son code ? (ou pas)"},{"location":"CH1_map/cours/#32-le-cas-particulier-des-docstrings","text":"","title":"3.2 Le cas particulier des docstrings"},{"location":"CH1_map/cours/#4-la-programmation-defensive-des-assert-pour-securiser-le-code","text":"La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici .","title":"4. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code"},{"location":"CH1_map/cours/#5-les-tests","text":"","title":"5. Les tests"},{"location":"CH1_map/cours/#51-pourquoi-des-tests","text":"Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok","title":"5.1 Pourquoi des tests ?"},{"location":"CH1_map/cours/#52-revoila-les-assert","text":"Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00e9nonc\u00e9 solution \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste d'entiers liste , suppos\u00e9e non vide, pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) . def test_maxi (): assert maxi ([ 5 ]) == 5 assert maxi ([ - 1 , 5 , 4 , 0 ]) == 5 assert maxi ([ 8 , 7 , 6 , 2 ]) == 8 assert maxi ([ - 1 , - 5 , 0 ]) == 0 def maxi ( liste ): \"\"\" revoie le maximum d'une liste d'entier non vide input : liste (list) d'entiers output : maximum (int) \"\"\" maximum = liste [ 0 ] for elt in liste : if elt > maximum : maximum = elt return maximum","title":"5.2 Revoil\u00e0 les assert"},{"location":"CH1_map/cours/#53-le-module-doctest","text":"Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. On peut, au lieu d'utiliser doctest dans la console Python, placer \u00e0 la fin du fichier le code suivant : if __name__ == '__main__' : import doctest doctest . testmod () Le resultat des tests, si ils ne passent pas, se fera dans l'interpr\u00e9teur \u00e0 chaque execution du code.","title":"5.3 Le module doctest"},{"location":"CH1_map/cours/#53-a-propos-des-tests","text":"Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...","title":"5.3 \u00c0 propos des tests"},{"location":"CH2_recursivite/cours/","text":"CH2 : La r\u00e9cursivit\u00e9 \u2693\ufe0e Programme officiel 1. Premi\u00e8re approche \u2693\ufe0e 1.1. D\u00e9finition \u2693\ufe0e Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition. 1.2 Un tr\u00e8s mauvais exemple \u2693\ufe0e C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : >>> prems () La sortie en console sera celle-ci : un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie . 1.3 La mauvaise r\u00e9putation \u2693\ufe0e Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association. 2. La r\u00e9cursivit\u00e9, \u00e7a marche ! \u2693\ufe0e Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat. 2.1 La r\u00e9cursivit\u00e9 en BD : \u2693\ufe0e Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb : 2.2 Enfin un bon exemple \u2693\ufe0e Exemple fondateur n\u00b01 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: $$ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1$$ Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp() . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec() . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 ) 3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9 \u2693\ufe0e 3.1 Notion de pile \u2693\ufe0e Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile, seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci : 3.2 Limitation de la taille de la pile \u2693\ufe0e Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? mystere ( 2962 ) --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ). 4. Exemples de r\u00e9cursivit\u00e9 double \u2693\ufe0e 4.1 La suite de Fibonnaci \u2693\ufe0e Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonnaci. 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois... 4.2 Comparaison des performances \u2693\ufe0e Exercice \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonnaci. 1 2 3 4 5 6 7 8 def fibo_imperatif ( n ): a = 0 b = 1 for k in range ( n - 1 ): t = b b = a + b a = t return b Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . % timeit fibo_imperatif ( 20 ) 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit fibo_recursif ( 20 ) 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef) 5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle \u2693\ufe0e Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )","title":"CH2 : La r\u00e9cursivit\u00e9"},{"location":"CH2_recursivite/cours/#ch2-la-recursivite","text":"Programme officiel","title":"CH2 : La r\u00e9cursivit\u00e9"},{"location":"CH2_recursivite/cours/#1-premiere-approche","text":"","title":"1. Premi\u00e8re approche"},{"location":"CH2_recursivite/cours/#11-definition","text":"Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition.","title":"1.1. D\u00e9finition"},{"location":"CH2_recursivite/cours/#12-un-tres-mauvais-exemple","text":"C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : >>> prems () La sortie en console sera celle-ci : un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie .","title":"1.2 Un tr\u00e8s mauvais exemple"},{"location":"CH2_recursivite/cours/#13-la-mauvaise-reputation","text":"Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association.","title":"1.3 La mauvaise r\u00e9putation"},{"location":"CH2_recursivite/cours/#2-la-recursivite-ca-marche","text":"Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat.","title":"2. La r\u00e9cursivit\u00e9, \u00e7a marche !"},{"location":"CH2_recursivite/cours/#21-la-recursivite-en-bd","text":"Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb :","title":"2.1 La r\u00e9cursivit\u00e9 en BD :"},{"location":"CH2_recursivite/cours/#22-enfin-un-bon-exemple","text":"Exemple fondateur n\u00b01 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: $$ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1$$ Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp() . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec() . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 )","title":"2.2 Enfin un bon exemple"},{"location":"CH2_recursivite/cours/#3-le-mecanisme-interne-de-la-recursivite","text":"","title":"3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9"},{"location":"CH2_recursivite/cours/#31-notion-de-pile","text":"Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile, seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci :","title":"3.1 Notion de pile"},{"location":"CH2_recursivite/cours/#32-limitation-de-la-taille-de-la-pile","text":"Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? mystere ( 2962 ) --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ).","title":"3.2 Limitation de la taille de la pile"},{"location":"CH2_recursivite/cours/#4-exemples-de-recursivite-double","text":"","title":"4. Exemples de r\u00e9cursivit\u00e9 double"},{"location":"CH2_recursivite/cours/#41-la-suite-de-fibonnaci","text":"Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonnaci. 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois...","title":"4.1 La suite de Fibonnaci"},{"location":"CH2_recursivite/cours/#42-comparaison-des-performances","text":"Exercice \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonnaci. 1 2 3 4 5 6 7 8 def fibo_imperatif ( n ): a = 0 b = 1 for k in range ( n - 1 ): t = b b = a + b a = t return b Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . % timeit fibo_imperatif ( 20 ) 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit fibo_recursif ( 20 ) 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef)","title":"4.2 Comparaison des performances"},{"location":"CH2_recursivite/cours/#5-annexe-dessins-recursifs-grace-au-module-turtle","text":"Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )","title":"5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle"},{"location":"CH3_TDA/cours/","text":"CH3 : Structures de donn\u00e9es - Listes et dictionnaires \u2693\ufe0e Programme officiel Le langage Python dispose, comme tous les langages de haut niveau, d'un ensemble de types simples et de types structur\u00e9s vus dans le programme de premi\u00e8re : nombres, bool\u00e9ens, cha\u00eenes de caract\u00e8res, tuples, tableaux, dictionnaires ... Ces types de bases sont appell\u00e9s types concrets . Cette ann\u00e9e, comme nous allons manipuler des donn\u00e9es plus complexes que des simples nombres, on va cr\u00e9er des structures de donn\u00e9es plus complexes. Pour d\u00e9finir ces structures, on utilise des types abstraits de donn\u00e9es . 1. Type abstrait de donn\u00e9es \u2693\ufe0e 1.1 Interface \u2693\ufe0e Un type abstrait est caract\u00e9ris\u00e9 par une interface de programmation . L'interface, c'est l'ensemble des op\u00e9rations ou primitives qui vont permettre de manipuler les donn\u00e9es. On distingue : - les constructeurs qui permettent de cr\u00e9er une nouvelle structure de donn\u00e9es. - les op\u00e9rateurs qui permettent de modifier la structure. On peut par exemple ajouter ou retirer des donn\u00e9es. - les accesseurs qui donnent des informations sur la structure. Par exemple, donner le nombre d'\u00e9l\u00e9ments dans la structure. - les it\u00e9rateurs qui permettent d'\u00e9num\u00e9rer les \u00e9l\u00e9ments de la structure. 1.2 Impl\u00e9mentation \u2693\ufe0e Impl\u00e9menter un type abstrait, c'est coder les diff\u00e9rentes op\u00e9rations qui r\u00e9pondent \u00e0 sp\u00e9cification de l'interface. Il est possible de r\u00e9aliser plusieurs impl\u00e9mentations diff\u00e9rentes pour r\u00e9pondre \u00e0 la m\u00eame sp\u00e9cification. Certaines impl\u00e9mentation vont \u00eatre plus rapides, moins gourmandes en espace m\u00e9moire, plus adapt\u00e9es \u00e0 la taille des donn\u00e9es ... Du concret pour mieux comprendre : INTERFACE vs IMPL\u00c9MENTATION On peut choisir comme image une machine \u00e0 caf\u00e9 \u00e0 capsule, dans laquelle on peut distinguer : L'interface On distinge ici : les boutons, le levier, les petites lumi\u00e8res ... C'est la partie utilisateur . L'impl\u00e9mentation Sur ce sch\u00e9ma apparaissent : les \u00e9lectrovannes, la pompe, le bloc de chauffe, voire le d\u00e9roulement des op\u00e9rations ... C'est la partie constructeur . Pas besoin de savoir comment fonctionne la machine \u00e0 l'int\u00e9rieur (impl\u00e9mentation), pour se faire un caf\u00e9 (interface)... Dans notre programme de terminale, on va pr\u00e9senter plusieurs types abstraits comme : les listes (Ne pas confondre avec le type list de Python), les piles, les files ... On va apprendre \u00e0 utiliser ces types, puis on les impl\u00e9mentera de diff\u00e9rentes fa\u00e7on. 1.3 Exemple des tableaux \u2693\ufe0e En premi\u00e8re, on utilise des objets de type list pour manipuler des donn\u00e9es. Le type list est un type concret du langage Python. Par abus de langage on appelle cela des listes mais en fait ce sont des tableaux dynamiques . L'interface de ce type serait : Op\u00e9rations Exemple(s) complexit\u00e9 Constructeurs l = [] ou l = list() O(1) accesseurs len(l) O(1) l[i] O(1) op\u00e9rateurs l[i] = x O(1) l.append(x) O(1) l.insert(i, x) O(n) l.pop() O(1) del l[i] O(n) it\u00e9rateurs for elt in l O(n) Exercice 1 \u00c9nonc\u00e9 Solution Donner le contenu de la variable l apr\u00e8s avoir executer les instructions ci-dessous : >>> l = list () >>> l . append ( 4 ) >>> l . append ( 6 ) >>> l . insert ( 0 , 6 ) >>> l . pop () >>> l [ 0 ] = 2 >>> l . append ( 3 ) [ 2 , 4 , 3 ] L\u00e0 encore pas besoin de comprendre comment cela fonction. Il suffit juste d'utiliser l'interface. 1.4 Exemples de types abstraits \u2693\ufe0e Voici les diff\u00e9rents types abstraits que l'on va \u00e9tudier cette ann\u00e9e. En informatique comme dans la vie courante, il est conseill\u00e9 d'adapter sa mani\u00e8re de stocker et de traiter des donn\u00e9es en fonction de la nature de celles-ci : Le serveur d'un caf\u00e9, charg\u00e9 de transporter les boissons du comptoir aux tables des clients, n'utilisera pas un sac en plastique pour faire le transport : il pr\u00e9f\u00e8rera un plateau. Le chercheur de champignons, lui, n'utilisera pas un plateau pour stocker ses trouvailles : il pr\u00e9f\u00e8rera un panier. Pour stocker des chaussettes, on pr\u00e9f\u00e8rera les entasser dans un tiroir (apr\u00e8s les avoir appair\u00e9es), plut\u00f4t que de les suspendre \u00e0 des cintres. De m\u00eame en informatique, pour chaque type de donn\u00e9es, pour chaque utilisation pr\u00e9vue, une structure particuli\u00e8re de donn\u00e9es se rev\u00e8lera (peut-\u00eatre) plus adapt\u00e9e qu'une autre. Int\u00e9ressons nous par exemple aux donn\u00e9es lin\u00e9aires . Ce sont des donn\u00e9es qui ne comportent pas de hi\u00e9rarchie : toutes les donn\u00e9es sont de la m\u00eame nature et ont le m\u00eame r\u00f4le. Par exemple, un relev\u00e9 mensuel de temp\u00e9ratures, la liste des \u00e9l\u00e8ves d'une classe, un historique d'op\u00e9rations bancaires... Ces donn\u00e9es sont \u00abplates\u00bb, n'ont pas de sous-domaines : la structure de liste para\u00eet parfaitement adapt\u00e9e. Lorsque les donn\u00e9es de cette liste sont en fait des couples (comme dans le cas d'une liste de noms/num\u00e9ros de t\u00e9l\u00e9phone), alors la structure la plus adapt\u00e9e est sans doute celle du dictionnaire . Les listes et les dictionnaires sont donc des exemples de structures de donn\u00e9es lin\u00e9aires . 2. Les listes \u2693\ufe0e 2.1 D\u00e9finitions g\u00e9n\u00e9rales \u2693\ufe0e Une liste est un ensemble ordonn\u00e9 d'objets. G\u00e9n\u00e9ralement, ces donn\u00e9es seront de m\u00eame type, mais ce n'est pas structurellement obligatoire. Lorsque l'impl\u00e9mentation de la liste fait appara\u00eetre une cha\u00eene de valeurs, chacune pointant vers la suivante, on dit que la liste est une liste cha\u00een\u00e9e . L'interface minimale d'une liste est : constructeur : creer_liste() qui retourne une liste vide. accesseur : liste_vide(l) qui retourne True si la liste l est vide. op\u00e9rateur : inserer(e, l) qui ins\u00e8re l'\u00e9l\u00e9ment e dans la liste l et retourne une nouvelle liste. accesseur : tete(l) qui retourne l'\u00e9l\u00e9ment en t\u00eate de liste (si elle n'est pas vide). accesseur : queue(l) qui retourne la liste priv\u00e9e de son premier \u00e9l\u00e9ment (la t\u00eate)(si elle n'est pas vide). it\u00e9rateur : elements_liste(l) qui retourne un tableau contenant les \u00e9l\u00e9ments de la liste l , que l'on peut ensuite \u00e9num\u00e9rer avec une boucle for. 2.2 Exemple d'impl\u00e9mentation par des tuples \u2693\ufe0e On peut impl\u00e9menter une liste en Python en utilisant des tuples. Une liste sera repr\u00e9sent\u00e9e par un tuple (tete, queue) . tete est le premier \u00e9l\u00e9ment de la liste et queue est le reste de la liste, qui est elle m\u00eame une liste. C'est r\u00e9cursif. On peut utiliser la liste de la mani\u00e8re suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> liste = creer_liste () >>> liste = inserer ( \"Alice\" , liste ) >>> liste = inserer ( \"Bob\" , liste ) >>> liste = inserer ( \"Charlie\" , liste ) >>> print ( tete ( liste )) Charlie >>> print ( queue ( liste )) ( \"Bob\" , ( \"Alice\" , ())) >>> for elt in elements_liste ( liste ): print ( elt ) Charlie Bob Alice L'\u00e9tat de la liste apr\u00e8s la ligne 4 est : ( \"Charlie\" , ( \"Bob\" , ( \"Alice\" , ()))) Soit : Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier listes_cours.py . Le constructeur : cr\u00e9ation de la liste \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction creer_liste qui ne prend pas d'argument et qui renvoie un tuple. def creer_liste (): return () Un accesseur : savoir si la liste est vide \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction liste_vide qui prend en argument une liste et qui renvoie True si la liste est vide. def liste_vide ( liste ): return liste == () Un op\u00e9rateur : insertion d'un \u00e9l\u00e9ment \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction inserer qui prend en argument un \u00e9l\u00e9ment et une liste et qui renvoie la liste. L'\u00e9l\u00e9ment est ajout\u00e9 en t\u00eate de liste et la liste vient en queue. def inserer ( elt , liste ): return ( elt , liste ) Des accesseurs : \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er deux fonctions : tete qui prend en argument une liste et qui renvoie l'\u00e9l\u00e9ment en t\u00eate de liste. queue qui prend en argument une liste et qui renvoie la liste priv\u00e9e de sa t\u00eate. V\u00e9rifier pour les deux fonctions que la liste pass\u00e9e en argument n'est pas vide avec un assert . def tete ( liste ): assert not liste_vide ( liste ), \"liste vide\" return liste [ 0 ] def queue ( liste ): assert not liste_vide ( liste ), 'liste vide' return liste [ 1 ] Un it\u00e9rateur : lister les \u00e9l\u00e9ments pr\u00e9sents dans la liste \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction elements_liste qui prend en argument une liste et qui renvoie un tableau contenant les \u00e9l\u00e9ments de la liste. La fonction doit retourner un tableau. Utiliser une boucle while pour parcourir la liste. def elements_liste ( liste ): tab_iter = [] while not liste_vide ( liste ): tab_iter . append ( tete ( liste )) liste = queue ( liste ) return tab_iter \u00c9tendre l'interface \u2693\ufe0e On peut ajouter un accesseur taille qui retourne le nombre d'\u00e9l\u00e9ments de la liste. Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction taille qui prend en argument une liste et qui renvoie le nombre d'\u00e9l\u00e9ments de la liste. def taille ( liste ): nb = 0 while not liste_vide ( liste ): nb = nb + 1 liste = queue ( liste ) return nb 2.3 Autre impl\u00e9mentation et utilisation des listes \u2693\ufe0e Travail \u00e0 r\u00e9aliser sur le notebook TD_listes.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 listes.py avec l'impl\u00e9mentation utilisant la POO. 3. Les dictionnaires \u2693\ufe0e 3.1 tableau associatif \u2693\ufe0e Les dictionnaires ont d\u00e9j\u00e0 \u00e9t\u00e9 \u00e9tudi\u00e9s en classe de premi\u00e8re. Pour rappel, ce type de donn\u00e9es, aussi appel\u00e9 tableau associatif , permet de stocker des valeurs et d'y acc\u00e9der au moyen d'une cl\u00e9 , contrairement au tableau qui permet d'acc\u00e9der \u00e0 une donn\u00e9e au moyen d'un indice . On parle d'association cl\u00e9: valeur . Le langage Python fournit directement le type structur\u00e9 dict qui impl\u00e9mente un dictionnaire. Constructeur : d = dict() ou d = {} , cr\u00e9ation d'un dictionnaire nomm\u00e9 d . op\u00e9rateur : d[cle] = valeur , ajouter une association cle: valeur dans d . accesseur : d[cle] , lire la valeur associ\u00e9e \u00e0 cle dans d . it\u00e9rateur : for cle in d , \u00e9num\u00e8rer toutes les cl\u00e9s de d . Exemple >>> dico = dict () >>> dico [ \"nom\" ] = \"Jannel\" >>> dico [ \"prenom\" ] = \"David\" >>> print ( f : \" {dico[\"nom\"]} {dico[\"prenom\"]} \" ) Jannel David La recherche dans un dictionnaire est optimis\u00e9e pour s'effectuer sur les cl\u00e9s et non sur les valeurs. Par exemple avec le dictionnaire que nous avons cr\u00e9\u00e9 pr\u00e9c\u00e9demment dans l'exemple, la commande \"Nom\" in dico renverra True alors que \"Jannel\" in dico renverra False . Dans un dictionnaire, les cl\u00e9s et les valeurs ne jouent donc pas du tout le m\u00eame r\u00f4le et ne sont pas interchangeables. 3.2 Tables de hachage et cl\u00e9s \u2693\ufe0e Une cl\u00e9 peut \u00eatre d'un autre type que cha\u00eene de caract\u00e8re, du moment que c'est un objet non mutable , c'est \u00e0 dire qui ne peut pas \u00eatre modifi\u00e9. Une cl\u00e9 ne peut pas \u00eatre une liste par exemple car une liste est un objet mutable que l'on peut modifier, par exemple au travers de la m\u00e9thode .append(). Regardons ce qui se passe si on essaye de d\u00e9finir une cl\u00e9 de type list pour un dictionnaire : >>> dico [[ 2 , 1 ]] = \"blablabla ...\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unhashable type : 'list' Le type list n'est pas pas hashable . Mais qu'est-ce que le hachage ? 3.3 Impl\u00e9mentation d'un type dictionnaire \u00e0 l'aide d'une table de hachage \u2693\ufe0e Pr\u00e9sentation du probl\u00e8me \u2693\ufe0e Ici on ne veut pas utiliser directement le type dict de Python. Une impl\u00e9mentation simple consiste \u00e0 cr\u00e9er une liste de tuples (cle, valeur) . Le probl\u00e8me de cette impl\u00e9mentation est dans l'efficacit\u00e9 de la recherche d'une cl\u00e9. On doit parcourir la totalit\u00e9 de la liste au pire des cas et donc la compl\u00e9xit\u00e9 est lin\u00e9aire O(n). Une impl\u00e9mentation plus efficace est donc de continuer \u00e0 utiliser un tableau et \u00e0 transformer la cl\u00e9 en un indice \u00e0 l'aide d'une fonction de hachage. \u00c7a a l'avantage de trouver directement une cl\u00e9 dans le tableau. La fonction de hachage transforme la cl\u00e9 en un indice et il suffit donc de lire la donn\u00e9e stock\u00e9e dans le tableau \u00e0 l'indice correspondant. La complexit\u00e9 de la recherche est donc O(1). Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier table_hachage_cours.py . La fonction de hachage \u2693\ufe0e Si on prend pour cl\u00e9 une chaine de caract\u00e8re, une fonction de hachage peut consister \u00e0 additionner le code ascii de chaque caract\u00e8re, modulo la taille du tableau. HTAILLE = 109 # taille de la table de hachage def hachage ( cle ): code = 0 for car in cle : code = code + ord ( car ) return code % HTAILLE Question Question R\u00e9ponse Quel soucis peut appa\u00eetre avec une telle fonction de hachage ? Il est possible que deux cl\u00e9s diff\u00e9rentes aient le m\u00eame code de hachage. On appelle cela une collision . Une m\u00e9thode pour traiter ces collisions, consiste \u00e0 stocker dans chaque \u00e9l\u00e9ment de la table de hachage, une liste des tuples (cle, valeur) qui on le m\u00eame code de hachage. C'est cette impl\u00e9mentation qui vous est propos\u00e9e ci-dessous. Vous pouvez tester la fonction en prenant HTAILLE = 7 et deux cl\u00e9s comme \"Alice\" et \"Bob\". La fonction renvoie 2 pour les deux cl\u00e9s. Le constructeur : Cr\u00e9ation du dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction creer_dico qui ne prend pas d'argument et qui renvoie un tableau contenant HTAILLE cases remplies avec None . def creer_dico (): return [ None ] * HTAILLE Un op\u00e9rateur : Ajouter une entr\u00e9e dans le dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction ajouter qui prend en arguments dico , cle et valeur et qui ajoute le couple (cle, valeur) dans le dictionnaire dico . Utiliser les op\u00e9rations sp\u00e9cifi\u00e9es dans l'interface des listes donn\u00e9es en cours. L'interface et ses op\u00e9rations doivent \u00eatre import\u00e9es dans votre fichier. Les entr\u00e9es de la table de hachage \u00e9tant des listes, il faut penser \u00e0 cr\u00e9er une nouvelle liste si elle n'existe pas avant d'ajouter le tuple au dictionnaire. def ajouter_cle ( dico , cle , valeur ): h = hachage ( cle ) if dico [ h ] == None : dico [ h ] = creer_liste () dico [ h ] = inserer (( cle , valeur ), dico [ h ]) return dico Un accesseur : lire la valeur associ\u00e9e \u00e0 un cl\u00e9 du dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction valeur_cle qui prend en arguments dico et cle . Et qui retourne la valeur associ\u00e9e \u00e0 la cl\u00e9 dans le dictionnaire dico . V\u00e9rifier que le r\u00e9sultat de la fonction de hachage, appliqu\u00e9e \u00e0 la cl\u00e9, correspond \u00e0 une liste sinon retourner None . La fonction elements_liste permet de r\u00e9cup\u00e9rer une liste de tous les tuples pr\u00e9sents dans une liste. def valeur_cle ( dico , cle ): h = hachage ( cle ) if dico [ h ] == None : return None else : for ( c , v ) in elements_liste ( dico [ h ]): if c == cle : return v return None Un it\u00e9rateur : lister les cl\u00e9s pr\u00e9sentes dans un dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction cle_dico qui prend en arguments dico . Et qui retourne la liste des cl\u00e9s pr\u00e9sentes dans le dictionnaire dico . La fonction doit retourner un tableau de cl\u00e9s. La fonction elements_liste permet de r\u00e9cup\u00e9rer une liste de tous les tuples (cle, valeur) pr\u00e9sents dans une liste. def cles_dico ( dico ): tab_cles = [] for h in range ( len ( dico )): if dico [ h ] != None : for ( c , v ) in elements_liste ( dico [ h ]): tab_cles . append ( c ) return tab_cles \u00c9tendre l'interface : \u2693\ufe0e L'objectif est d'ajouter une fonction permettant de connaitre le nombre d'\u00e9l\u00e9ments (couples) pr\u00e9sents dans le dictionnaire. Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction taille qui prend en arguments dico . Et qui retourne le nombre d'\u00e9l\u00e9ments pr\u00e9sents dans le dictionnaire dico . Une fa\u00e7on de proc\u00e9der est de compter le nombre de cl\u00e9s pr\u00e9sentes dans le tableau renvoy\u00e9 par l'it\u00e9rateur cle_dico . def taille ( dico ): return len ( cles_dico ( dico )) Utiliser l'interface : \u2693\ufe0e Cr\u00e9er une fonction moyenne qui retourne la moyenne des notes pr\u00e9sentes dans un dictionnaire ou les cl\u00e9s seraient des noms d'\u00e9l\u00e8ves et la valeur associ\u00e9e la note. Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction moyenne qui prend en arguments dico . Et qui retourne la moyenne des valeurs pr\u00e9sentes dans le dictionnaire dico . Tester si le dictionnaire n'est pas vide. Utiliser les fonctions cle_dico , valeur_cle et taille pour calculer la moyenne. def moyenne ( dico ): assert cles_dico ( dico ) != [], \"dictionnaire vide\" total = 0 for cle in cles_dico ( dico ): total = total + valeur_cle ( dico , cle ) return total / taille ( dico )","title":"CH3 : Structures de donn\u00e9es - Listes et dictionnaires"},{"location":"CH3_TDA/cours/#ch3-structures-de-donnees-listes-et-dictionnaires","text":"Programme officiel Le langage Python dispose, comme tous les langages de haut niveau, d'un ensemble de types simples et de types structur\u00e9s vus dans le programme de premi\u00e8re : nombres, bool\u00e9ens, cha\u00eenes de caract\u00e8res, tuples, tableaux, dictionnaires ... Ces types de bases sont appell\u00e9s types concrets . Cette ann\u00e9e, comme nous allons manipuler des donn\u00e9es plus complexes que des simples nombres, on va cr\u00e9er des structures de donn\u00e9es plus complexes. Pour d\u00e9finir ces structures, on utilise des types abstraits de donn\u00e9es .","title":"CH3 : Structures de donn\u00e9es - Listes et dictionnaires"},{"location":"CH3_TDA/cours/#1-type-abstrait-de-donnees","text":"","title":"1. Type abstrait de donn\u00e9es"},{"location":"CH3_TDA/cours/#11-interface","text":"Un type abstrait est caract\u00e9ris\u00e9 par une interface de programmation . L'interface, c'est l'ensemble des op\u00e9rations ou primitives qui vont permettre de manipuler les donn\u00e9es. On distingue : - les constructeurs qui permettent de cr\u00e9er une nouvelle structure de donn\u00e9es. - les op\u00e9rateurs qui permettent de modifier la structure. On peut par exemple ajouter ou retirer des donn\u00e9es. - les accesseurs qui donnent des informations sur la structure. Par exemple, donner le nombre d'\u00e9l\u00e9ments dans la structure. - les it\u00e9rateurs qui permettent d'\u00e9num\u00e9rer les \u00e9l\u00e9ments de la structure.","title":"1.1 Interface"},{"location":"CH3_TDA/cours/#12-implementation","text":"Impl\u00e9menter un type abstrait, c'est coder les diff\u00e9rentes op\u00e9rations qui r\u00e9pondent \u00e0 sp\u00e9cification de l'interface. Il est possible de r\u00e9aliser plusieurs impl\u00e9mentations diff\u00e9rentes pour r\u00e9pondre \u00e0 la m\u00eame sp\u00e9cification. Certaines impl\u00e9mentation vont \u00eatre plus rapides, moins gourmandes en espace m\u00e9moire, plus adapt\u00e9es \u00e0 la taille des donn\u00e9es ... Du concret pour mieux comprendre : INTERFACE vs IMPL\u00c9MENTATION On peut choisir comme image une machine \u00e0 caf\u00e9 \u00e0 capsule, dans laquelle on peut distinguer : L'interface On distinge ici : les boutons, le levier, les petites lumi\u00e8res ... C'est la partie utilisateur . L'impl\u00e9mentation Sur ce sch\u00e9ma apparaissent : les \u00e9lectrovannes, la pompe, le bloc de chauffe, voire le d\u00e9roulement des op\u00e9rations ... C'est la partie constructeur . Pas besoin de savoir comment fonctionne la machine \u00e0 l'int\u00e9rieur (impl\u00e9mentation), pour se faire un caf\u00e9 (interface)... Dans notre programme de terminale, on va pr\u00e9senter plusieurs types abstraits comme : les listes (Ne pas confondre avec le type list de Python), les piles, les files ... On va apprendre \u00e0 utiliser ces types, puis on les impl\u00e9mentera de diff\u00e9rentes fa\u00e7on.","title":"1.2 Impl\u00e9mentation"},{"location":"CH3_TDA/cours/#13-exemple-des-tableaux","text":"En premi\u00e8re, on utilise des objets de type list pour manipuler des donn\u00e9es. Le type list est un type concret du langage Python. Par abus de langage on appelle cela des listes mais en fait ce sont des tableaux dynamiques . L'interface de ce type serait : Op\u00e9rations Exemple(s) complexit\u00e9 Constructeurs l = [] ou l = list() O(1) accesseurs len(l) O(1) l[i] O(1) op\u00e9rateurs l[i] = x O(1) l.append(x) O(1) l.insert(i, x) O(n) l.pop() O(1) del l[i] O(n) it\u00e9rateurs for elt in l O(n) Exercice 1 \u00c9nonc\u00e9 Solution Donner le contenu de la variable l apr\u00e8s avoir executer les instructions ci-dessous : >>> l = list () >>> l . append ( 4 ) >>> l . append ( 6 ) >>> l . insert ( 0 , 6 ) >>> l . pop () >>> l [ 0 ] = 2 >>> l . append ( 3 ) [ 2 , 4 , 3 ] L\u00e0 encore pas besoin de comprendre comment cela fonction. Il suffit juste d'utiliser l'interface.","title":"1.3 Exemple des tableaux"},{"location":"CH3_TDA/cours/#14-exemples-de-types-abstraits","text":"Voici les diff\u00e9rents types abstraits que l'on va \u00e9tudier cette ann\u00e9e. En informatique comme dans la vie courante, il est conseill\u00e9 d'adapter sa mani\u00e8re de stocker et de traiter des donn\u00e9es en fonction de la nature de celles-ci : Le serveur d'un caf\u00e9, charg\u00e9 de transporter les boissons du comptoir aux tables des clients, n'utilisera pas un sac en plastique pour faire le transport : il pr\u00e9f\u00e8rera un plateau. Le chercheur de champignons, lui, n'utilisera pas un plateau pour stocker ses trouvailles : il pr\u00e9f\u00e8rera un panier. Pour stocker des chaussettes, on pr\u00e9f\u00e8rera les entasser dans un tiroir (apr\u00e8s les avoir appair\u00e9es), plut\u00f4t que de les suspendre \u00e0 des cintres. De m\u00eame en informatique, pour chaque type de donn\u00e9es, pour chaque utilisation pr\u00e9vue, une structure particuli\u00e8re de donn\u00e9es se rev\u00e8lera (peut-\u00eatre) plus adapt\u00e9e qu'une autre. Int\u00e9ressons nous par exemple aux donn\u00e9es lin\u00e9aires . Ce sont des donn\u00e9es qui ne comportent pas de hi\u00e9rarchie : toutes les donn\u00e9es sont de la m\u00eame nature et ont le m\u00eame r\u00f4le. Par exemple, un relev\u00e9 mensuel de temp\u00e9ratures, la liste des \u00e9l\u00e8ves d'une classe, un historique d'op\u00e9rations bancaires... Ces donn\u00e9es sont \u00abplates\u00bb, n'ont pas de sous-domaines : la structure de liste para\u00eet parfaitement adapt\u00e9e. Lorsque les donn\u00e9es de cette liste sont en fait des couples (comme dans le cas d'une liste de noms/num\u00e9ros de t\u00e9l\u00e9phone), alors la structure la plus adapt\u00e9e est sans doute celle du dictionnaire . Les listes et les dictionnaires sont donc des exemples de structures de donn\u00e9es lin\u00e9aires .","title":"1.4 Exemples de types abstraits"},{"location":"CH3_TDA/cours/#2-les-listes","text":"","title":"2. Les listes"},{"location":"CH3_TDA/cours/#21-definitions-generales","text":"Une liste est un ensemble ordonn\u00e9 d'objets. G\u00e9n\u00e9ralement, ces donn\u00e9es seront de m\u00eame type, mais ce n'est pas structurellement obligatoire. Lorsque l'impl\u00e9mentation de la liste fait appara\u00eetre une cha\u00eene de valeurs, chacune pointant vers la suivante, on dit que la liste est une liste cha\u00een\u00e9e . L'interface minimale d'une liste est : constructeur : creer_liste() qui retourne une liste vide. accesseur : liste_vide(l) qui retourne True si la liste l est vide. op\u00e9rateur : inserer(e, l) qui ins\u00e8re l'\u00e9l\u00e9ment e dans la liste l et retourne une nouvelle liste. accesseur : tete(l) qui retourne l'\u00e9l\u00e9ment en t\u00eate de liste (si elle n'est pas vide). accesseur : queue(l) qui retourne la liste priv\u00e9e de son premier \u00e9l\u00e9ment (la t\u00eate)(si elle n'est pas vide). it\u00e9rateur : elements_liste(l) qui retourne un tableau contenant les \u00e9l\u00e9ments de la liste l , que l'on peut ensuite \u00e9num\u00e9rer avec une boucle for.","title":"2.1 D\u00e9finitions g\u00e9n\u00e9rales"},{"location":"CH3_TDA/cours/#22-exemple-dimplementation-par-des-tuples","text":"On peut impl\u00e9menter une liste en Python en utilisant des tuples. Une liste sera repr\u00e9sent\u00e9e par un tuple (tete, queue) . tete est le premier \u00e9l\u00e9ment de la liste et queue est le reste de la liste, qui est elle m\u00eame une liste. C'est r\u00e9cursif. On peut utiliser la liste de la mani\u00e8re suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> liste = creer_liste () >>> liste = inserer ( \"Alice\" , liste ) >>> liste = inserer ( \"Bob\" , liste ) >>> liste = inserer ( \"Charlie\" , liste ) >>> print ( tete ( liste )) Charlie >>> print ( queue ( liste )) ( \"Bob\" , ( \"Alice\" , ())) >>> for elt in elements_liste ( liste ): print ( elt ) Charlie Bob Alice L'\u00e9tat de la liste apr\u00e8s la ligne 4 est : ( \"Charlie\" , ( \"Bob\" , ( \"Alice\" , ()))) Soit : Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier listes_cours.py .","title":"2.2 Exemple d'impl\u00e9mentation par des tuples"},{"location":"CH3_TDA/cours/#23-autre-implementation-et-utilisation-des-listes","text":"Travail \u00e0 r\u00e9aliser sur le notebook TD_listes.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 listes.py avec l'impl\u00e9mentation utilisant la POO.","title":"2.3 Autre impl\u00e9mentation et utilisation des listes"},{"location":"CH3_TDA/cours/#3-les-dictionnaires","text":"","title":"3. Les dictionnaires"},{"location":"CH3_TDA/cours/#31-tableau-associatif","text":"Les dictionnaires ont d\u00e9j\u00e0 \u00e9t\u00e9 \u00e9tudi\u00e9s en classe de premi\u00e8re. Pour rappel, ce type de donn\u00e9es, aussi appel\u00e9 tableau associatif , permet de stocker des valeurs et d'y acc\u00e9der au moyen d'une cl\u00e9 , contrairement au tableau qui permet d'acc\u00e9der \u00e0 une donn\u00e9e au moyen d'un indice . On parle d'association cl\u00e9: valeur . Le langage Python fournit directement le type structur\u00e9 dict qui impl\u00e9mente un dictionnaire. Constructeur : d = dict() ou d = {} , cr\u00e9ation d'un dictionnaire nomm\u00e9 d . op\u00e9rateur : d[cle] = valeur , ajouter une association cle: valeur dans d . accesseur : d[cle] , lire la valeur associ\u00e9e \u00e0 cle dans d . it\u00e9rateur : for cle in d , \u00e9num\u00e8rer toutes les cl\u00e9s de d . Exemple >>> dico = dict () >>> dico [ \"nom\" ] = \"Jannel\" >>> dico [ \"prenom\" ] = \"David\" >>> print ( f : \" {dico[\"nom\"]} {dico[\"prenom\"]} \" ) Jannel David La recherche dans un dictionnaire est optimis\u00e9e pour s'effectuer sur les cl\u00e9s et non sur les valeurs. Par exemple avec le dictionnaire que nous avons cr\u00e9\u00e9 pr\u00e9c\u00e9demment dans l'exemple, la commande \"Nom\" in dico renverra True alors que \"Jannel\" in dico renverra False . Dans un dictionnaire, les cl\u00e9s et les valeurs ne jouent donc pas du tout le m\u00eame r\u00f4le et ne sont pas interchangeables.","title":"3.1 tableau associatif"},{"location":"CH3_TDA/cours/#32-tables-de-hachage-et-cles","text":"Une cl\u00e9 peut \u00eatre d'un autre type que cha\u00eene de caract\u00e8re, du moment que c'est un objet non mutable , c'est \u00e0 dire qui ne peut pas \u00eatre modifi\u00e9. Une cl\u00e9 ne peut pas \u00eatre une liste par exemple car une liste est un objet mutable que l'on peut modifier, par exemple au travers de la m\u00e9thode .append(). Regardons ce qui se passe si on essaye de d\u00e9finir une cl\u00e9 de type list pour un dictionnaire : >>> dico [[ 2 , 1 ]] = \"blablabla ...\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unhashable type : 'list' Le type list n'est pas pas hashable . Mais qu'est-ce que le hachage ?","title":"3.2 Tables de hachage et cl\u00e9s"},{"location":"CH3_TDA/cours/#33-implementation-dun-type-dictionnaire-a-laide-dune-table-de-hachage","text":"","title":"3.3 Impl\u00e9mentation d'un type dictionnaire \u00e0 l'aide d'une table de hachage"},{"location":"CH4_piles_files/cours/","text":"CH4 : Piles et files \u2693\ufe0e Programme officiel 1. Les piles \u2693\ufe0e 1.1 Qu'est ce qu'une pile ? \u2693\ufe0e Une structure de pile (penser \u00e0 une pile d'assiette) est associ\u00e9e \u00e0 la m\u00e9thode LIFO (Last In, First Out) : les \u00e9l\u00e9ments sont empil\u00e9s les uns au-dessus des autres, et on ne peut toujours d\u00e9piler que l'\u00e9l\u00e9ment du haut de la pile. Le dernier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 \u00eatre sorti. Son interface minimale est : creer_pile() : constructeur qui retourne une pile vide. pile_vide(p) : accesseur qui retourne Vrai si la pile p est vide. empiler(e, p) : op\u00e9rateur qui ajoute l'\u00e9l\u00e9ment e au sommet de la pile p. depiler(p) : op\u00e9rateur qui retire et retourne le sommet de la pile p (si elle n'est pas vide). sommet(p) : accesseur qui retourne le sommet de la pile p (si elle n'est pas vide). elements_pile(p) : it\u00e9rateur qui \u00e9num\u00e8re les \u00e9l\u00e9ments contenus dans la pile p. Exercice : Utilisation de l'interface \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la pile p et la valeur \u00e9ventuellement renvoy\u00e9e. 1. p = creer_pile () 2. p = empiler ( 3 , p ) 3. p = empiler ( 5 , p ) 4. pile_vide ( p ) 4. p = empiler ( 1 , p ) 5. depiler ( p ) 6. depiler ( p ) 7. p = empiler ( 9 , p ) 8. depiler ( p ) 9. depiler ( p ) 10. pile_vide ( p ) 1. p = None # \u00e0 ce stade on a aucune connaissance de l'impl\u00e9mentation utilis\u00e9e 2. p = 3 3. p = 3 , 5 4. Faux 4. p = 3 , 5 , 1 5. p = 3 , 5 et on renvoie 1 6. p = 3 et on renvoie 5 7. p = 3 , 9 8. p = 3 et on renvoie 9 9. p = None et on renvoie 3 10. Vrai 1.2 Exemples d'utilisation de piles en informatique \u2693\ufe0e lors de l'ex\u00e9cution d'une fonction r\u00e9cursive, le processeur empile successivement les appels \u00e0 traiter : seule l'instruction du haut de la pile peut \u00eatre trait\u00e9e. dans un navigateur internet, la liste des pages parcourues est stock\u00e9e sous forme de pile : la fonction \u00abBack\u00bb permet de \u00abd\u00e9piler\u00bb peu \u00e0 peu les pages pr\u00e9c\u00e9demment parcourues : 1.3 Exemple d'impl\u00e9mentation \u2693\ufe0e Une impl\u00e9mentation possible consiste \u00e0 utiliser les tableaux dynamiques (type list de Python). Pour r\u00e9aliser notre impl\u00e9mentation, on utilisera les m\u00e9thodes append , pop ... Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier piles_cours.py . Le constructeur : cr\u00e9ation de la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction creer_pile qui ne prend pas d'argument et qui renvoie un tableau vide (type list ). def creer_pile (): return [] Un accesseur : savoir si la pile est vide \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction pile_vide qui prend en argument une pile et qui renvoie True si la pile est vide. def pile_vide ( pile ): return pile == [] Un op\u00e9rateur : ajout d'un \u00e9l\u00e9ment au sommet de la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction empiler qui prend en argument un \u00e9l\u00e9ment et une liste et place cet \u00e9l\u00e9ment au sommet de la pile. La fonction ne renvoie rien. C'est une proc\u00e9dure. def empiler ( elt , pile ): pile . append ( elt ) Un op\u00e9rateur : retirer un \u00e9l\u00e9ment du sommet de la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction depiler qui prend en argument une pile, retire et retourne le sommet de la pile p (si elle n'est pas vide). V\u00e9rifier que la pile pass\u00e9e en argument n'est pas vide avec un assert . def depiler ( pile ): assert not pile_vide ( pile ), \"pile vide\" sommet = pile . pop () return sommet Un accesseur : Conna\u00eetre le sommet de la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction sommet qui prend en argument une pile et renvoie simplement l'\u00e9l\u00e9ment situ\u00e9 au sommet de la pile (si elle n'est pas vide). V\u00e9rifier que la pile pass\u00e9e en argument n'est pas vide avec un assert . La pile ne doit pas \u00eatre modifi\u00e9e. def sommet ( pile ): assert not pile_vide ( pile ), \"pile vide\" return pile [ - 1 ] Un it\u00e9rateur : lister les \u00e9l\u00e9ments pr\u00e9sents dans la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction elements_pile qui prend en argument une pile et qui renvoie un tableau contenant les \u00e9l\u00e9ments de la pile. Attention, le tableau doit contenir les \u00e9l\u00e9ments parcourus du sommet \u00e0 la base de la pile. Vous pouvez regarder la documentation de la fonction range ( help(range) ). def elements_pile ( pile ): tab_elt = [] for i in range ( len ( pile ) - 1 , - 1 , - 1 ): tab_elt . append ( pile [ i ]) return tab_elt \u00c9tendre l'interface \u2693\ufe0e On peut ajouter un accesseur taille qui retourne le nombre d'\u00e9l\u00e9ments de la pile. Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction taille qui prend en argument une pile et qui renvoie le nombre d'\u00e9l\u00e9ments de la pile. def taille ( pile ): return len ( pile ) 1.4 TD - Impl\u00e9mentation utilisant la POO et utilisation des piles \u2693\ufe0e Travail \u00e0 r\u00e9aliser sur le notebook TD_piles.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 piles.py avec l'impl\u00e9mentation utilisant la POO. 1.5 TP - R\u00e9alisation d'une calculatrice \u2693\ufe0e Dans les ann\u00e9es 90, les calculatrices HP \u00e9taient tr\u00e8s r\u00e9put\u00e9es dans le milieu scientifique pour la richesse de leures fonctionnalit\u00e9s. Elles poss\u00e9daient une autre particularit\u00e9 : elles utilisaient la notation dite \"polonaise invers\u00e9e\" NPI pour effectuer les calculs. Cela signifie que l'on entrait d'abord les \u00e9l\u00e9ments pour faire le calcul puis ensuite l'op\u00e9rateur. Par exemple, pour effectuer l'op\u00e9ration 4 + 3 on entrait successivement 4 puis 3 et enfin +. On peut donner encore d'autres exemples : pour calculer (2+3)*11 , on entrera la chaine de caract\u00e8re \" 2 3 + 11 * \". On aurait d'ailleurs le m\u00eame r\u00e9sultat avec la chaine de caract\u00e8re \" 11 2 3 + * \" qui repr\u00e9senterait 11*(2+3) . L'algorithme pour calculer le r\u00e9sultat d'un calcul en notation polonaise invers\u00e9 utilise une pile. On proc\u00e9de de la fa\u00e7on suivante. Pour chaque \u00e9l\u00e9ment de l'expression : si c'est un nombre on le place dans la pile. si c'est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux nombres au sommet de la pile et on leur applique l'op\u00e9rateur (le premier sommet est \u00e0 droite de l'op\u00e9rateur, ce qui est important pour les soustractions et les divisions). Vous allez r\u00e9aliser une calculatrice NPI \u00e0 partir de la classe de pile que nous avons fait pr\u00e9cedemment. Travail \u00e0 faire Consignes Code \u00e0 compl\u00e9ter Pour faire une calculatrice NPI, vous compl\u00e9terez la fonction calcule qui prend en entr\u00e9e une chaine de caract\u00e8re not\u00e9e expression qui est une expression en notation polonaise invers\u00e9e, et qui renvoi en sortie la valeur du r\u00e9sultat. Si la chaine est bien form\u00e9e, la pile ne contient plus qu'un seul \u00e9l\u00e9ment qui est le r\u00e9sultat. Si la chaine est mal form\u00e9e, la fonction doit renvoyer None . Pour faciliter votre travail, la chaine est s\u00e9par\u00e9e en \u00e9lements dans un tableau gr\u00e2ce \u00e0 split, et il n'y a plus qu'\u00e0 boucler sur le tableau. Des assertions ont \u00e9t\u00e9 fournies pour vous aider \u00e0 v\u00e9rifier votre travail. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class cellule : \"\"\" Classe qui mod\u00e9lise une cellule dans une structure lin\u00e9aire \"\"\" def __init__ ( self , element ): self . contenu = element self . suivant = None class pile : \"\"\" Classe qui impl\u00e9mente une pile\"\"\" def __init__ ( self ): self . sommet = None def estVide ( self ): return self . sommet == None def empile ( self , element ): nouveau = cellule ( element ) nouveau . suivant = self . sommet self . sommet = nouveau def depile ( self ): valeur = self . sommet . contenu self . sommet = self . sommet . suivant return valeur def affiche ( self ): pointeur = self . sommet while pointeur != None : print ( pointeur . contenu ) pointeur = pointeur . suivant def calcule ( expression ): valeur = None tableau = expression . split () ### Mettez votre code ici return valeur assert calcule ( '2 3 + 11 *' ) == 55 , \"erreur sur le premier calcul\" assert calcule ( '2 5 * 7 +' ) == 17 , \"erreur sur le second calcul\" assert calcule ( '8 2 / 4 - ' ) == 0 , \"erreur sur le troisi\u00e8me calcul\" assert calcule ( '1 2 3 4 + * +' ) == 15 , \"erreur sur le quatri\u00e8me calcul\" assert calcule ( \"1 2 3 + \" ) == None , \" chaine mal form\u00e9e mais valeur retourn\u00e9e\" 2. Les files \u2693\ufe0e Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier files_cours.py . 2.1 Qu'est ce qu'une file ? \u2693\ufe0e Une structure de file (penser \u00e0 une file d'attente) est associ\u00e9e \u00e0 la m\u00e9thode FIFO (First In, First Out) : les \u00e9l\u00e9ments sont enfil\u00e9s les uns \u00e0 la suite des autres, et on ne peut toujours d\u00e9filer que l'\u00e9l\u00e9ment en t\u00eate de la file. Le premier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 en sortir. Sinon \u00e7a r\u00e2le dans la file d'attente. Son interface minimale est : creer_file : constructeur qui retourne une file vide. file_vide(f) : accesseur qui retourne vrai si la file f est vide. enfiler(e, f) : op\u00e9rateur qui ajoute l'\u00e9l\u00e9ment e \u00e0 la fin de la file f. defiler(f) : op\u00e9rateur qui retire l'\u00e9l\u00e9ment plac\u00e9 en t\u00eate de file (si elle n'est pas vide). tete_file(f) : accesseur qui retourne l'\u00e9l\u00e9ment plac\u00e9 en t\u00eate de la file f (si elle n'est pas vide). elements_file(f) : it\u00e9rateur qui \u00e9num\u00e8re les \u00e9l\u00e9ments de la file f. Exercice : Utilisation de l'interface \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la file f et la valeur \u00e9ventuellement renvoy\u00e9e. La convention choisie est : on enfilera \u00e0 droite et on d\u00e9filera \u00e0 gauche . 1. f = creer_file () 2. enfiler ( 3 , f ) 3. enfiler ( 5 , f ) 4. file_vide ( f ) 5. enfiler ( 1 , f ) 6. defiler ( f ) 7. defile ( f ) 8. enfiler ( 9 , f ) 9. defiler ( f ) 10. defiler ( f ) 11. file_vide ( f ) 1. f = # d\u00e9pend de l'impl\u00e9mentation utilis\u00e9e 2. f = 3 3. f = 3 , 5 4. faux 5. f = 3 , 5 , 1 6. valeur renvoy\u00e9e : 3 , f = 5 , 1 7. valeur renvoy\u00e9e : 5 , f = 1 8. f = 1 , 9 9. valeur renvoy\u00e9e : 1 , f = 9 10. valeur renvoy\u00e9e : 9 , f = 11. vrai 2.2 Exemples d'utilisation de files en informatique \u2693\ufe0e Serveurs d'impression : Spoolers qui traitent ainsi les requ\u00eates dans l'ordre dans lequel elles arrivent, et les ins\u00e8rent dans une file d'attente (dite aussi queue ou spool ). Certains moteurs multit\u00e2ches dans un OS , qui doivent accorder du temps-machine \u00e0 chaque t\u00e2che, sans en privil\u00e9gier aucune. 2.3 Exemple d'impl\u00e9m\u00e9ntation \u2693\ufe0e Comme pour les piles, une impl\u00e9mentation possible consiste \u00e0 utiliser les tableaux dynamiques (type list de Python). Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier files_cours.py . Le constructeur : cr\u00e9ation de la file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction creer_file qui ne prend pas d'argument et qui renvoie un tableau vide (type list ). def creer_file (): return [] Un accesseur : savoir si la file est vide \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction file_vide qui prend en argument une file et qui renvoie True si la file est vide. def file_vide ( file ): return file == [] Un op\u00e9rateur : ajout d'un \u00e9l\u00e9ment en queue de file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction enfiler qui prend en argument un \u00e9l\u00e9ment et une liste et place cet \u00e9l\u00e9ment en queue de file. La fonction ne renvoie rien. C'est une proc\u00e9dure. def enfiler ( elt , file ): file . append ( elt ) Un op\u00e9rateur : retirer un \u00e9l\u00e9ment de la file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction defiler qui prend en argument une file, retire et retourne la t\u00eate de la file f (si elle n'est pas vide). V\u00e9rifier que la file pass\u00e9e en argument n'est pas vide avec un assert . def defiler ( file ): assert not file_vide ( file ), \"file vide\" tete = file . pop ( 0 ) return tete Un accesseur : Conna\u00eetre la tete de la file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction tete_file qui prend en argument une file et renvoie simplement l'\u00e9l\u00e9ment situ\u00e9 en t\u00eate de la file (si elle n'est pas vide). V\u00e9rifier que la file pass\u00e9e en argument n'est pas vide avec un assert . La file ne doit pas \u00eatre modifi\u00e9e. def tete_file ( file ): assert not file_vide ( file ), \"file vide\" return file [ 0 ] Un it\u00e9rateur : lister les \u00e9l\u00e9ments pr\u00e9sents dans la file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction elements_file qui prend en argument une file et qui renvoie un tableau contenant les \u00e9l\u00e9ments de la file. Attention, le tableau doit contenir les \u00e9l\u00e9ments parcourus de la queue \u00e0 la t\u00eate de la file. def elements_file ( file ): return file \u00c9tendre l'interface \u2693\ufe0e On peut ajouter un accesseur taille qui retourne le nombre d'\u00e9l\u00e9ments de la file. Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction taille qui prend en argument une file et qui renvoie le nombre d'\u00e9l\u00e9ments de la file. def taille ( file ): return len ( file ) 2.4 TD - Impl\u00e9mentation utilisant la POO et utilisation des files \u2693\ufe0e Travail \u00e0 r\u00e9aliser \u00e0 partir du TD_files.pdf en cr\u00e9ant un notebook not\u00e9 : TD_files.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 files.py avec l'impl\u00e9mentation utilisant la POO.","title":"CH4 : Piles et files"},{"location":"CH4_piles_files/cours/#ch4-piles-et-files","text":"Programme officiel","title":"CH4 : Piles et files"},{"location":"CH4_piles_files/cours/#1-les-piles","text":"","title":"1. Les piles"},{"location":"CH4_piles_files/cours/#11-quest-ce-quune-pile","text":"Une structure de pile (penser \u00e0 une pile d'assiette) est associ\u00e9e \u00e0 la m\u00e9thode LIFO (Last In, First Out) : les \u00e9l\u00e9ments sont empil\u00e9s les uns au-dessus des autres, et on ne peut toujours d\u00e9piler que l'\u00e9l\u00e9ment du haut de la pile. Le dernier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 \u00eatre sorti. Son interface minimale est : creer_pile() : constructeur qui retourne une pile vide. pile_vide(p) : accesseur qui retourne Vrai si la pile p est vide. empiler(e, p) : op\u00e9rateur qui ajoute l'\u00e9l\u00e9ment e au sommet de la pile p. depiler(p) : op\u00e9rateur qui retire et retourne le sommet de la pile p (si elle n'est pas vide). sommet(p) : accesseur qui retourne le sommet de la pile p (si elle n'est pas vide). elements_pile(p) : it\u00e9rateur qui \u00e9num\u00e8re les \u00e9l\u00e9ments contenus dans la pile p. Exercice : Utilisation de l'interface \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la pile p et la valeur \u00e9ventuellement renvoy\u00e9e. 1. p = creer_pile () 2. p = empiler ( 3 , p ) 3. p = empiler ( 5 , p ) 4. pile_vide ( p ) 4. p = empiler ( 1 , p ) 5. depiler ( p ) 6. depiler ( p ) 7. p = empiler ( 9 , p ) 8. depiler ( p ) 9. depiler ( p ) 10. pile_vide ( p ) 1. p = None # \u00e0 ce stade on a aucune connaissance de l'impl\u00e9mentation utilis\u00e9e 2. p = 3 3. p = 3 , 5 4. Faux 4. p = 3 , 5 , 1 5. p = 3 , 5 et on renvoie 1 6. p = 3 et on renvoie 5 7. p = 3 , 9 8. p = 3 et on renvoie 9 9. p = None et on renvoie 3 10. Vrai","title":"1.1 Qu'est ce qu'une pile ?"},{"location":"CH4_piles_files/cours/#12-exemples-dutilisation-de-piles-en-informatique","text":"lors de l'ex\u00e9cution d'une fonction r\u00e9cursive, le processeur empile successivement les appels \u00e0 traiter : seule l'instruction du haut de la pile peut \u00eatre trait\u00e9e. dans un navigateur internet, la liste des pages parcourues est stock\u00e9e sous forme de pile : la fonction \u00abBack\u00bb permet de \u00abd\u00e9piler\u00bb peu \u00e0 peu les pages pr\u00e9c\u00e9demment parcourues :","title":"1.2 Exemples d'utilisation de piles en informatique"},{"location":"CH4_piles_files/cours/#13-exemple-dimplementation","text":"Une impl\u00e9mentation possible consiste \u00e0 utiliser les tableaux dynamiques (type list de Python). Pour r\u00e9aliser notre impl\u00e9mentation, on utilisera les m\u00e9thodes append , pop ... Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier piles_cours.py .","title":"1.3 Exemple d'impl\u00e9mentation"},{"location":"CH4_piles_files/cours/#14-td-implementation-utilisant-la-poo-et-utilisation-des-piles","text":"Travail \u00e0 r\u00e9aliser sur le notebook TD_piles.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 piles.py avec l'impl\u00e9mentation utilisant la POO.","title":"1.4 TD - Impl\u00e9mentation utilisant la POO et utilisation des piles"},{"location":"CH4_piles_files/cours/#15-tp-realisation-dune-calculatrice","text":"Dans les ann\u00e9es 90, les calculatrices HP \u00e9taient tr\u00e8s r\u00e9put\u00e9es dans le milieu scientifique pour la richesse de leures fonctionnalit\u00e9s. Elles poss\u00e9daient une autre particularit\u00e9 : elles utilisaient la notation dite \"polonaise invers\u00e9e\" NPI pour effectuer les calculs. Cela signifie que l'on entrait d'abord les \u00e9l\u00e9ments pour faire le calcul puis ensuite l'op\u00e9rateur. Par exemple, pour effectuer l'op\u00e9ration 4 + 3 on entrait successivement 4 puis 3 et enfin +. On peut donner encore d'autres exemples : pour calculer (2+3)*11 , on entrera la chaine de caract\u00e8re \" 2 3 + 11 * \". On aurait d'ailleurs le m\u00eame r\u00e9sultat avec la chaine de caract\u00e8re \" 11 2 3 + * \" qui repr\u00e9senterait 11*(2+3) . L'algorithme pour calculer le r\u00e9sultat d'un calcul en notation polonaise invers\u00e9 utilise une pile. On proc\u00e9de de la fa\u00e7on suivante. Pour chaque \u00e9l\u00e9ment de l'expression : si c'est un nombre on le place dans la pile. si c'est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux nombres au sommet de la pile et on leur applique l'op\u00e9rateur (le premier sommet est \u00e0 droite de l'op\u00e9rateur, ce qui est important pour les soustractions et les divisions). Vous allez r\u00e9aliser une calculatrice NPI \u00e0 partir de la classe de pile que nous avons fait pr\u00e9cedemment. Travail \u00e0 faire Consignes Code \u00e0 compl\u00e9ter Pour faire une calculatrice NPI, vous compl\u00e9terez la fonction calcule qui prend en entr\u00e9e une chaine de caract\u00e8re not\u00e9e expression qui est une expression en notation polonaise invers\u00e9e, et qui renvoi en sortie la valeur du r\u00e9sultat. Si la chaine est bien form\u00e9e, la pile ne contient plus qu'un seul \u00e9l\u00e9ment qui est le r\u00e9sultat. Si la chaine est mal form\u00e9e, la fonction doit renvoyer None . Pour faciliter votre travail, la chaine est s\u00e9par\u00e9e en \u00e9lements dans un tableau gr\u00e2ce \u00e0 split, et il n'y a plus qu'\u00e0 boucler sur le tableau. Des assertions ont \u00e9t\u00e9 fournies pour vous aider \u00e0 v\u00e9rifier votre travail. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class cellule : \"\"\" Classe qui mod\u00e9lise une cellule dans une structure lin\u00e9aire \"\"\" def __init__ ( self , element ): self . contenu = element self . suivant = None class pile : \"\"\" Classe qui impl\u00e9mente une pile\"\"\" def __init__ ( self ): self . sommet = None def estVide ( self ): return self . sommet == None def empile ( self , element ): nouveau = cellule ( element ) nouveau . suivant = self . sommet self . sommet = nouveau def depile ( self ): valeur = self . sommet . contenu self . sommet = self . sommet . suivant return valeur def affiche ( self ): pointeur = self . sommet while pointeur != None : print ( pointeur . contenu ) pointeur = pointeur . suivant def calcule ( expression ): valeur = None tableau = expression . split () ### Mettez votre code ici return valeur assert calcule ( '2 3 + 11 *' ) == 55 , \"erreur sur le premier calcul\" assert calcule ( '2 5 * 7 +' ) == 17 , \"erreur sur le second calcul\" assert calcule ( '8 2 / 4 - ' ) == 0 , \"erreur sur le troisi\u00e8me calcul\" assert calcule ( '1 2 3 4 + * +' ) == 15 , \"erreur sur le quatri\u00e8me calcul\" assert calcule ( \"1 2 3 + \" ) == None , \" chaine mal form\u00e9e mais valeur retourn\u00e9e\"","title":"1.5 TP - R\u00e9alisation d'une calculatrice"},{"location":"CH4_piles_files/cours/#2-les-files","text":"Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier files_cours.py .","title":"2. Les files"},{"location":"CH4_piles_files/cours/#21-quest-ce-quune-file","text":"Une structure de file (penser \u00e0 une file d'attente) est associ\u00e9e \u00e0 la m\u00e9thode FIFO (First In, First Out) : les \u00e9l\u00e9ments sont enfil\u00e9s les uns \u00e0 la suite des autres, et on ne peut toujours d\u00e9filer que l'\u00e9l\u00e9ment en t\u00eate de la file. Le premier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 en sortir. Sinon \u00e7a r\u00e2le dans la file d'attente. Son interface minimale est : creer_file : constructeur qui retourne une file vide. file_vide(f) : accesseur qui retourne vrai si la file f est vide. enfiler(e, f) : op\u00e9rateur qui ajoute l'\u00e9l\u00e9ment e \u00e0 la fin de la file f. defiler(f) : op\u00e9rateur qui retire l'\u00e9l\u00e9ment plac\u00e9 en t\u00eate de file (si elle n'est pas vide). tete_file(f) : accesseur qui retourne l'\u00e9l\u00e9ment plac\u00e9 en t\u00eate de la file f (si elle n'est pas vide). elements_file(f) : it\u00e9rateur qui \u00e9num\u00e8re les \u00e9l\u00e9ments de la file f. Exercice : Utilisation de l'interface \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la file f et la valeur \u00e9ventuellement renvoy\u00e9e. La convention choisie est : on enfilera \u00e0 droite et on d\u00e9filera \u00e0 gauche . 1. f = creer_file () 2. enfiler ( 3 , f ) 3. enfiler ( 5 , f ) 4. file_vide ( f ) 5. enfiler ( 1 , f ) 6. defiler ( f ) 7. defile ( f ) 8. enfiler ( 9 , f ) 9. defiler ( f ) 10. defiler ( f ) 11. file_vide ( f ) 1. f = # d\u00e9pend de l'impl\u00e9mentation utilis\u00e9e 2. f = 3 3. f = 3 , 5 4. faux 5. f = 3 , 5 , 1 6. valeur renvoy\u00e9e : 3 , f = 5 , 1 7. valeur renvoy\u00e9e : 5 , f = 1 8. f = 1 , 9 9. valeur renvoy\u00e9e : 1 , f = 9 10. valeur renvoy\u00e9e : 9 , f = 11. vrai","title":"2.1 Qu'est ce qu'une file ?"},{"location":"CH4_piles_files/cours/#22-exemples-dutilisation-de-files-en-informatique","text":"Serveurs d'impression : Spoolers qui traitent ainsi les requ\u00eates dans l'ordre dans lequel elles arrivent, et les ins\u00e8rent dans une file d'attente (dite aussi queue ou spool ). Certains moteurs multit\u00e2ches dans un OS , qui doivent accorder du temps-machine \u00e0 chaque t\u00e2che, sans en privil\u00e9gier aucune.","title":"2.2 Exemples d'utilisation de files en informatique"},{"location":"CH4_piles_files/cours/#23-exemple-dimplementation","text":"Comme pour les piles, une impl\u00e9mentation possible consiste \u00e0 utiliser les tableaux dynamiques (type list de Python). Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier files_cours.py .","title":"2.3 Exemple d'impl\u00e9m\u00e9ntation"},{"location":"CH4_piles_files/cours/#24-td-implementation-utilisant-la-poo-et-utilisation-des-files","text":"Travail \u00e0 r\u00e9aliser \u00e0 partir du TD_files.pdf en cr\u00e9ant un notebook not\u00e9 : TD_files.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 files.py avec l'impl\u00e9mentation utilisant la POO.","title":"2.4 TD - Impl\u00e9mentation utilisant la POO et utilisation des files"}]}