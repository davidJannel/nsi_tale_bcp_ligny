{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Terminale sp\u00e9cialit\u00e9 NSI \u2693\ufe0e Le programme officiel \u2693\ufe0e Attention seuls les chapitres abord\u00e9s avec la mention BAC seront \u00e9valu\u00e9s \u00e0 l'\u00e9preuve \u00e9crite. \u2693\ufe0e Chapitres et th\u00e8mes abord\u00e9s en cours avec moi: \u2693\ufe0e CH1 : Mise au point des programmes - Gestion des bugs (BAC) CH2 : R\u00e9cursivit\u00e9 (BAC) CH3 : Structures de donn\u00e9es - Listes et dictionnaires (BAC) CH4 : Piles et files (BAC) CH5 : Syst\u00e8mes sur puce SOC (BAC) CH6 : Gestion des processus (BAC) CH7 : Graphes et parcours de graphes CH8 : Routage (BAC) CH9 : Cryptographie - S\u00e9curisation des communications CH10 : Diviser pour r\u00e9gner (BAC) CH11 : Modularit\u00e9 - API R\u00e9f\u00e9rences et sites utilis\u00e9s: \u2693\ufe0e Livre Hachette - NSI Sp\u00e9cialit\u00e9 terminale Alain BUSSER : https://alainbusser.frama.io/NSI-IREMI-974/ Guillaume Connan: https://gitlab.com/lyceeND/tale Romain Janvier : nsiterminale.janviercommelemois.fr Gilles LASSUS: https://glassus.github.io/terminale_nsi/ Anne GELLIER : https://angellier.gitlab.io/nsi/terminale/ Pixees - David Roche eskool - Tale NSI - Rodrigo Schwencke","title":"Accueil"},{"location":"#terminale-specialite-nsi","text":"","title":"Terminale sp\u00e9cialit\u00e9 NSI"},{"location":"#le-programme-officiel","text":"","title":"Le programme officiel"},{"location":"#attention-seuls-les-chapitres-abordes-avec-la-mention-bac-seront-evalues-a-lepreuve-ecrite","text":"","title":"Attention seuls les chapitres abord\u00e9s avec la mention BAC seront \u00e9valu\u00e9s \u00e0 l'\u00e9preuve \u00e9crite."},{"location":"#chapitres-et-themes-abordes-en-cours-avec-moi","text":"CH1 : Mise au point des programmes - Gestion des bugs (BAC) CH2 : R\u00e9cursivit\u00e9 (BAC) CH3 : Structures de donn\u00e9es - Listes et dictionnaires (BAC) CH4 : Piles et files (BAC) CH5 : Syst\u00e8mes sur puce SOC (BAC) CH6 : Gestion des processus (BAC) CH7 : Graphes et parcours de graphes CH8 : Routage (BAC) CH9 : Cryptographie - S\u00e9curisation des communications CH10 : Diviser pour r\u00e9gner (BAC) CH11 : Modularit\u00e9 - API","title":"Chapitres et th\u00e8mes abord\u00e9s en cours avec moi:"},{"location":"#references-et-sites-utilises","text":"Livre Hachette - NSI Sp\u00e9cialit\u00e9 terminale Alain BUSSER : https://alainbusser.frama.io/NSI-IREMI-974/ Guillaume Connan: https://gitlab.com/lyceeND/tale Romain Janvier : nsiterminale.janviercommelemois.fr Gilles LASSUS: https://glassus.github.io/terminale_nsi/ Anne GELLIER : https://angellier.gitlab.io/nsi/terminale/ Pixees - David Roche eskool - Tale NSI - Rodrigo Schwencke","title":"R\u00e9f\u00e9rences et sites utilis\u00e9s:"},{"location":"Algorithmique/sommaire/","text":"CH10 : Diviser pour r\u00e9gner (BAC)","title":"Sommaire"},{"location":"Algorithmique/CH10_diviser/cours/","text":"CH10 : Diviser pour r\u00e9gner \u2693\ufe0e Programme officiel 1. Retour sur l'algorithme de dichotomie \u2693\ufe0e Nous avons vu en classe de Premi\u00e8re l'algorithme de dichotomie (du grec dikhotomia , \u00ab division en deux parties \u00bb). Notre but ici est la recherche de la pr\u00e9sence (ou non) d'un \u00e9l\u00e9ment dans une liste tri\u00e9e . Notre fonction renverra donc un bool\u00e9en. La recherche na\u00efve (\u00e9l\u00e9ment par \u00e9l\u00e9ment) est naturellement de complexit\u00e9 lin\u00e9aire. Nous allons voir que la m\u00e9thode dichotomique est plus efficace. 1.1 Version imp\u00e9rative \u2693\ufe0e Dichotomie version imp\u00e9rative 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = 0 i_fin = len ( tab ) - 1 while i_debut <= i_fin : i_centre = ( i_debut + i_fin ) // 2 # (1) val_centrale = tab [ i_centre ] # (2) if val_centrale == val : # (3) return True if val_centrale < val : # (4) i_debut = i_centre + 1 # (5) else : i_fin = i_centre - 1 return False on prend l'indice central on prend la valeur centrale si la valeur centrale est la valeur cherch\u00e9e... si la valeur centrale est trop petite... on ne prend pas la valeur centrale qui a d\u00e9j\u00e0 \u00e9t\u00e9 test\u00e9e Exemple d'utilisation : >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False \u00c0 chaque tour de la boucle while , la taille de la liste est divis\u00e9e par 2. Ceci conf\u00e8re \u00e0 cet algorithme une complexit\u00e9 logarithmique (bien meilleure qu'une complexit\u00e9 lin\u00e9aire). 1.2 Version r\u00e9cursive \u2693\ufe0e 1.2.1 Pr\u00e9ambule : le slicing \u2693\ufe0e Pour \u00e9crire simplement la version r\u00e9cursive de cet algorithme, nous allons avoir besoin de faire du slicing (d\u00e9coupage) de listes. Cette manipulation n'est pas au programme de NSI (m\u00eame si elle est tr\u00e8s simple). Attention, elle a un co\u00fbt algorithmique important, qui peut fausser notre analyse de complexit\u00e9. Exemples de slicing : >>> lst = [ 'a' , 'b' , 'c' , 'd' , 'e' ] >>> lst [: 2 ] [ 'a' , 'b' ] >>> lst [ 2 :] [ 'c' , 'd' , 'e' ] On comprend que : lst[:k] va renvoyer la sous-liste compos\u00e9e du premier \u00e9l\u00e9ment jusqu'\u00e0 celui d'indice k non inclus . lst[k:] va renvoyer la sous-liste compos\u00e9e du k -i\u00e8me \u00e9l\u00e9ment ( inclus ) jusqu'au dernier. plus g\u00e9n\u00e9ralement, lst[k:p] va renvoyer la sous-liste compos\u00e9e du k -i\u00e8me \u00e9l\u00e9ment ( inclus ) jusqu'au p -i\u00e8me ( non inclus ). 1.2.2 Dichotomie r\u00e9cursive avec slicing \u2693\ufe0e Dichotomie version r\u00e9cursive avec slicing 1 2 3 4 5 6 7 8 9 10 def dichotomie_rec ( tab , val ): if len ( tab ) == 0 : return False i_centre = len ( tab ) // 2 if tab [ i_centre ] == val : return True if tab [ i_centre ] < val : return dichotomie_rec ( tab [ i_centre + 1 :], val ) # (1) else : return dichotomie_rec ( tab [: i_centre ], val ) # (2) On prend la partie droite de liste, juste apr\u00e8s l'indice central. On prend la partie gauche de liste, juste avant l'indice central. Exemple d'utilisation : >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> dichotomie_rec ( tab , 12 ) True >>> dichotomie_rec ( tab , 17 ) False Visualisation gr\u00e2ce \u00e0 PythonTutor: 1.2.3 Dichotomie r\u00e9cursive sans slicing \u2693\ufe0e Il est possible de programmer de mani\u00e8re r\u00e9cursive la recherche dichotomique sans toucher \u00e0 la liste, et donc en jouant uniquement sur les indices : Dichotomie version r\u00e9cursive sans slicing 1 2 3 4 5 6 7 8 9 10 11 12 def dicho_rec_2 ( tab , val , i = 0 , j = None ): # (1) if j is None : # (2) j = len ( tab ) - 1 if i > j : return False m = ( i + j ) // 2 if tab [ m ] < val : return dicho_rec_2 ( tab , val , m + 1 , j ) elif tab [ m ] > val : return dicho_rec_2 ( tab , val , i , m - 1 ) else : return True Pour pouvoir appeler simplement la fonction sans avoir \u00e0 pr\u00e9ciser les indices, on leur donne des param\u00e8tres par d\u00e9faut. Il est impossible de donner j=len(tab)-1 par d\u00e9faut (car tab est aussi un param\u00e8tre). On passe donc par une autre valeur (ici None ) qu'on va ici intercepter. Exemple d'utilisation : >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> dicho_rec_2 ( tab , 12 ) True >>> dicho_rec_2 ( tab , 17 ) False 2. Diviser pour r\u00e9gner \u2693\ufe0e Les algorithmes de dichotomie pr\u00e9sent\u00e9s ci-dessous ont tous en commun de diviser par deux la taille des donn\u00e9es de travail \u00e0 chaque \u00e9tape. Cette m\u00e9thode de r\u00e9solution d'un probl\u00e8me est connue sous le nom de diviser pour r\u00e9gner , ou divide and conquer en anglais. Une d\u00e9finition pourrait \u00eatre : D\u00e9finition Un probl\u00e8me peut se r\u00e9soudre en employant le paradigme diviser pour r\u00e9gner lorsque : - il est possible de d\u00e9composer ce probl\u00e8me en sous-probl\u00e8mes ind\u00e9pendants . - la taille de ces sous-probl\u00e8mes est une fraction du probl\u00e8me initial Remarques : Les sous-probl\u00e8mes peuvent n\u00e9cessiter d'\u00eatre ensuite recombin\u00e9s entre eux (voir plus loin le tri fusion). Consid\u00e9rons de l'\u00e9criture r\u00e9cursive de la fonction factorielle ci-dessous : def factorielle ( n ): if n == 0 : return 1 else : return n * factorielle ( n - 1 ) On ne peut pas parler ici de diviser pour r\u00e9gner car la taille des donn\u00e9es \u00e0 traiter est pass\u00e9e de n \u00e0 n-1 . C'est bien une diminution (qui fait que l'algorithme fonctionne) mais il n'y a pas de division de la taille des donn\u00e9es. C'est cette division (par 2 dans le cas de la dichotomie) qui donne son efficacit\u00e9 \u00e0 ce paradigme. Le paradigme diviser pour r\u00e9gner va naturellement amener \u00e0 r\u00e9diger des programmes r\u00e9cursifs. 3. L'exponentiation rapide \u2693\ufe0e On appelle exponentiation le fait de mettre en puissance un nombre. On va donc coder, de deux mani\u00e8res diff\u00e9rentes, la puissance d'un nombre. 3.1 Algorithme classique \u2693\ufe0e Exponentiation classique 1 2 3 4 5 def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 ) 3.2 Algorithme utilisant diviser pour r\u00e9gner \u2693\ufe0e Nous allons nous appuyer sur la remarque math\u00e9matique suivante : Pour tout nombre \\(a\\) , si \\(n\\) est pair, \\(a^n = (a^2)^{\\frac{n}{2}}\\) si \\(n\\) est impair, \\(a^n = a \\times a^{n-1} = a \\times (a^2)^{\\frac{n-1}{2}}\\) Ainsi, dans le cas o\u00f9 \\(n\\) est pair, il suffit d'\u00e9lever \\(a\\) au carr\u00e9 (une seule op\u00e9ration) pour que l'exposant diminue de moiti\u00e9 . On peut donc programmer la fonction puissance en utilisant le paradigme diviser pour r\u00e9gner : Exponentiation rapide 1 2 3 4 5 6 7 def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a * a , n // 2 ) else : return a * puissance_mod ( a * a , ( n - 1 ) // 2 ) 3.3 Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes \u2693\ufe0e Exercice \u00c9nonc\u00e9 Recr\u00e9er le graphique ci-dessus, qui compare les temps d'ex\u00e9cution des deux fonctions puissance et puissance_mod . Aide pour Matplotlib : le code ci-dessous 1 2 3 4 5 6 7 8 9 import matplotlib.pyplot as plt def carre ( x ): return x * x x = list ( range ( 10 )) y = [ carre ( k ) for k in x ] plt . plot ( x , y ) plt . show () donne le graphique suivant : 4. Le tri-fusion \u2693\ufe0e En anglais le merge sort . 4.1 Preambule : l'interclassement \u2693\ufe0e Le m\u00e9canisme principal du tri fusion est la fusion de deux listes tri\u00e9es en une nouvelle liste elle aussi tri\u00e9e. On appelera ce m\u00e9canisme l' interclassement . Principe de l'interclassement de deux listes lst1 et lst2 . on part d'une liste vide lst_totale on y ajoute alternativement les \u00e9l\u00e9ments de lst1 et lst2 . Il faut pour cela g\u00e9rer s\u00e9par\u00e9ment un indice i1 pour la liste lst1 et un indice i2 pour la liste i2 . quand une liste est \u00e9puis\u00e9e, on y ajoute la totalit\u00e9 restante de l'autre liste. Exercice \u00c9nonc\u00e9 Correction Coder la fonction interclassement . def interclassement ( lst1 , lst2 ): i1 = 0 i2 = 0 lst_totale = [] while i1 != len ( lst1 ) and i2 != len ( lst2 ): if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :] 4.2 La fusion \u2693\ufe0e 4.2.1 Principe \u2693\ufe0e L'id\u00e9e du tri fusion est le d\u00e9coupage de la liste originale en une multitude de listes ne contenant qu'un seul \u00e9l\u00e9ment. Ces listes \u00e9l\u00e9mentaires seront ensuite interclass\u00e9es avec la fonction pr\u00e9c\u00e9dente. Principe de l'algorithme du tri fusion : pour trier une liste, on interclasse les deux moiti\u00e9s de cette liste, pr\u00e9c\u00e9d\u00e9mment elles-m\u00eames tri\u00e9es par le tri fusion. si une liste \u00e0 trier est r\u00e9duite \u00e0 un \u00e9l\u00e9ment, elle est d\u00e9j\u00e0 tri\u00e9e. 4.2.2 Impl\u00e9mentation \u2693\ufe0e La grande force de ce tri va \u00eatre qu'il se programme simplement de mani\u00e8re r\u00e9cursive , en appelant \u00e0 chaque \u00e9tape la m\u00eame fonction mais avec une taille de liste divis\u00e9e par deux, ce qui justifie son classement parmi les algorithmes utilisants \u00abdiviser pour r\u00e9gner\u00bb. Algorithme de tri fusion ( merge sort ) def interclassement ( lst1 , lst2 ): lst_totale = [] n1 , n2 = len ( lst1 ), len ( lst2 ) i1 , i2 = 0 , 0 while i1 < n1 and i2 < n2 : if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :] def tri_fusion ( lst ): if len ( lst ) <= 1 : return lst else : m = len ( lst ) // 2 return interclassement ( tri_fusion ( lst [: m ]), tri_fusion ( lst [ m :])) 4.2.3 Visualisation \u2693\ufe0e Une erreur classique avec les fonctions r\u00e9cursives est de consid\u00e9rer que les appels r\u00e9cursifs sont simultan\u00e9s. C'est faux ! L'animation suivante montre la progression du tri : Il est aussi conseill\u00e9 d'observer l'\u00e9volution de l'algorithme gr\u00e2ce \u00e0 PythonTutor : 4.3 Complexit\u00e9 \u2693\ufe0e La division par 2 de la taille de la liste pourrait nous amener \u00e0 penser que le tri fusion est de complexit\u00e9 logarithmique, comme l'algorithme de dichotomie. Il n'en est rien. En effet, l'instruction finale interclassement(tri_fusion(lst[:m]), tri_fusion(lst[m:])) lance deux appels \u00e0 la fonction tri_fusion (avec certe des donn\u00e9es d'entr\u00e9e deux fois plus petites). On peut montrer que : Complexit\u00e9 du tri fusion L'algorithme de tri fusion est en \\(O(n \\log n)\\) . On dit qu'il est semi-logarithmique . Une complexit\u00e9 semi-logarithmique (en \\(O(n \\log n)\\) ) se situe \u00abentre\u00bb une complexit\u00e9 lin\u00e9aire (en \\(O(n)\\) ) et une complexit\u00e9 quadratique (en \\(O(n^2)\\) ). Une jolie animation permettant de comparer les tris : Issue de ce site Sources Page tir\u00e9e de : https://glassus.github.io/terminale_nsi/T3_Algorithmique/3.1_Diviser_pour_regner/cours/","title":"CH10 Diviser pour r\u00e9gner"},{"location":"Algorithmique/CH10_diviser/cours/#ch10-diviser-pour-regner","text":"Programme officiel","title":"CH10 : Diviser pour r\u00e9gner"},{"location":"Algorithmique/CH10_diviser/cours/#1-retour-sur-lalgorithme-de-dichotomie","text":"Nous avons vu en classe de Premi\u00e8re l'algorithme de dichotomie (du grec dikhotomia , \u00ab division en deux parties \u00bb). Notre but ici est la recherche de la pr\u00e9sence (ou non) d'un \u00e9l\u00e9ment dans une liste tri\u00e9e . Notre fonction renverra donc un bool\u00e9en. La recherche na\u00efve (\u00e9l\u00e9ment par \u00e9l\u00e9ment) est naturellement de complexit\u00e9 lin\u00e9aire. Nous allons voir que la m\u00e9thode dichotomique est plus efficace.","title":"1. Retour sur l'algorithme de dichotomie"},{"location":"Algorithmique/CH10_diviser/cours/#11-version-imperative","text":"Dichotomie version imp\u00e9rative 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = 0 i_fin = len ( tab ) - 1 while i_debut <= i_fin : i_centre = ( i_debut + i_fin ) // 2 # (1) val_centrale = tab [ i_centre ] # (2) if val_centrale == val : # (3) return True if val_centrale < val : # (4) i_debut = i_centre + 1 # (5) else : i_fin = i_centre - 1 return False on prend l'indice central on prend la valeur centrale si la valeur centrale est la valeur cherch\u00e9e... si la valeur centrale est trop petite... on ne prend pas la valeur centrale qui a d\u00e9j\u00e0 \u00e9t\u00e9 test\u00e9e Exemple d'utilisation : >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False \u00c0 chaque tour de la boucle while , la taille de la liste est divis\u00e9e par 2. Ceci conf\u00e8re \u00e0 cet algorithme une complexit\u00e9 logarithmique (bien meilleure qu'une complexit\u00e9 lin\u00e9aire).","title":"1.1 Version imp\u00e9rative"},{"location":"Algorithmique/CH10_diviser/cours/#12-version-recursive","text":"","title":"1.2 Version r\u00e9cursive"},{"location":"Algorithmique/CH10_diviser/cours/#2-diviser-pour-regner","text":"Les algorithmes de dichotomie pr\u00e9sent\u00e9s ci-dessous ont tous en commun de diviser par deux la taille des donn\u00e9es de travail \u00e0 chaque \u00e9tape. Cette m\u00e9thode de r\u00e9solution d'un probl\u00e8me est connue sous le nom de diviser pour r\u00e9gner , ou divide and conquer en anglais. Une d\u00e9finition pourrait \u00eatre : D\u00e9finition Un probl\u00e8me peut se r\u00e9soudre en employant le paradigme diviser pour r\u00e9gner lorsque : - il est possible de d\u00e9composer ce probl\u00e8me en sous-probl\u00e8mes ind\u00e9pendants . - la taille de ces sous-probl\u00e8mes est une fraction du probl\u00e8me initial Remarques : Les sous-probl\u00e8mes peuvent n\u00e9cessiter d'\u00eatre ensuite recombin\u00e9s entre eux (voir plus loin le tri fusion). Consid\u00e9rons de l'\u00e9criture r\u00e9cursive de la fonction factorielle ci-dessous : def factorielle ( n ): if n == 0 : return 1 else : return n * factorielle ( n - 1 ) On ne peut pas parler ici de diviser pour r\u00e9gner car la taille des donn\u00e9es \u00e0 traiter est pass\u00e9e de n \u00e0 n-1 . C'est bien une diminution (qui fait que l'algorithme fonctionne) mais il n'y a pas de division de la taille des donn\u00e9es. C'est cette division (par 2 dans le cas de la dichotomie) qui donne son efficacit\u00e9 \u00e0 ce paradigme. Le paradigme diviser pour r\u00e9gner va naturellement amener \u00e0 r\u00e9diger des programmes r\u00e9cursifs.","title":"2. Diviser pour r\u00e9gner"},{"location":"Algorithmique/CH10_diviser/cours/#3-lexponentiation-rapide","text":"On appelle exponentiation le fait de mettre en puissance un nombre. On va donc coder, de deux mani\u00e8res diff\u00e9rentes, la puissance d'un nombre.","title":"3. L'exponentiation rapide"},{"location":"Algorithmique/CH10_diviser/cours/#31-algorithme-classique","text":"Exponentiation classique 1 2 3 4 5 def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 )","title":"3.1 Algorithme classique"},{"location":"Algorithmique/CH10_diviser/cours/#32-algorithme-utilisant-diviser-pour-regner","text":"Nous allons nous appuyer sur la remarque math\u00e9matique suivante : Pour tout nombre \\(a\\) , si \\(n\\) est pair, \\(a^n = (a^2)^{\\frac{n}{2}}\\) si \\(n\\) est impair, \\(a^n = a \\times a^{n-1} = a \\times (a^2)^{\\frac{n-1}{2}}\\) Ainsi, dans le cas o\u00f9 \\(n\\) est pair, il suffit d'\u00e9lever \\(a\\) au carr\u00e9 (une seule op\u00e9ration) pour que l'exposant diminue de moiti\u00e9 . On peut donc programmer la fonction puissance en utilisant le paradigme diviser pour r\u00e9gner : Exponentiation rapide 1 2 3 4 5 6 7 def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a * a , n // 2 ) else : return a * puissance_mod ( a * a , ( n - 1 ) // 2 )","title":"3.2 Algorithme utilisant diviser pour r\u00e9gner"},{"location":"Algorithmique/CH10_diviser/cours/#33-comparaison-de-la-vitesse-dexecution-des-deux-algorithmes","text":"Exercice \u00c9nonc\u00e9 Recr\u00e9er le graphique ci-dessus, qui compare les temps d'ex\u00e9cution des deux fonctions puissance et puissance_mod . Aide pour Matplotlib : le code ci-dessous 1 2 3 4 5 6 7 8 9 import matplotlib.pyplot as plt def carre ( x ): return x * x x = list ( range ( 10 )) y = [ carre ( k ) for k in x ] plt . plot ( x , y ) plt . show () donne le graphique suivant :","title":"3.3 Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes"},{"location":"Algorithmique/CH10_diviser/cours/#4-le-tri-fusion","text":"En anglais le merge sort .","title":"4. Le tri-fusion"},{"location":"Algorithmique/CH10_diviser/cours/#41-preambule-linterclassement","text":"Le m\u00e9canisme principal du tri fusion est la fusion de deux listes tri\u00e9es en une nouvelle liste elle aussi tri\u00e9e. On appelera ce m\u00e9canisme l' interclassement . Principe de l'interclassement de deux listes lst1 et lst2 . on part d'une liste vide lst_totale on y ajoute alternativement les \u00e9l\u00e9ments de lst1 et lst2 . Il faut pour cela g\u00e9rer s\u00e9par\u00e9ment un indice i1 pour la liste lst1 et un indice i2 pour la liste i2 . quand une liste est \u00e9puis\u00e9e, on y ajoute la totalit\u00e9 restante de l'autre liste. Exercice \u00c9nonc\u00e9 Correction Coder la fonction interclassement . def interclassement ( lst1 , lst2 ): i1 = 0 i2 = 0 lst_totale = [] while i1 != len ( lst1 ) and i2 != len ( lst2 ): if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :]","title":"4.1 Preambule : l'interclassement"},{"location":"Algorithmique/CH10_diviser/cours/#42-la-fusion","text":"","title":"4.2 La fusion"},{"location":"Algorithmique/CH10_diviser/cours/#43-complexite","text":"La division par 2 de la taille de la liste pourrait nous amener \u00e0 penser que le tri fusion est de complexit\u00e9 logarithmique, comme l'algorithme de dichotomie. Il n'en est rien. En effet, l'instruction finale interclassement(tri_fusion(lst[:m]), tri_fusion(lst[m:])) lance deux appels \u00e0 la fonction tri_fusion (avec certe des donn\u00e9es d'entr\u00e9e deux fois plus petites). On peut montrer que : Complexit\u00e9 du tri fusion L'algorithme de tri fusion est en \\(O(n \\log n)\\) . On dit qu'il est semi-logarithmique . Une complexit\u00e9 semi-logarithmique (en \\(O(n \\log n)\\) ) se situe \u00abentre\u00bb une complexit\u00e9 lin\u00e9aire (en \\(O(n)\\) ) et une complexit\u00e9 quadratique (en \\(O(n^2)\\) ). Une jolie animation permettant de comparer les tris : Issue de ce site Sources Page tir\u00e9e de : https://glassus.github.io/terminale_nsi/T3_Algorithmique/3.1_Diviser_pour_regner/cours/","title":"4.3 Complexit\u00e9"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/sommaire/","text":"CH5 : Syst\u00e8mes sur puce (BAC) CH6 : Gestion des processus (BAC) CH8 : Routage (BAC) CH9 : Cryptographie - S\u00e9curisation des communications","title":"Sommaire"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/","text":"CH5 : Syst\u00e8mes sur puce \u2693\ufe0e pr\u00e9ambule : cours de Premi\u00e8re sur l'architecture Von Neumann 1. Loi de Moore et miniaturisation progressive \u2693\ufe0e 1.1 La Loi de Moore \u2693\ufe0e En 1965, Gordon Moore postule que le nombre de transistors pr\u00e9sents sur une puce de microprocesseur doublera tous les deux ans. Cette pr\u00e9diction s'est r\u00e9v\u00e9l\u00e9e \u00e9tonnamment juste (\u00e0 quelques approximations pr\u00e8s) et les \u00e9quipements \u00e9lectroniques n'ont depuis jamais cess\u00e9 de devenir toujours plus performants / miniatures / \u00e9conomes en \u00e9nergie. 1.2 \u00c9volution de la taille des ordinateurs \u2693\ufe0e 1.2.1 IBM 650, le premier ordinateur fabriqu\u00e9 en s\u00e9rie (1955) \u2693\ufe0e Cet ordinateur n'a pas encore de transistors mais des tubes \u00e0 vide. 1.2.2 IBM 7090, le premier ordinateur \u00e0 transistors (1959) \u2693\ufe0e Le transistor Le transistor est un composant \u00e9lectronique essentiel : il permet de laisser (ou non) passer un courant \u00e9lectrique. 1.2.3 Le r\u00f4le crucial de la taille des transistors \u2693\ufe0e Ainsi que l'avait pr\u00e9dit Moore, c'est la progression du nombre de transistors gravables sur le processeur qui guidera pendant des ann\u00e9es l'\u00e9volution de l'informatique : 2. Composition d'un pc actuel \u2693\ufe0e Chaque composant a un r\u00f4le sp\u00e9cifique. Ils communiquent entre eux par des bus de diff\u00e9rentes vitesses. Chaque composant est rempla\u00e7able, et il est possible d'ajouter de nouveaux composants sur la carte m\u00e8re qui poss\u00e8de des slots d'extension. 3. Tout un pc sur une seule puce : les SoC \u2693\ufe0e 3.1 L'int\u00e9gration de composants diff\u00e9rents au sein d'une m\u00eame puce \u2693\ufe0e Le principe d'un syst\u00e8me sur puce ou System On a Chip (SoC) est d'int\u00e9grer au sein d'une puce unique un ensemble de composants habituellement physiquement dissoci\u00e9s dans un ordinateur classique (ordinateur de bureau ou ordinateur portable). On peut retrouver ainsi au sein d'une m\u00eame puce : le microprocesseur (CPU) la carte graphique (GPU) la m\u00e9moire RAM + \u00e9ventuellement des composants de communication (WiFi, Bluetooth...) Avantages et inconv\u00e9nients d'un SoC Avantages moindre consommation \u00e9lectrique moindre encombrement pas besoin de refroidissement meilleure s\u00e9curit\u00e9 (vue globale sur la s\u00e9curit\u00e9 qui n'est plus d\u00e9pendante d'une multitude de composants) moindre co\u00fbt (forte automisation du processus, gros volumes de production) Inconv\u00e9nients Impossibilit\u00e9 de choisir ind\u00e9pendamment ses composants Pas de mise \u00e0 jour possible / remplacement / ajout d'un composant La panne d'un seul composant entra\u00eene la panne totale du SoC 3.2 Exemple : A15 Bionic \u2693\ufe0e Observons par exemple la puce Apple A15 Bionic, qui \u00e9quipe les iPhone 13. Cette puce est fabriqu\u00e9e par TSMC . Cette puce contient : 15 milliards de transistors (grav\u00e9s \u00e0 5 nm) un processeur central \u00e0 6 c\u0153urs (2 c\u0153urs hautes performances + 4 c\u0153urs plus \u00e9conomes en \u00e9nergie) un GPU (processeur d\u00e9di\u00e9 uniquement au calcul du rendu graphique) de 5 c\u0153urs. une puce d\u00e9di\u00e9e au Machine Learning ( Neural Engine ) 4. Des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches sp\u00e9cifiques \u2693\ufe0e L'int\u00e9gration dans un SoC n'est pas totale : il reste des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches tr\u00e8s sp\u00e9cifiques qui ne sont pas forc\u00e9ment int\u00e9gr\u00e9es dans le SoC. 4.1 Au sein d'un t\u00e9l\u00e9phone \u2693\ufe0e Ainsi, d'apr\u00e8s le site iFixit , on peut retrouver ceci dans l'iPhone Pro 13, au c\u00f4t\u00e9 de la puce A15 \u00e9voqu\u00e9e plus haut : On voit que (par exemple) qu'il existe une puce sp\u00e9cifique pour g\u00e9rer l'audio, une puce sp\u00e9cifique pour le module WiFi, une puce sp\u00e9cifique pour le module Modem 5G... 4.2 En \u00e9lectronique \u00abgrand public\u00bb \u2693\ufe0e Ce composant (pouvant \u00eatre utilis\u00e9 dans un montage personnel, sur un Arduino par exemple) ne sert qu'\u00e0 faire des calculs cryptographiques. 4.3 Un principe g\u00e9n\u00e9ral \u2693\ufe0e Il est important de comprendre que certains processeurs sont optimis\u00e9s pour un certains types de calcul. C'est le cas par exemple d'une carte graphique, qui excelle dans le calcul de rendus de polygones. On s'est aper\u00e7u que cette aptitude \u00e0 faire des calculs \u00abb\u00eates et r\u00e9p\u00e9titifs\u00bb \u00e9tait parfaite pour faire les calculs math\u00e9matiques (inutiles) n\u00e9cessaires au minage des cryptomonnaies. Les cartes graphiques ont donc \u00e9t\u00e9 d\u00e9tourn\u00e9es de leur usage originel, \u00e0 cause de la sp\u00e9cificit\u00e9 de l'impl\u00e9mentation de leur puce. De m\u00eame, les calculs sur les r\u00e9seaux de neurones (essentiels en IA) n\u00e9cessitent une grande rapidit\u00e9 dans les multiplications de matrices. Pour cette raison, Apple a int\u00e9gr\u00e9 directement dans son SoC A15 une puce sp\u00e9calis\u00e9e dans ces calculs (voir plus haut). 4.4 Conclusion \u2693\ufe0e L'orientation actuelle de l'\u00e9lectronique est donc \u00e0 la fois : une int\u00e9gration toujours plus grande dans des SoC multi-t\u00e2ches. des puces toujours plus sp\u00e9cifiques qui excellent dans un domaine particulier. 5. Exercice \u2693\ufe0e Exercice (Polyn\u00e9sie 2021) \u00c9nonc\u00e9 Correction Un constructeur automobile int\u00e8gre \u00e0 ses v\u00e9hicules des syst\u00e8mes embarqu\u00e9s, comme par exemple un syst\u00e8me de guidage par satellites (GPS), un syst\u00e8me de freinage antiblocage (ABS)... Ces dispositifs utilisent des syst\u00e8mes sur puces (SoC : System on a Chip). Citer deux avantages \u00e0 utiliser ces syst\u00e8mes sur puces plut\u00f4t qu'une architecture classique d'ordinateur. On peut citer : Moindre consommation \u00e9nerg\u00e9tique Moindre encombrement Moindre co\u00fbt ... Bibliographie / Sitographie Page tir\u00e9e de : https://glassus.github.io/terminale_nsi/T5_Architecture_materielle/5.1_Systemes_sur_puce Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. https://fr.wikipedia.org/wiki/Loi_de_Moore https://blog.iakaa.com/lordinateur-fete-ses-60-ans/ https://www.thewindowsclub.com/history-of-computers https://perso-etis.ensea.fr//lorandel/M2_SoC/s1.pdf https://www.hawkpointtechnologies.com/about/blog/computer-components https://www.tremplin-numerique.org/apple-a15-vs-a14-quoi-de-neuf-dans-la-puce-de-liphone-13 https://www.distrelec.be/fr/cryptoprocesseur-breakout-atecc608a-sparkfun-electronics-dev-18077/p/30241877","title":"CH5 Syst\u00e8mes sur puce"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#ch5-systemes-sur-puce","text":"pr\u00e9ambule : cours de Premi\u00e8re sur l'architecture Von Neumann","title":"CH5 : Syst\u00e8mes sur puce"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#1-loi-de-moore-et-miniaturisation-progressive","text":"","title":"1. Loi de Moore et miniaturisation progressive"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#11-la-loi-de-moore","text":"En 1965, Gordon Moore postule que le nombre de transistors pr\u00e9sents sur une puce de microprocesseur doublera tous les deux ans. Cette pr\u00e9diction s'est r\u00e9v\u00e9l\u00e9e \u00e9tonnamment juste (\u00e0 quelques approximations pr\u00e8s) et les \u00e9quipements \u00e9lectroniques n'ont depuis jamais cess\u00e9 de devenir toujours plus performants / miniatures / \u00e9conomes en \u00e9nergie.","title":"1.1 La Loi de Moore"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#12-evolution-de-la-taille-des-ordinateurs","text":"","title":"1.2  \u00c9volution de la taille des ordinateurs"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#2-composition-dun-pc-actuel","text":"Chaque composant a un r\u00f4le sp\u00e9cifique. Ils communiquent entre eux par des bus de diff\u00e9rentes vitesses. Chaque composant est rempla\u00e7able, et il est possible d'ajouter de nouveaux composants sur la carte m\u00e8re qui poss\u00e8de des slots d'extension.","title":"2. Composition d'un pc actuel"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#3-tout-un-pc-sur-une-seule-puce-les-soc","text":"","title":"3. Tout un pc sur une seule puce : les SoC"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#31-lintegration-de-composants-differents-au-sein-dune-meme-puce","text":"Le principe d'un syst\u00e8me sur puce ou System On a Chip (SoC) est d'int\u00e9grer au sein d'une puce unique un ensemble de composants habituellement physiquement dissoci\u00e9s dans un ordinateur classique (ordinateur de bureau ou ordinateur portable). On peut retrouver ainsi au sein d'une m\u00eame puce : le microprocesseur (CPU) la carte graphique (GPU) la m\u00e9moire RAM + \u00e9ventuellement des composants de communication (WiFi, Bluetooth...) Avantages et inconv\u00e9nients d'un SoC Avantages moindre consommation \u00e9lectrique moindre encombrement pas besoin de refroidissement meilleure s\u00e9curit\u00e9 (vue globale sur la s\u00e9curit\u00e9 qui n'est plus d\u00e9pendante d'une multitude de composants) moindre co\u00fbt (forte automisation du processus, gros volumes de production) Inconv\u00e9nients Impossibilit\u00e9 de choisir ind\u00e9pendamment ses composants Pas de mise \u00e0 jour possible / remplacement / ajout d'un composant La panne d'un seul composant entra\u00eene la panne totale du SoC","title":"3.1 L'int\u00e9gration de composants diff\u00e9rents au sein d'une m\u00eame puce"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#32-exemple-a15-bionic","text":"Observons par exemple la puce Apple A15 Bionic, qui \u00e9quipe les iPhone 13. Cette puce est fabriqu\u00e9e par TSMC . Cette puce contient : 15 milliards de transistors (grav\u00e9s \u00e0 5 nm) un processeur central \u00e0 6 c\u0153urs (2 c\u0153urs hautes performances + 4 c\u0153urs plus \u00e9conomes en \u00e9nergie) un GPU (processeur d\u00e9di\u00e9 uniquement au calcul du rendu graphique) de 5 c\u0153urs. une puce d\u00e9di\u00e9e au Machine Learning ( Neural Engine )","title":"3.2 Exemple : A15 Bionic"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#4-des-puces-dediees-a-des-taches-specifiques","text":"L'int\u00e9gration dans un SoC n'est pas totale : il reste des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches tr\u00e8s sp\u00e9cifiques qui ne sont pas forc\u00e9ment int\u00e9gr\u00e9es dans le SoC.","title":"4. Des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches sp\u00e9cifiques"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#41-au-sein-dun-telephone","text":"Ainsi, d'apr\u00e8s le site iFixit , on peut retrouver ceci dans l'iPhone Pro 13, au c\u00f4t\u00e9 de la puce A15 \u00e9voqu\u00e9e plus haut : On voit que (par exemple) qu'il existe une puce sp\u00e9cifique pour g\u00e9rer l'audio, une puce sp\u00e9cifique pour le module WiFi, une puce sp\u00e9cifique pour le module Modem 5G...","title":"4.1 Au sein d'un t\u00e9l\u00e9phone"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#42-en-electronique-grand-public","text":"Ce composant (pouvant \u00eatre utilis\u00e9 dans un montage personnel, sur un Arduino par exemple) ne sert qu'\u00e0 faire des calculs cryptographiques.","title":"4.2 En \u00e9lectronique \u00abgrand public\u00bb"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#43-un-principe-general","text":"Il est important de comprendre que certains processeurs sont optimis\u00e9s pour un certains types de calcul. C'est le cas par exemple d'une carte graphique, qui excelle dans le calcul de rendus de polygones. On s'est aper\u00e7u que cette aptitude \u00e0 faire des calculs \u00abb\u00eates et r\u00e9p\u00e9titifs\u00bb \u00e9tait parfaite pour faire les calculs math\u00e9matiques (inutiles) n\u00e9cessaires au minage des cryptomonnaies. Les cartes graphiques ont donc \u00e9t\u00e9 d\u00e9tourn\u00e9es de leur usage originel, \u00e0 cause de la sp\u00e9cificit\u00e9 de l'impl\u00e9mentation de leur puce. De m\u00eame, les calculs sur les r\u00e9seaux de neurones (essentiels en IA) n\u00e9cessitent une grande rapidit\u00e9 dans les multiplications de matrices. Pour cette raison, Apple a int\u00e9gr\u00e9 directement dans son SoC A15 une puce sp\u00e9calis\u00e9e dans ces calculs (voir plus haut).","title":"4.3 Un principe g\u00e9n\u00e9ral"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#44-conclusion","text":"L'orientation actuelle de l'\u00e9lectronique est donc \u00e0 la fois : une int\u00e9gration toujours plus grande dans des SoC multi-t\u00e2ches. des puces toujours plus sp\u00e9cifiques qui excellent dans un domaine particulier.","title":"4.4 Conclusion"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH5_SOC/cours/#5-exercice","text":"Exercice (Polyn\u00e9sie 2021) \u00c9nonc\u00e9 Correction Un constructeur automobile int\u00e8gre \u00e0 ses v\u00e9hicules des syst\u00e8mes embarqu\u00e9s, comme par exemple un syst\u00e8me de guidage par satellites (GPS), un syst\u00e8me de freinage antiblocage (ABS)... Ces dispositifs utilisent des syst\u00e8mes sur puces (SoC : System on a Chip). Citer deux avantages \u00e0 utiliser ces syst\u00e8mes sur puces plut\u00f4t qu'une architecture classique d'ordinateur. On peut citer : Moindre consommation \u00e9nerg\u00e9tique Moindre encombrement Moindre co\u00fbt ... Bibliographie / Sitographie Page tir\u00e9e de : https://glassus.github.io/terminale_nsi/T5_Architecture_materielle/5.1_Systemes_sur_puce Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. https://fr.wikipedia.org/wiki/Loi_de_Moore https://blog.iakaa.com/lordinateur-fete-ses-60-ans/ https://www.thewindowsclub.com/history-of-computers https://perso-etis.ensea.fr//lorandel/M2_SoC/s1.pdf https://www.hawkpointtechnologies.com/about/blog/computer-components https://www.tremplin-numerique.org/apple-a15-vs-a14-quoi-de-neuf-dans-la-puce-de-liphone-13 https://www.distrelec.be/fr/cryptoprocesseur-breakout-atecc608a-sparkfun-electronics-dev-18077/p/30241877","title":"5. Exercice"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/","text":"CH6 : Gestion des processus \u2693\ufe0e Programme officiel 1. Notion de processus \u2693\ufe0e 1.1 D\u00e9finition d'un processus \u2693\ufe0e Lorsqu'un programme est ex\u00e9cut\u00e9 sur un ordinateur, celui-ci va cr\u00e9er un (ou plusieurs) processus . On dit que ce processus est une instance d'ex\u00e9cution de ce programme. Un processus est caract\u00e9ris\u00e9 par : l'ensemble des instructions qu'il va devoir accomplir (\u00e9crites dans le fichier ex\u00e9cutable obtenu par la compilation du code-source du programme) les ressources que le programme va mobiliser (fichier en ouverture, carte son...) l'\u00e9tat des registres du processeur (voir le cours de Premi\u00e8re sur l' architecture Von Neumann ) 1.2 Observation des processus sous Linux \u2693\ufe0e 1.2.1 La commande ps \u2693\ufe0e Dans un terminal, la commande ps va permettre d'afficher la liste des processus actifs. Plus pr\u00e9cis\u00e9ment, nous allons utiliser la commande ps -lu nom_user . L'option l permet d'afficher un grand nombre de renseignements et l'option u permet de sp\u00e9cifier l'utilisateur propri\u00e9taire des processus. On retrouve notamment dans ce tableau les colonnes : CMD (Command) : le nom de la commande qui a cr\u00e9\u00e9 le processus. Vous pouvez y retrouver par ordre chronologique le nom de tous les programmes actifs. Certains sont ceux que vous avez ouverts volontairement (navigateur...) mais on y trouve surtout tous les programmes n\u00e9cessaires au bon fonctionnement du syst\u00e8me d'exploitation. Le dernier processus en bas de la liste est forc\u00e9ment ps , puisque vous venez de l'appeler. PID (Process Identifier) : le num\u00e9ro unique d'identification, affect\u00e9 chronologiquement par le syst\u00e8me d'exploitation. Le processus de PID \u00e9gal \u00e0 1 est systemd , qui est le tout premier programme lanc\u00e9 par le noyau Linux au d\u00e9marrage. PPID (Parent PID) : certains processus vont eux-m\u00eames lancer plusieurs processus-fils, qui porteront le m\u00eame nom. C'est ainsi qu'on peut retrouver de multiples processus s'appelant chrome : Ici, l'instance \u00abprincipale\u00bb de Chrome ( PID 1453) a g\u00e9n\u00e9r\u00e9 6 autres instances de PID diff\u00e9rents, dont le PPID vaut 1453. Dans Chrome/Chromium, vous pouvez comprendre le r\u00f4le de chaque processus en le retrouvant dans le gestionnaire des t\u00e2ches (clic-droit sur une zone vide de la barre d'onglets) 1.2.2 La commande pstree \u2693\ufe0e \u00c0 noter que la commande pstree permet d'afficher les processus sous forme d'arborescence : 1.2.3 La commande top \u2693\ufe0e La commande top permet de conna\u00eetre en temps r\u00e9el la liste des processus, class\u00e9s par ordre d\u00e9croissant de consommation de CPU. On ferme top par la combinaison de touches Ctrl-C . Si on rep\u00e8re alors un processus qui consomme beaucoup trop de ressources, on peut utiliser... 1.2.4 La commande kill \u2693\ufe0e La commande kill permet de fermer un processus, en donnant son PID en argument. Exemple : kill 1453 tuera Chrome (voir la capture du 1.2.1) 2. Ordonnancement \u2693\ufe0e 2.1 Exp\u00e9rience : les processus fonctionnent simultan\u00e9ment \u00e0 tour de r\u00f4le. \u2693\ufe0e Un ordinateur donne l'illusion de r\u00e9aliser plusieurs t\u00e2ches simultan\u00e9ment. Hormis pour les processeurs fonctionnant avec plusieurs c\u0153urs, il n'en est rien. Comme nous l'avons vu, ces processus sont lanc\u00e9s s\u00e9quentiellement par le syst\u00e8me d'exploitation, et sont ensuite en apparence tous \u00abactifs en m\u00eame temps\u00bb (les guillemets sont importants) : on parle de programmation concurrente . Revenons sur l'expression \u00abactifs en m\u00eame temps\u00bb, car elle v\u00e9hicule une fausse id\u00e9e : ces processus sont bien vivants dans un m\u00eame laps de temps, mais ils s'ex\u00e9cutent LES UNS APR\u00c8S LES AUTRES , le processeur ne pouvant en traiter qu' un seul \u00e0 la fois . Un cadencement extr\u00eamement rapide et efficace donne l' apparence d'une (fausse) simultan\u00e9it\u00e9. Nous allons la mettre en \u00e9vidence : Consid\u00e9rons les fichiers progA.py et progB.py ci-dessous : progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) progB.py import time time . sleep ( 0.01 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) Le programme progB.py est l\u00e9g\u00e8rement retard\u00e9 au d\u00e9marrage par le time.sleep(0.01) . Il devrait donc en r\u00e9sulter un entrelacement entre les phrases programme A en cours et programme B en cours . L'ex\u00e9cution \u00abd'apparence simultan\u00e9e\u00bb de ces deux programmes peut se faire dans un Terminal via la commande python3 progA.py & python3 progB.py . Il en r\u00e9sulte ceci : Nous retrouvons bien l'alternance pr\u00e9vue \u00e0 la lecture du code. Tout se passe donc comme si les deux processus avaient \u00e9t\u00e9 lanc\u00e9s et trait\u00e9s simultan\u00e9ment. R\u00e9duisons maintenant les temporisations (en passant du centi\u00e8me de seconde \u00e0 la milliseconde): progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) progB.py import time time . sleep ( 0.001 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) Il en r\u00e9sulte maintenant ceci : L'alternance pr\u00e9vue n'est plus respect\u00e9e (et les r\u00e9sultats deviennent non-reproductibles). Si la gestion des processus \u00e9tait r\u00e9ellement simultan\u00e9e, m\u00eame en consid\u00e9rant des ralentissements du processeur par des sollicitations ext\u00e9rieures, chaque processus serait ralenti de la m\u00eame mani\u00e8re : l'entrelacement des phrases serait toujours le m\u00eame. En r\u00e9alit\u00e9, le processeur passe son temps \u00e0 alterner entre les divers processus qu'il a \u00e0 g\u00e9rer, et les met en attente quand il ne peut pas s'occuper d'eux. Il ob\u00e9it pour cela aux instructions de son ordonnanceur . 2.2 L'ordonnancement des processus \u2693\ufe0e 2.2.1 Diff\u00e9rents types d'ordonnancement \u2693\ufe0e Si on vous donne 4 t\u00e2ches A, B, C et D \u00e0 accomplir, vous pouvez d\u00e9cider : de faire la t\u00e2che prioritaire d'abord ; de faire la t\u00e2che la plus rapide d'abord ; de faire la t\u00e2che la plus longue d'abord ; de les faire dans l'ordre o\u00f9 elles vous ont \u00e9t\u00e9 donn\u00e9es ; de faire \u00e0 tour de r\u00f4le chaque t\u00e2che pendant un temps fixe jusqu'\u00e0 ce qu'elles soient toutes termin\u00e9es; ... Un processeur est confront\u00e9 aux m\u00eames choix : comment d\u00e9terminer quel processus doit \u00eatre trait\u00e9 \u00e0 quel moment ? Le sch\u00e9ma ci-dessous (issu de ce site ) pr\u00e9sente quelques politiques d'ordonnancement : Sous Linux, l'ordonnancement est effectu\u00e9 par un syst\u00e8me hybride o\u00f9 les processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le (on parle de tourniquet ou de Round Robin ) suivant un ordre de priorit\u00e9 dynamique. Dans le cas (tr\u00e8s fr\u00e9quent maintenant) d'un processeur multi-c\u0153urs , le probl\u00e8me reste identique. Certes, sur 4 c\u0153urs, 4 processus pourront \u00eatre trait\u00e9s simultan\u00e9ment (une r\u00e9elle simultan\u00e9it\u00e9) mais il reste toujours beaucoup plus de processus \u00e0 traiter que de c\u0153urs dans le processeur... et un ordonnancement est donc toujours n\u00e9cessaire. 2.2.2 Les diff\u00e9rents \u00e9tats d'un processus \u2693\ufe0e Selon que l'ordonnanceur aura d\u00e9cid\u00e9 de le confier ou non au processeur pour son ex\u00e9cution, un processus peut donc se trouver dans 3 \u00e9tats : Pr\u00eat : il attend qu'arrive le moment de son ex\u00e9cution. \u00c9lu : il est en cours d'ex\u00e9cution par le processeur. Bloqu\u00e9 : pendant son ex\u00e9cution (\u00e9tat \u00c9lu ), le processus r\u00e9clame une ressource qui n'est pas imm\u00e9diatement disponible. Son ex\u00e9cution s'interrompt. Lorsque la ressource sera disponible, le processus repassera par l'\u00e9tat Pr\u00eat et attendra \u00e0 nouveau son tour. On peut utiliser la m\u00e9taphore suivante : Sur le bureau d'un professeur, il y a 3 paquets de copies, correspondant aux classes A, B, et C. Ces paquets sont Pr\u00eats \u00e0 \u00eatre corrig\u00e9s. Si le professeur ram\u00e8ne devant lui le paquet A, celui-ci devient \u00c9lu , et le professeur peut commencer \u00e0 le corriger. Pour se changer les id\u00e9es, il peut interrompre la correction du paquet A (qui va passer \u00e0 l'\u00e9tat Bloqu\u00e9 ) et ramener vers lui le paquet C. Il pourra ensuite prendre le paquet B, puis \u00e0 nouveau le C, puis le A, ainsi de suite jusqu'\u00e0 ce que tous les paquets soient totalement corrig\u00e9s. Ces paquets seront alors Termin\u00e9s . Au cours de cette proc\u00e9dure, le professeur n'a toujours eu devant lui qu' un seul paquet de copies (soit A, soit B, soit C). Pourquoi l'acc\u00e8s \u00e0 une ressource peut bloquer un processus ? Pendant son ex\u00e9cution, un processus peut avoir besoin d'acc\u00e9der \u00e0 une ressource d\u00e9j\u00e0 occup\u00e9e (un fichier d\u00e9j\u00e0 ouvert, par exemple) ou \u00eatre en attente d'une entr\u00e9e-utilisateur (un input() dans un code Python par exemple). Dans ce cas-l\u00e0, le processeur va passer ce processus \u00e0 l'\u00e9tat Bloqu\u00e9 , pour pouvoir ainsi se consacrer \u00e0 un autre processus. Une fois d\u00e9bloqu\u00e9, le processus va repasser \u00e0 l'\u00e9tat Pr\u00eat et rejoindre (par exemple) la file d'attente des processus avant d'\u00eatre \u00e0 nouveau \u00c9lu et donc ex\u00e9cut\u00e9. 3. Interblocage \u2693\ufe0e 3.1 D\u00e9finition et exemple \u2693\ufe0e Comme nous venons de le voir, un processus peut \u00eatre dans l'\u00e9tat bloqu\u00e9 dans l'attente de la lib\u00e9ration d'une ressource. Ces ressources (l'acc\u00e8s en \u00e9criture \u00e0 un fichier, \u00e0 un registre de la m\u00e9moire...) ne peuvent \u00eatre donn\u00e9es \u00e0 deux processus \u00e0 la fois. Des processus souhaitant acc\u00e9der \u00e0 cette ressource sont donc en concurrence sur cette ressource. Un processus peut donc devoir attendre qu'une ressource se lib\u00e8re avant de pouvoir y acc\u00e9der (et ainsi passer de l'\u00e9tat Bloqu\u00e9 \u00e0 l'\u00e9tat Pr\u00eat). Probl\u00e8me : Et si deux processus se bloquent mutuellement la ressource dont ils ont besoin ? Exemple : Consid\u00e9rons 2 processus A et B, et deux ressources R et S. L'action des processus A et B est d\u00e9crite ci-dessous : D\u00e9roulement des processus A et B : A et B sont cr\u00e9\u00e9s et passent \u00e0 l'\u00e9tat Pr\u00eat . L'ordonnanceur d\u00e9clare \u00c9lu le processus A (ou bien B, cela ne change rien). L'\u00e9tape A1 de A est r\u00e9alis\u00e9e : la ressource R est donc affect\u00e9e \u00e0 A. L'ordonnanceur d\u00e9clare maintenant \u00c9lu le processus B. A est donc pass\u00e9 \u00e0 Bloqu\u00e9 en attendant que son tour revienne. L'\u00e9tape B1 de B est r\u00e9alis\u00e9e : la ressource S est donc affect\u00e9e \u00e0 B. L'ordonnanceur d\u00e9clare \u00e0 nouveau \u00c9lu le processus A. B est donc pass\u00e9 \u00e0 Bloqu\u00e9 en attendant que son tour revienne. L'\u00e9tape A2 de A est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource S, qui n'est pas disponible. L'ordonnanceur va donc passer A \u00e0 Bloqu\u00e9 et va revenir au processus B qui redevient \u00c9lu . L'\u00e9tape B2 de B est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource R, qui n'est pas disponible. L'ordonnanceur va donc passer B \u00e0 Bloqu\u00e9 . Les deux processus A et B sont donc dans l'\u00e9tat Bloqu\u00e9 , chacun en attente de la lib\u00e9ration d'une ressource bloqu\u00e9e par l'autre : ils se bloquent mutuellement. Cette situation (critique) est appel\u00e9e interblocage ou deadlock . 3.3 Repr\u00e9sentation sch\u00e9matique \u2693\ufe0e les processus seront repr\u00e9sent\u00e9s par des cercles , les ressources par des carr\u00e9s . Si \u00e0 l'\u00e9tape A1 le processus A a demand\u00e9 et re\u00e7u la ressource R, la repr\u00e9sentation sera : Si \u00e0 l'\u00e9tape A2 le processus A est en attente de la ressource S, la repr\u00e9sentation sera : Avec ces conventions, la situation pr\u00e9c\u00e9dente peut donc se sch\u00e9matiser par : Ce type de sch\u00e9ma fait appara\u00eetre un cycle d'interd\u00e9pendance , qui caract\u00e9rise ici la situation de deadlock. 3.4 Comment s'en pr\u00e9munir ? (HP) \u2693\ufe0e Il existe trois strat\u00e9gies pour \u00e9viter les interblocages : la pr\u00e9vention : on oblige le processus \u00e0 d\u00e9clarer \u00e0 l'avance la liste de toutes les ressources auxquelles il va acc\u00e9der. l'\u00e9vitement : on fait en sorte qu'\u00e0 chaque \u00e9tape il reste une possibilit\u00e9 d'attribution de ressources qui \u00e9vite le deadlock. la d\u00e9tection/r\u00e9solution : on laisse la situation arriver jusqu'au deadlock, puis un algorithme de r\u00e9solution d\u00e9termine quelle ressource lib\u00e9rer pour mettre fin \u00e0 l'interblocage. 3.5 Le deadlock dans la vie courante \u2693\ufe0e 3.5.1 L'emballage diabolique \u2693\ufe0e 3.5.2 Le carrefour maudit \u2693\ufe0e 3.5.3 Le ch\u00f4mage \u00e9ternel \u2693\ufe0e 3.6 TP : Mise en \u00e9vidence de la situation d'interblocage \u2693\ufe0e Notebook sur la situation d'interblocage en utilisant Python : CH6_TP_interblocage.ipynb Sources Pages tir\u00e9es de : - https://glassus.github.io/terminale_nsi/T5_Architecture_materielle/5.2_Gestion_des_processus - http://info-mounier.fr/terminale_nsi/archi_se_reseaux/processus.php - http://lycee.educinfo.org/index.php?page=creation_thread&activite=processus - https://www.lecluse.fr/nsi/NSI_T/archi/process/ - http://www.uqac.ca/pguerin/8INF341/Cours9_Interblocage.html} - http://www-inf.it-sudparis.eu/cours/AlgoRep/Web/8.25.html","title":"CH6 Gestion des processus"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#ch6-gestion-des-processus","text":"Programme officiel","title":"CH6 : Gestion des processus"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#1-notion-de-processus","text":"","title":"1. Notion de processus"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#11-definition-dun-processus","text":"Lorsqu'un programme est ex\u00e9cut\u00e9 sur un ordinateur, celui-ci va cr\u00e9er un (ou plusieurs) processus . On dit que ce processus est une instance d'ex\u00e9cution de ce programme. Un processus est caract\u00e9ris\u00e9 par : l'ensemble des instructions qu'il va devoir accomplir (\u00e9crites dans le fichier ex\u00e9cutable obtenu par la compilation du code-source du programme) les ressources que le programme va mobiliser (fichier en ouverture, carte son...) l'\u00e9tat des registres du processeur (voir le cours de Premi\u00e8re sur l' architecture Von Neumann )","title":"1.1 D\u00e9finition d'un processus"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#12-observation-des-processus-sous-linux","text":"","title":"1.2 Observation des processus sous Linux"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#121-la-commande-ps","text":"Dans un terminal, la commande ps va permettre d'afficher la liste des processus actifs. Plus pr\u00e9cis\u00e9ment, nous allons utiliser la commande ps -lu nom_user . L'option l permet d'afficher un grand nombre de renseignements et l'option u permet de sp\u00e9cifier l'utilisateur propri\u00e9taire des processus. On retrouve notamment dans ce tableau les colonnes : CMD (Command) : le nom de la commande qui a cr\u00e9\u00e9 le processus. Vous pouvez y retrouver par ordre chronologique le nom de tous les programmes actifs. Certains sont ceux que vous avez ouverts volontairement (navigateur...) mais on y trouve surtout tous les programmes n\u00e9cessaires au bon fonctionnement du syst\u00e8me d'exploitation. Le dernier processus en bas de la liste est forc\u00e9ment ps , puisque vous venez de l'appeler. PID (Process Identifier) : le num\u00e9ro unique d'identification, affect\u00e9 chronologiquement par le syst\u00e8me d'exploitation. Le processus de PID \u00e9gal \u00e0 1 est systemd , qui est le tout premier programme lanc\u00e9 par le noyau Linux au d\u00e9marrage. PPID (Parent PID) : certains processus vont eux-m\u00eames lancer plusieurs processus-fils, qui porteront le m\u00eame nom. C'est ainsi qu'on peut retrouver de multiples processus s'appelant chrome : Ici, l'instance \u00abprincipale\u00bb de Chrome ( PID 1453) a g\u00e9n\u00e9r\u00e9 6 autres instances de PID diff\u00e9rents, dont le PPID vaut 1453. Dans Chrome/Chromium, vous pouvez comprendre le r\u00f4le de chaque processus en le retrouvant dans le gestionnaire des t\u00e2ches (clic-droit sur une zone vide de la barre d'onglets)","title":"1.2.1 La commande ps"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#122-la-commande-pstree","text":"\u00c0 noter que la commande pstree permet d'afficher les processus sous forme d'arborescence :","title":"1.2.2 La commande pstree"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#123-la-commande-top","text":"La commande top permet de conna\u00eetre en temps r\u00e9el la liste des processus, class\u00e9s par ordre d\u00e9croissant de consommation de CPU. On ferme top par la combinaison de touches Ctrl-C . Si on rep\u00e8re alors un processus qui consomme beaucoup trop de ressources, on peut utiliser...","title":"1.2.3 La commande top"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#124-la-commande-kill","text":"La commande kill permet de fermer un processus, en donnant son PID en argument. Exemple : kill 1453 tuera Chrome (voir la capture du 1.2.1)","title":"1.2.4 La commande kill"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#2-ordonnancement","text":"","title":"2. Ordonnancement"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#21-experience-les-processus-fonctionnent-simultanement-a-tour-de-role","text":"Un ordinateur donne l'illusion de r\u00e9aliser plusieurs t\u00e2ches simultan\u00e9ment. Hormis pour les processeurs fonctionnant avec plusieurs c\u0153urs, il n'en est rien. Comme nous l'avons vu, ces processus sont lanc\u00e9s s\u00e9quentiellement par le syst\u00e8me d'exploitation, et sont ensuite en apparence tous \u00abactifs en m\u00eame temps\u00bb (les guillemets sont importants) : on parle de programmation concurrente . Revenons sur l'expression \u00abactifs en m\u00eame temps\u00bb, car elle v\u00e9hicule une fausse id\u00e9e : ces processus sont bien vivants dans un m\u00eame laps de temps, mais ils s'ex\u00e9cutent LES UNS APR\u00c8S LES AUTRES , le processeur ne pouvant en traiter qu' un seul \u00e0 la fois . Un cadencement extr\u00eamement rapide et efficace donne l' apparence d'une (fausse) simultan\u00e9it\u00e9. Nous allons la mettre en \u00e9vidence : Consid\u00e9rons les fichiers progA.py et progB.py ci-dessous : progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) progB.py import time time . sleep ( 0.01 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) Le programme progB.py est l\u00e9g\u00e8rement retard\u00e9 au d\u00e9marrage par le time.sleep(0.01) . Il devrait donc en r\u00e9sulter un entrelacement entre les phrases programme A en cours et programme B en cours . L'ex\u00e9cution \u00abd'apparence simultan\u00e9e\u00bb de ces deux programmes peut se faire dans un Terminal via la commande python3 progA.py & python3 progB.py . Il en r\u00e9sulte ceci : Nous retrouvons bien l'alternance pr\u00e9vue \u00e0 la lecture du code. Tout se passe donc comme si les deux processus avaient \u00e9t\u00e9 lanc\u00e9s et trait\u00e9s simultan\u00e9ment. R\u00e9duisons maintenant les temporisations (en passant du centi\u00e8me de seconde \u00e0 la milliseconde): progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) progB.py import time time . sleep ( 0.001 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) Il en r\u00e9sulte maintenant ceci : L'alternance pr\u00e9vue n'est plus respect\u00e9e (et les r\u00e9sultats deviennent non-reproductibles). Si la gestion des processus \u00e9tait r\u00e9ellement simultan\u00e9e, m\u00eame en consid\u00e9rant des ralentissements du processeur par des sollicitations ext\u00e9rieures, chaque processus serait ralenti de la m\u00eame mani\u00e8re : l'entrelacement des phrases serait toujours le m\u00eame. En r\u00e9alit\u00e9, le processeur passe son temps \u00e0 alterner entre les divers processus qu'il a \u00e0 g\u00e9rer, et les met en attente quand il ne peut pas s'occuper d'eux. Il ob\u00e9it pour cela aux instructions de son ordonnanceur .","title":"2.1 Exp\u00e9rience : les processus fonctionnent simultan\u00e9ment \u00e0 tour de r\u00f4le."},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#22-lordonnancement-des-processus","text":"","title":"2.2 L'ordonnancement des processus"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#221-differents-types-dordonnancement","text":"Si on vous donne 4 t\u00e2ches A, B, C et D \u00e0 accomplir, vous pouvez d\u00e9cider : de faire la t\u00e2che prioritaire d'abord ; de faire la t\u00e2che la plus rapide d'abord ; de faire la t\u00e2che la plus longue d'abord ; de les faire dans l'ordre o\u00f9 elles vous ont \u00e9t\u00e9 donn\u00e9es ; de faire \u00e0 tour de r\u00f4le chaque t\u00e2che pendant un temps fixe jusqu'\u00e0 ce qu'elles soient toutes termin\u00e9es; ... Un processeur est confront\u00e9 aux m\u00eames choix : comment d\u00e9terminer quel processus doit \u00eatre trait\u00e9 \u00e0 quel moment ? Le sch\u00e9ma ci-dessous (issu de ce site ) pr\u00e9sente quelques politiques d'ordonnancement : Sous Linux, l'ordonnancement est effectu\u00e9 par un syst\u00e8me hybride o\u00f9 les processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le (on parle de tourniquet ou de Round Robin ) suivant un ordre de priorit\u00e9 dynamique. Dans le cas (tr\u00e8s fr\u00e9quent maintenant) d'un processeur multi-c\u0153urs , le probl\u00e8me reste identique. Certes, sur 4 c\u0153urs, 4 processus pourront \u00eatre trait\u00e9s simultan\u00e9ment (une r\u00e9elle simultan\u00e9it\u00e9) mais il reste toujours beaucoup plus de processus \u00e0 traiter que de c\u0153urs dans le processeur... et un ordonnancement est donc toujours n\u00e9cessaire.","title":"2.2.1 Diff\u00e9rents types d'ordonnancement"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#222-les-differents-etats-dun-processus","text":"Selon que l'ordonnanceur aura d\u00e9cid\u00e9 de le confier ou non au processeur pour son ex\u00e9cution, un processus peut donc se trouver dans 3 \u00e9tats : Pr\u00eat : il attend qu'arrive le moment de son ex\u00e9cution. \u00c9lu : il est en cours d'ex\u00e9cution par le processeur. Bloqu\u00e9 : pendant son ex\u00e9cution (\u00e9tat \u00c9lu ), le processus r\u00e9clame une ressource qui n'est pas imm\u00e9diatement disponible. Son ex\u00e9cution s'interrompt. Lorsque la ressource sera disponible, le processus repassera par l'\u00e9tat Pr\u00eat et attendra \u00e0 nouveau son tour. On peut utiliser la m\u00e9taphore suivante : Sur le bureau d'un professeur, il y a 3 paquets de copies, correspondant aux classes A, B, et C. Ces paquets sont Pr\u00eats \u00e0 \u00eatre corrig\u00e9s. Si le professeur ram\u00e8ne devant lui le paquet A, celui-ci devient \u00c9lu , et le professeur peut commencer \u00e0 le corriger. Pour se changer les id\u00e9es, il peut interrompre la correction du paquet A (qui va passer \u00e0 l'\u00e9tat Bloqu\u00e9 ) et ramener vers lui le paquet C. Il pourra ensuite prendre le paquet B, puis \u00e0 nouveau le C, puis le A, ainsi de suite jusqu'\u00e0 ce que tous les paquets soient totalement corrig\u00e9s. Ces paquets seront alors Termin\u00e9s . Au cours de cette proc\u00e9dure, le professeur n'a toujours eu devant lui qu' un seul paquet de copies (soit A, soit B, soit C). Pourquoi l'acc\u00e8s \u00e0 une ressource peut bloquer un processus ? Pendant son ex\u00e9cution, un processus peut avoir besoin d'acc\u00e9der \u00e0 une ressource d\u00e9j\u00e0 occup\u00e9e (un fichier d\u00e9j\u00e0 ouvert, par exemple) ou \u00eatre en attente d'une entr\u00e9e-utilisateur (un input() dans un code Python par exemple). Dans ce cas-l\u00e0, le processeur va passer ce processus \u00e0 l'\u00e9tat Bloqu\u00e9 , pour pouvoir ainsi se consacrer \u00e0 un autre processus. Une fois d\u00e9bloqu\u00e9, le processus va repasser \u00e0 l'\u00e9tat Pr\u00eat et rejoindre (par exemple) la file d'attente des processus avant d'\u00eatre \u00e0 nouveau \u00c9lu et donc ex\u00e9cut\u00e9.","title":"2.2.2 Les diff\u00e9rents \u00e9tats d'un processus"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#3-interblocage","text":"","title":"3. Interblocage"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#31-definition-et-exemple","text":"Comme nous venons de le voir, un processus peut \u00eatre dans l'\u00e9tat bloqu\u00e9 dans l'attente de la lib\u00e9ration d'une ressource. Ces ressources (l'acc\u00e8s en \u00e9criture \u00e0 un fichier, \u00e0 un registre de la m\u00e9moire...) ne peuvent \u00eatre donn\u00e9es \u00e0 deux processus \u00e0 la fois. Des processus souhaitant acc\u00e9der \u00e0 cette ressource sont donc en concurrence sur cette ressource. Un processus peut donc devoir attendre qu'une ressource se lib\u00e8re avant de pouvoir y acc\u00e9der (et ainsi passer de l'\u00e9tat Bloqu\u00e9 \u00e0 l'\u00e9tat Pr\u00eat). Probl\u00e8me : Et si deux processus se bloquent mutuellement la ressource dont ils ont besoin ? Exemple : Consid\u00e9rons 2 processus A et B, et deux ressources R et S. L'action des processus A et B est d\u00e9crite ci-dessous : D\u00e9roulement des processus A et B : A et B sont cr\u00e9\u00e9s et passent \u00e0 l'\u00e9tat Pr\u00eat . L'ordonnanceur d\u00e9clare \u00c9lu le processus A (ou bien B, cela ne change rien). L'\u00e9tape A1 de A est r\u00e9alis\u00e9e : la ressource R est donc affect\u00e9e \u00e0 A. L'ordonnanceur d\u00e9clare maintenant \u00c9lu le processus B. A est donc pass\u00e9 \u00e0 Bloqu\u00e9 en attendant que son tour revienne. L'\u00e9tape B1 de B est r\u00e9alis\u00e9e : la ressource S est donc affect\u00e9e \u00e0 B. L'ordonnanceur d\u00e9clare \u00e0 nouveau \u00c9lu le processus A. B est donc pass\u00e9 \u00e0 Bloqu\u00e9 en attendant que son tour revienne. L'\u00e9tape A2 de A est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource S, qui n'est pas disponible. L'ordonnanceur va donc passer A \u00e0 Bloqu\u00e9 et va revenir au processus B qui redevient \u00c9lu . L'\u00e9tape B2 de B est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource R, qui n'est pas disponible. L'ordonnanceur va donc passer B \u00e0 Bloqu\u00e9 . Les deux processus A et B sont donc dans l'\u00e9tat Bloqu\u00e9 , chacun en attente de la lib\u00e9ration d'une ressource bloqu\u00e9e par l'autre : ils se bloquent mutuellement. Cette situation (critique) est appel\u00e9e interblocage ou deadlock .","title":"3.1 D\u00e9finition et exemple"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#33-representation-schematique","text":"les processus seront repr\u00e9sent\u00e9s par des cercles , les ressources par des carr\u00e9s . Si \u00e0 l'\u00e9tape A1 le processus A a demand\u00e9 et re\u00e7u la ressource R, la repr\u00e9sentation sera : Si \u00e0 l'\u00e9tape A2 le processus A est en attente de la ressource S, la repr\u00e9sentation sera : Avec ces conventions, la situation pr\u00e9c\u00e9dente peut donc se sch\u00e9matiser par : Ce type de sch\u00e9ma fait appara\u00eetre un cycle d'interd\u00e9pendance , qui caract\u00e9rise ici la situation de deadlock.","title":"3.3 Repr\u00e9sentation sch\u00e9matique"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#34-comment-sen-premunir-hp","text":"Il existe trois strat\u00e9gies pour \u00e9viter les interblocages : la pr\u00e9vention : on oblige le processus \u00e0 d\u00e9clarer \u00e0 l'avance la liste de toutes les ressources auxquelles il va acc\u00e9der. l'\u00e9vitement : on fait en sorte qu'\u00e0 chaque \u00e9tape il reste une possibilit\u00e9 d'attribution de ressources qui \u00e9vite le deadlock. la d\u00e9tection/r\u00e9solution : on laisse la situation arriver jusqu'au deadlock, puis un algorithme de r\u00e9solution d\u00e9termine quelle ressource lib\u00e9rer pour mettre fin \u00e0 l'interblocage.","title":"3.4 Comment s'en pr\u00e9munir ? (HP)"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#35-le-deadlock-dans-la-vie-courante","text":"","title":"3.5 Le deadlock dans la vie courante"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH6_Processus/cours/#36-tp-mise-en-evidence-de-la-situation-dinterblocage","text":"Notebook sur la situation d'interblocage en utilisant Python : CH6_TP_interblocage.ipynb Sources Pages tir\u00e9es de : - https://glassus.github.io/terminale_nsi/T5_Architecture_materielle/5.2_Gestion_des_processus - http://info-mounier.fr/terminale_nsi/archi_se_reseaux/processus.php - http://lycee.educinfo.org/index.php?page=creation_thread&activite=processus - https://www.lecluse.fr/nsi/NSI_T/archi/process/ - http://www.uqac.ca/pguerin/8INF341/Cours9_Interblocage.html} - http://www-inf.it-sudparis.eu/cours/AlgoRep/Web/8.25.html","title":"3.6 TP : Mise en \u00e9vidence de la situation d'interblocage"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/","text":"CH8 : Routage \u2693\ufe0e Programme officiel Rappels de premi\u00e8re sur les r\u00e9seaux \u2693\ufe0e Cours \u2693\ufe0e Notations \u00e0 conna\u00eetre par coeur Une adresse IPv4 estcompos\u00e9e de 4 octets, soit 32 bits. Elle est not\u00e9e a.b.c.d, o\u00f9 a, b, c et d sont les valeurs des 4 octets. La notation a.b.c.d/n signifie que les n premiers bits de l'adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits qui suivent repr\u00e9sentent la partie \u00ab machine \u00bb. L'adresse IPv4 dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. L'adresse IPv4 dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 1 est appel\u00e9e \u00ab adresse de diffusion \u00bb ou de \u00ab broadcast \u00bb . Test rapide \u2693\ufe0e question 1 qcm \u00e9l\u00e9ments de correction La communication d'information entre deux machines se fait : par paquets en continu en s\u00e9rie en parall\u00e8le La communication entre deux machines se fait par paquets. Revoir cours de premi\u00e8re. question 2 qcm \u00e9l\u00e9ments de correction Quelles sont les adresses IP valides ? 192.168.1.16 10.0.0.1 192.256.45.2 10.54.16 Les adresses IPv4 sont cod\u00e9es sur 32 bits. Donc sur 4 octets et la valeur d'un octet est comprise entre 0 et 255. question 3 qcm \u00e9l\u00e9ments de correction L'adresse IP en binaire d'une machine est \"11000000.10101000.00010000.10011000\". Quelle est sa repr\u00e9sentation en d\u00e9cimal ? 192.168.16.152 192.168.8.152 192.168.16.76 3.21.8.25 Revoir les conversions binaire/d\u00e9cimal. question 4 qcm \u00e9l\u00e9ments de correction L'adresse IP d'une machine est 192.168.1.16/24. Quelle est l'adresse du r\u00e9seau ? 192.168.1.0 0.0.0.16 192.168.1.24 192.168.0.0 192.168.1.16/24 donc les 24 premiers bits ou les trois premiers octets repr\u00e9sentent la partie r\u00e9seau. Pour avoir l'adresse du r\u00e9seau on met les bits de la partie machine \u00e0 0. Donc le dernier octet vaut 0. question 5 qcm \u00e9l\u00e9ments de correction L'adresse IP d'une machine est 192.168.1.16/24. Quel est le nombre maximal de machines que l'on peut connecter sur le r\u00e9seau ? 254 255 256 16 Les trois premiers octets \u00e9tant r\u00e9serv\u00e9s pour le r\u00e9seau, il reste donc 1 octet (8 bits) pour les adresses machines. Cela nous donne 256 possibilit\u00e9s moins 2 (adresse du r\u00e9seau \u00e0 0 et celle de broadcast \u00e0 255) donc 254 machines maximum. 1. Routeur et routage \u2693\ufe0e 1.1 Qu'est ce qu'un routeur ? \u2693\ufe0e D\u00e9finition Un routeur est un mat\u00e9riel r\u00e9seau (une sorte d'ordinateur), qui a vocation a relayer / router les paquets d'information re\u00e7us en entr\u00e9e, vers leur prochaine destination (le prochain routeur), voire leur destination finale (lorsqu'ils sont arriv\u00e9s). Un routeur dispose de (au moins) 2 interfaces r\u00e9seau : Chaque interface r\u00e9seau d'un routeur dispose d'une adresse IP distincte Chaque interface r\u00e9seau d'un routeur d\u00e9finit un r\u00e9seau diff\u00e9rent Une \" box internet \" est un routeur. Elle permet de transf\u00e9rer des informations (paquets) entre le r\u00e9seau local (ordinateurs, smartphones, TV, objets connect\u00e9s ...) de la maison et le \" r\u00e9seau internet \". Cette box comprend : une interface est connect\u00e9e au r\u00e9seau de votre op\u00e9rateur / Fournisseur d'Acc\u00e8s (FAI) une ou plusieurs interfaces filaires (ethernet) connect\u00e9es \u00e0 votre r\u00e9seau local une interface Wifi En fait, une box familiale joue plusieurs r\u00f4les: Le r\u00f4le de routeur pour d\u00e9terminer les meilleurs routes par lesquelles acheminer/router les paquets de donn\u00e9es. Le r\u00f4le de passerelle / gateway pour sortir du r\u00e9seau local. le r\u00f4le de commutateur / switch pour permettre la communication entre eux des h\u00f4tes d'un m\u00eame r\u00e9seau. 1.2 Quel est son role ? \u2693\ufe0e Essentiellement, le r\u00f4le d'un routeur est de: Relayer / Router les paquets de donn\u00e9es \u2693\ufe0e Chaque routeur re\u00e7oit des donn\u00e9es en entr\u00e9e, sous forme de paquets, et doit d\u00e9cider \u00e0 qui les relayer / rediriger / router : vers le prochain routeur / passerelle / gateway, \u00e9galement surnomm\u00e9 le saut suivant / next hop . En pratique, de mani\u00e8re \u00e9quivalente, le routeur doit d\u00e9terminer vers laquelle de ses propres interfaces de sortie / ports il doit relayer / router / rediriger le paquet. Pour prendre une telle d\u00e9cision, le routeur dispose de table de routage . vers la machine de destination, si le paquet est arriv\u00e9 au routeur final, directement connect\u00e9 r\u00e9seau de destination. Maintenir \u00e0 jour ses tables de Routage \u2693\ufe0e Les r\u00e9seaux sont soumis \u00e0 des \u00e9volutions constantes, pr\u00e9vues ou pas, souhait\u00e9es ou pas. Cela oblige la mise \u00e0 jour/le maintien r\u00e9guliers des tables de routage dans les routeurs en cas d'ajout de nouveau mat\u00e9riel, de pannes impr\u00e9vues, ... 1.3 Qu'est ce que le routage ? \u2693\ufe0e 1.4 Tables de routage. \u2693\ufe0e Une table de routage est une sorte de \"panneau indicateur\" qui donne les routes (les r\u00e9seaux) joignables \u00e0 partir du \"carrefour\" que constitue un routeur. Les paquets arrivent sur une interface de la machine. Pour \"router\" le paquet, le routeur fondera sa d\u00e9cision en deux temps : d\u2019abord il regarde dans l\u2019en-t\u00eate IP le r\u00e9seau de destination et compare toutes les entr\u00e9es dont il dispose dans sa table de routage; ensuite, si le r\u00e9seau de destination est trouv\u00e9, il commute le paquet sur le bon port de sortie; si ce r\u00e9seau n\u2019est pas trouv\u00e9, le paquet est jet\u00e9. Quels sont les \u00e9l\u00e9ments d'une table de routage ? \u2693\ufe0e Le routage IP peut trouv\u00e9e une analogie avec le syst\u00e8me routier ou encore le routage postal. Un r\u00e9seau de destination et son masque = une ville Une passerelle ou une interface de sortie = une direction Une distance administrative ou m\u00e9trique = un kilom\u00e9trage Exemple : \u2693\ufe0e Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). Par exemple, la table de routage du routeur R1 pourrait \u00eatre : Destination Passerelle M\u00e9trique 192.168.0.0 /24 1 172.17.1.0 /24 1 10.0.5.0 /24 1 10.5.2.0 /24 172.17.1.147 2 10.7.3.0 /24 10.0.5.135 2 Dans notre exemple la m\u00e9trique repr\u00e9sente de nombre de saut pour atteindre le r\u00e9seau de destination. Une distance \u00e9gale \u00e0 1 signifie que le r\u00e9seau de destination est directement connect\u00e9 (protocole RIP) Ce n'est pas toujours le cas. On se pr\u00e9ocupera de cette notion de m\u00e9trique dans les protocoles de routage. Exercice \u00c9nonc\u00e9 Solution Construire les tables de routage de R2, R3 et R4. Attention sur le sch\u00e9ma, des routeur n'ont pas d'adresse pour leur interface (passerelle). Il faut donc en allouer une en faisant attention \u00e0 ce qu'elle ne soit pas d\u00e9ja prise. Exemple de solutions : Pour R2 : Destination Passerelle Metrique 172.17.1.0 /24 1 10.5.2.0 /24 1 192.168.0.0 /24 172.17.1.254 2 10.0.5.0 /24 172.17.1.254 2 10.7.3.0 /24 10.5.2.254 2 Pour R3 : Destination Passerelle Metrique 10.0.5.0 /24 1 10.7.3.0 /24 1 172.17.1.0 /24 10.0.5.152 2 10.5.2.0 /24 10.7.3.132 2 192.168.0.0 /24 10.0.5.152 2 Pour R4 : Destination Passerelle Metrique 10.5.2.0 /24 1 10.7.3.0 /24 1 10.0.5.0 /24 10.7.3.254 2 172.17.1.0 /24 10.5.2.138 2 192.168.0.0 /24 10.5.2.138 3 Remarque : pour atteindre le r\u00e9seau 192.168.0.0, on peut passer par la passerelle 10.7.3.254 en 3 sauts \u00e9galement. \u00c0 retenir Lorsque que l'adresse IP de destination d'un paquet ne fait pas partie du sous r\u00e9seau auquel la machine \u00e9mettrice appartient, le routeur interroge sa table de routage pour conna\u00eetre l'adresse de la passerelle vers qui rediriger le paquet. Dans la table de routage on va donc trouver : l' adresse du r\u00e9seau destinataire (avec le masque de sous r\u00e9seau). l' adresse de la passerelle . C'est l'adresse du routeur suivant vers qui on doit acheminer le paquet. Lorsque le r\u00e9seau de destination est directement accessible on ne note pas l'adresse ou on met 0.0.0.0 (C'est une adresse invalide qui signifie \"toutes directions\" ou \"destination non sp\u00e9cifi\u00e9e\".). Dans certaines tables simplifi\u00e9es, on donne directement le nom du routeur suivant (R2, R3 ...). l' interface (wifi, ethernet ...). Dans nos exercices et exemples, elle n'est pas toujours renseign\u00e9e car l'info est non essentielle pour comprendre le m\u00e9canisme de routage. la m\u00e9trique ou le nombre de sauts (cela va d\u00e9pendre du protocole utilis\u00e9 : RIP, OSPF ...) Comment sont construites les tables de routage ? \u2693\ufe0e Soit \u00e0 la main par l'administrateur r\u00e9seau, quand le r\u00e9seau est petit : on parle alors de table statique . Soit de mani\u00e8re dynamique : les r\u00e9seaux s'envoient eux-m\u00eames des informations permettant de mettre \u00e0 jour leurs tables de routages respectives. Des algorithmes de d\u00e9termination de meilleur chemin sont alors utilis\u00e9s : nous allons en d\u00e9couvrir deux, le protocole RIP et le protocole OSPF. 2. Protocoles de routage \u2693\ufe0e 2.1 protocole RIP \u2693\ufe0e Le protocole RIP - Routing Information Protocol est un protocole dit \u00e0 vecteur de distance. Le protocole RIP est un des premiers algorithmes utilis\u00e9s pour \u00e9tablir les tables de routage des routeurs interconnectant des r\u00e9seaux. Les paquets sont achemin\u00e9s en s\u2019appuyant sur l\u2019algorithme de Bellman-Ford (pas au BAC). Cet algorithme permet de calculer les plus courts chemins dans un graphe. TP RIP d\u00e9branch\u00e9 \u2693\ufe0e sujet \u00c9tablissement des tables de routage \u2693\ufe0e Il comporte les 3 \u00e9tapes suivantes : - \u00c9tape 1 - \u2693\ufe0e Initialement (\u00e0 la mise sous tension), la table de routage d\u2019un routeur contient uniquement des informations sur ses voisins directs (ceux auxquels il est connect\u00e9). Exemple : Initialement (mise sous tension) la table de routage de R1 contient uniquement les r\u00e9seaux 192.168.1.0 /24 et 10.1.1.0 /30. Table de routage de R1 R\u00e9seau destination Passerelle Interface M\u00e9trique 192.168.1.0 /24 wlan0 1 10.1.1.0 /30 eth1 1 Aucune passerelle n\u2019est sp\u00e9cifi\u00e9e car le routeur peut atteindre le r\u00e9seau destination directement. - \u00c9tape 2 - \u2693\ufe0e Chaque routeur envoie p\u00e9riodiquement (toutes les 30 secondes), \u00e0 tous ses voisins (routeurs adjacents), un message contenant : la liste de toutes les adresses de r\u00e9seaux qu\u2019il connait (ses voisins directs et ceux qu\u2019il a re\u00e7u auparavant) leur m\u00e9trique (le nombre de sauts pour les atteindre). Ce couple d\u2019informations (r\u00e9seau, m\u00e9trique) est appel\u00e9 vecteur de distance . - \u00c9tape 3 - \u2693\ufe0e \u00c0 chaque r\u00e9ception d\u2019un message de ce type, un routeur met \u00e0 jour sa table de routage avec les informations re\u00e7ues. Quatre cas peuvent se pr\u00e9senter : 1. il d\u00e9couvre une nouvelle route vers un sous r\u00e9seau qu\u2019il ne connaissait pas encore : il l\u2019ajoute \u00e0 sa table. 2. il d\u00e9couvre une nouvelle route plus courte vers un sous r\u00e9seau qu\u2019il connaissait d\u00e9j\u00e0 : il remplace l\u2019ancienne route par la nouvelle. 3. il re\u00e7oit une nouvelle route plus longue vers un sous r\u00e9seau qu\u2019il connaissait d\u00e9j\u00e0 : il ne fait rien. 4. il re\u00e7oit une route existante dans sa table (passant par le m\u00eame voisin), mais plus longue. Cela signifie que la route s\u2019est allong\u00e9e (panne ?) : il met sa table \u00e0 jour. Pour renseigner la colonne \u00ab m\u00e9trique \u00bb, le protocole utilise le nombre de sauts, autrement dit, le nombre de routeurs qui doivent \u00eatre travers\u00e9s pour atteindre le r\u00e9seau cible. Exemple : le routeur R1 re\u00e7oit des messages de la part de son seul voisin R3. Ce message contient les vecteurs de distance suivants : (10.1.2.0 /30 , 1) (10.1.3.0 /30 , 1) (10.1.4.0 /30 , 1) et tous les vecteurs de distance concernant les autres r\u00e9seaux qu\u2019il \u00ab connait \u00bb. Du point de vue de R1, R3 (d\u2019adresse 10.1.1.2 /30) est une passerelle. Sa table de routage devient alors : Table de routage de R1 R\u00e9seau destination Passerelle Interface M\u00e9trique 192.168.1.0 /24 wlan0 1 10.1.1.0 /30 eth1 1 10.1.2.0 /30 10.1.1.2 /30 eth1 2 10.1.3.0 /30 10.1.1.2 /30 eth1 2 10.1.4.0 /30 10.1.1.2 /30 eth1 2 D\u00e9lai de convergence \u2693\ufe0e On appelle d\u00e9lai de convergence le temps n\u00e9cessaire \u00e0 ce que l\u2019ensemble des routeurs soient configur\u00e9s pour offrir les meilleurs routes possible. \u00c0 chaque modification du r\u00e9seau (ajout ou suppression de routeurs), il faut un certain temps pour que les \u00e9changes de messages RIP m\u00e8nent \u00e0 une situation stable. C\u2019est pour limiter ce d\u00e9lai de convergence que le protocole RIP est limit\u00e9 \u00e0 15 sauts. D\u00e9tection des pannes \u2693\ufe0e Lorsqu\u2019un routeur ne re\u00e7oit pas de r\u00e9ponse de la part d\u2019un autre routeur \u00e0 une demande RIP (apr\u00e8s un certain laps de temps, 3 minutes), il consid\u00e8re que le routeur en question est en panne. Afin qu\u2019aucun paquet ne soit plus dirig\u00e9 dans cette direction, il pr\u00e9vient ses voisins en leur envoyant une m\u00e9trique \u00e9gale \u00e0 16 (plus grande valeur possible pour le protocole RIP) concernant toutes les routes passant par le routeur qui ne r\u00e9pond pas. Boucle de routage \u2693\ufe0e Une boucle de routage est le ph\u00e9nom\u00e8ne qui se produit lorsqu\u2019un paquet tourne en boucle et ne peut jamais atteindre sa destination. Diff\u00e9rentes r\u00e8gles dans le protocole RIP permettent d\u2019\u00e9viter que cela se produise, et notamment la r\u00e8gle split horizon, qui interdit \u00e0 un routeur d\u2019envoyer une information de routage via le routeur qui lui a envoy\u00e9. Le protocole RIP est aujourd\u2019hui tr\u00e8s rarement utilis\u00e9 dans les grandes infrastructures car il g\u00e9n\u00e8re, du fait de l\u2019envoi p\u00e9riodique de messages, un trafic r\u00e9seau important (surtout si les tables de routages contiennent beaucoup d\u2019entr\u00e9es). De plus, le protocole RIP est limit\u00e9 \u00e0 15 sauts (on traverse au maximum 15 routeurs pour atteindre sa destination). On lui pr\u00e9f\u00e8re donc souvent le protocole OSPF. Remarques concernant la m\u00e9trique Au sens du protocole RIP, La m\u00e9trique ou distance d'un routeur \u00e0 un r\u00e9seau de destination est le nombre de sauts (de routeurs) ou hops qui le s\u00e9parent de ce r\u00e9seau, c\u00e0d le nombre de routeurs devant \u00eatre travers\u00e9s/saut\u00e9s pour parvenir au r\u00e9seau. Dans le protocole RIP, la distance est un nombre entier compris entre 1 et 15 inclus. Une distance \u00e9gale \u00e0 1 signifie que le r\u00e9seau de destination est directement connect\u00e9. Une distance \u00e9gale \u00e0 16 repr\u00e9sente l'infini, donc que le r\u00e9seau de destination n'est pas atteignable. Remarques et inconv\u00e9nients Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor. La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF. 2.2 protocole OSPF \u2693\ufe0e Le protocole OSPF : Open Shortest Path First rentre dans la cat\u00e9gorie plus g\u00e9n\u00e9rale des protocoles \u00e0 \u00c9tats de Lien. Explication : Un inconv\u00e9nient majeur du protocole pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. principe fondamental du protocole OSPF Le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Donc dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur. Les diff\u00e9rents types de liaison et leur co\u00fbt \u2693\ufe0e On peut, approximativement, classer les types de liaison suivant ce tableau de d\u00e9bits th\u00e9oriques : Technologie BP descendante BP montante Modem 56 kbit/s 48 kbit/s Bluetooth 3 Mbit/s 3 Mbit/s Ethernet 10 Mbit/s 10 Mbit/s Wi-Fi 10 Mbit/s ~ 10 Gbits/s 10 Mbit/s ~ 10 Gbits/s ADSL 13 Mbit/s 1 Mbit/s 4G 100 Mbit/s 50 Mbit/s Satellite 50 Mbit/s 1 Mbit/s Fast Ethernet 100 Mbit/s 100 Mbit/s FFTH (fibre) 10 Gbit/s 10 Gbit/s 5G 20 Gbit/s 10 Gbit/s L'id\u00e9e du protocole OSPF est de pond\u00e9rer chaque trajet entre routeurs (comptant simplement pour \u00ab1\u00bb dans le protocole RIP) par une valeur de co\u00fbt inversement proportionnelle au d\u00e9bit de transfert. Par exemple, si le d\u00e9bit \\(d\\) est exprim\u00e9 en bits/s, on peut calculer le co\u00fbt de chaque liaison par la formule : \\[ \\text{co\u00fbt} = \\frac{10^8}{d} \\] Cette formule de calcul peut \u00eatre diff\u00e9rente suivant les exercices, et sera syst\u00e9matiquement redonn\u00e9e. N\u00e9anmoins la valeur \\(d\\) sera toujours au d\u00e9nominateur, pour assurer la proportionnalit\u00e9 inverse du d\u00e9bit. Avec cette convention, un route entre deux routeurs reli\u00e9s en Fast Ethernet (100 Mbits/s) aura a un poids de 1, une liaison satellite de 20 Mbits/s aura un poids de 5, etc. Exemple \u2693\ufe0e Reprenons le r\u00e9seau suivant : et simplifions-le en ne gardant que les liens entre routeurs, en indiquant leur d\u00e9bit : Notre r\u00e9seau est devenu un graphe . Nous allons pond\u00e9rer ses ar\u00eates avec la fonction co\u00fbt introduite pr\u00e9c\u00e9demment. L'unit\u00e9 \u00e9tant le Mbit/s, l'ar\u00eate entre R1 et R3 aura un poids de \\(\\frac{100}{20}=5\\) . Le graphe pond\u00e9r\u00e9 est donc : Le chemin le plus rapide pour aller de l'ordinateur au serveur est donc R1-R2-R4, et non plus R1-R3 comme l'aurait indiqu\u00e9 le protocole RIP. Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9 \u2693\ufe0e L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exercice d'application de l'algorithme de Dijkstra (HP) Donner le plus court chemin pour aller de E \u00e0 F dans le graphe ci-dessous : correction E A B C D F Choix 0 -- -- -- -- -- E(0) . 30vE -- 40vE 10vE -- D(10) . 20vD -- 40vE . 80vD A(20) . . 60vA 30vA . 80vD C(30) . . 50vC . . 80vD B(50) . . . . . 70vB F(70) Le meilleur trajet est donc E-D-A-C-B-F. Attention ce trajet correspond \u00e0 la colonne choix (dans l'ordre) mais c'est un hasard. 3. Exercices \u2693\ufe0e extrait du sujet 0 - BAC \u2693\ufe0e On consid\u00e8re le r\u00e9seau suivant : On rappelle que le co\u00fbt d\u2019une liaison est donn\u00e9 par la formule suivante : \\[ \\text{co\u00fbt} = \\frac{10^8}{d} \\] Question 1 V\u00e9rifier que le co\u00fbt de la liaison entre les routeurs A et B est 0,01. La liaison entre le routeur B et D a un co\u00fbt de 5. Quel est le d\u00e9bit de cette liaison ? Question 2 Le routeur A doit transmettre un message au routeur G, en empruntant le chemin dont la somme des co\u00fbts sera la plus petite possible. D\u00e9terminer le chemin parcouru. On indiquera le raisonnement utilis\u00e9. Correction Q1 1. \\(\\text{co\u00fbt} = \\dfrac{10^8}{10 \\times 10^9}= \\dfrac{10^8}{10^{10}}= 10^{-2}=0,01\\) 2. \\(5=\\dfrac{10^8}{d}\\) donc \\(d=\\dfrac{10^8}{5}=20 \\times 10^6\\) = 20 Mb/s Q2 Le graphe pond\u00e9r\u00e9 par les co\u00fbts est : On peut y deviner le chemin de co\u00fbt minimal entre A et G, qui est A-D-E-G (co\u00fbt 1,011). Pour le justifier, on peut (non obligatoire) faire un algorithme de Dijkstra : 2021, sujet M\u00e9tropole 1 \u2693\ufe0e On repr\u00e9sente ci-dessous un r\u00e9seau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le r\u00e9seau local L1 est reli\u00e9 au routeur R1 et le r\u00e9seau local L2 au routeur R6. ``` Dans cet exercice, les adresses IP sont compos\u00e9es de 4 octets, soit 32 bits. Elles sont not\u00e9es X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants repr\u00e9sentent la partie \u00ab h\u00f4te \u00bb. Toutes les adresses des h\u00f4tes connect\u00e9s \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau et peuvent donc communiquer directement. L\u2019adresse IP dont tous les bits de la partie \u00ab h\u00f4te \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. On donne \u00e9galement des extraits de la table de routage des routeurs R1 \u00e0 R5 dans le tableau suivant : Question 1 Un paquet part du r\u00e9seau local L1 \u00e0 destination du r\u00e9seau local L2. 1.a. En utilisant l\u2019extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier. 1.b. A l\u2019aide des extraits de tables de routage ci-dessus, nommer les routeurs travers\u00e9s par ce paquet, lorsqu\u2019il va du r\u00e9seau L1 au r\u00e9seau L2. Question 2 La liaison entre R1 et R2 est rompue. 2.a. Sachant que ce r\u00e9seau utilise le protocole RIP (distance en nombre de sauts), donner l\u2019un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2. 2.b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifi\u00e9e(s) ? Question 3 On a r\u00e9tabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du d\u00e9bit des liaisons, on d\u00e9cide d\u2019utiliser le protocole OSPF (distance li\u00e9e au co\u00fbt minimal des liaisons) pour effectuer le routage. Le co\u00fbt des liaisons entre les routeurs est donn\u00e9 par le tableau suivant : 3.a. Le co\u00fbt C d\u2019une liaison est donn\u00e9 ici par la formule \\(C = \\dfrac{10^9}{BP}\\) o\u00f9 \\(BP\\) est la bande passante de la connexion en bps (bits par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le co\u00fbt correspondant. 3.b. D\u00e9terminer le chemin parcouru par un paquet partant du r\u00e9seau L1 et arrivant au r\u00e9seau L2, en utilisant le protocole OSPF. 3.c. Indiquer pour quel(s) routeur(s) l\u2019extrait de la table de routage sera modifi\u00e9 pour un paquet \u00e0 destination de L2, avec la m\u00e9trique OSPF. Correction 1.a. D'apr\u00e8s la table, R1 doit passer par la passerelle 86.154.10.1 qui correspond au routeur R2. 1.b. Le paquet va traverser R1, R2, R6 avant d'arriver \u00e0 L2. 2.a. RIP doit minimiser le nombre de sauts, donc les deux chemins minimaux possibles sont R1-R3-R4-R6 et R1-R3-R2-R6. 2.b. La ligne R1 sera modifi\u00e9e, il faudra partir vers R3 (et son r\u00e9seau 112.44.65.0/24). Les autres lignes n'ont pas \u00e0 \u00eatre modifi\u00e9es puisque R3 am\u00e8ne en R4 qui am\u00e8ne en R6. 3.a \\(\\dfrac{10^9}{10 \\times 10^6}=100\\) donc le co\u00fbt R2-R3 est 100. 3.b. Avec OSPF, le chemin qui minimise le co\u00fbt est le chemin R1-R2-R4-R5-R6 (co\u00fbt 103) : 3.c. Dans la table de routage initiale, il faut modifier R2 pour qu'elle envoie sur R4 (et non sur R6), mais aussi R4 pour qu'elle envoie sur R5 (et non sur R6). Sites utilis\u00e9s et sources https://glassus.github.io/terminale_nsi/T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/ https://eskool.gitlab.io/tnsi/reseaux/ https://info.blaisepascal.fr/nsi-protocoles-de-routage https://cisco.goffinet.org/ccna/ Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER.","title":"CH8 Routage"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#ch8-routage","text":"Programme officiel","title":"CH8 : Routage"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#rappels-de-premiere-sur-les-reseaux","text":"","title":"Rappels de premi\u00e8re sur les r\u00e9seaux"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#cours","text":"Notations \u00e0 conna\u00eetre par coeur Une adresse IPv4 estcompos\u00e9e de 4 octets, soit 32 bits. Elle est not\u00e9e a.b.c.d, o\u00f9 a, b, c et d sont les valeurs des 4 octets. La notation a.b.c.d/n signifie que les n premiers bits de l'adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits qui suivent repr\u00e9sentent la partie \u00ab machine \u00bb. L'adresse IPv4 dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. L'adresse IPv4 dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 1 est appel\u00e9e \u00ab adresse de diffusion \u00bb ou de \u00ab broadcast \u00bb .","title":"Cours"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#test-rapide","text":"question 1 qcm \u00e9l\u00e9ments de correction La communication d'information entre deux machines se fait : par paquets en continu en s\u00e9rie en parall\u00e8le La communication entre deux machines se fait par paquets. Revoir cours de premi\u00e8re. question 2 qcm \u00e9l\u00e9ments de correction Quelles sont les adresses IP valides ? 192.168.1.16 10.0.0.1 192.256.45.2 10.54.16 Les adresses IPv4 sont cod\u00e9es sur 32 bits. Donc sur 4 octets et la valeur d'un octet est comprise entre 0 et 255. question 3 qcm \u00e9l\u00e9ments de correction L'adresse IP en binaire d'une machine est \"11000000.10101000.00010000.10011000\". Quelle est sa repr\u00e9sentation en d\u00e9cimal ? 192.168.16.152 192.168.8.152 192.168.16.76 3.21.8.25 Revoir les conversions binaire/d\u00e9cimal. question 4 qcm \u00e9l\u00e9ments de correction L'adresse IP d'une machine est 192.168.1.16/24. Quelle est l'adresse du r\u00e9seau ? 192.168.1.0 0.0.0.16 192.168.1.24 192.168.0.0 192.168.1.16/24 donc les 24 premiers bits ou les trois premiers octets repr\u00e9sentent la partie r\u00e9seau. Pour avoir l'adresse du r\u00e9seau on met les bits de la partie machine \u00e0 0. Donc le dernier octet vaut 0. question 5 qcm \u00e9l\u00e9ments de correction L'adresse IP d'une machine est 192.168.1.16/24. Quel est le nombre maximal de machines que l'on peut connecter sur le r\u00e9seau ? 254 255 256 16 Les trois premiers octets \u00e9tant r\u00e9serv\u00e9s pour le r\u00e9seau, il reste donc 1 octet (8 bits) pour les adresses machines. Cela nous donne 256 possibilit\u00e9s moins 2 (adresse du r\u00e9seau \u00e0 0 et celle de broadcast \u00e0 255) donc 254 machines maximum.","title":"Test rapide"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#1-routeur-et-routage","text":"","title":"1. Routeur et routage"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#11-quest-ce-quun-routeur","text":"D\u00e9finition Un routeur est un mat\u00e9riel r\u00e9seau (une sorte d'ordinateur), qui a vocation a relayer / router les paquets d'information re\u00e7us en entr\u00e9e, vers leur prochaine destination (le prochain routeur), voire leur destination finale (lorsqu'ils sont arriv\u00e9s). Un routeur dispose de (au moins) 2 interfaces r\u00e9seau : Chaque interface r\u00e9seau d'un routeur dispose d'une adresse IP distincte Chaque interface r\u00e9seau d'un routeur d\u00e9finit un r\u00e9seau diff\u00e9rent Une \" box internet \" est un routeur. Elle permet de transf\u00e9rer des informations (paquets) entre le r\u00e9seau local (ordinateurs, smartphones, TV, objets connect\u00e9s ...) de la maison et le \" r\u00e9seau internet \". Cette box comprend : une interface est connect\u00e9e au r\u00e9seau de votre op\u00e9rateur / Fournisseur d'Acc\u00e8s (FAI) une ou plusieurs interfaces filaires (ethernet) connect\u00e9es \u00e0 votre r\u00e9seau local une interface Wifi En fait, une box familiale joue plusieurs r\u00f4les: Le r\u00f4le de routeur pour d\u00e9terminer les meilleurs routes par lesquelles acheminer/router les paquets de donn\u00e9es. Le r\u00f4le de passerelle / gateway pour sortir du r\u00e9seau local. le r\u00f4le de commutateur / switch pour permettre la communication entre eux des h\u00f4tes d'un m\u00eame r\u00e9seau.","title":"1.1 Qu'est ce qu'un routeur ?"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#12-quel-est-son-role","text":"Essentiellement, le r\u00f4le d'un routeur est de:","title":"1.2 Quel est son role ?"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#13-quest-ce-que-le-routage","text":"","title":"1.3 Qu'est ce que le routage ?"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#14-tables-de-routage","text":"Une table de routage est une sorte de \"panneau indicateur\" qui donne les routes (les r\u00e9seaux) joignables \u00e0 partir du \"carrefour\" que constitue un routeur. Les paquets arrivent sur une interface de la machine. Pour \"router\" le paquet, le routeur fondera sa d\u00e9cision en deux temps : d\u2019abord il regarde dans l\u2019en-t\u00eate IP le r\u00e9seau de destination et compare toutes les entr\u00e9es dont il dispose dans sa table de routage; ensuite, si le r\u00e9seau de destination est trouv\u00e9, il commute le paquet sur le bon port de sortie; si ce r\u00e9seau n\u2019est pas trouv\u00e9, le paquet est jet\u00e9.","title":"1.4 Tables de routage."},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#2-protocoles-de-routage","text":"","title":"2. Protocoles de routage"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#21-protocole-rip","text":"Le protocole RIP - Routing Information Protocol est un protocole dit \u00e0 vecteur de distance. Le protocole RIP est un des premiers algorithmes utilis\u00e9s pour \u00e9tablir les tables de routage des routeurs interconnectant des r\u00e9seaux. Les paquets sont achemin\u00e9s en s\u2019appuyant sur l\u2019algorithme de Bellman-Ford (pas au BAC). Cet algorithme permet de calculer les plus courts chemins dans un graphe.","title":"2.1 protocole RIP"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#22-protocole-ospf","text":"Le protocole OSPF : Open Shortest Path First rentre dans la cat\u00e9gorie plus g\u00e9n\u00e9rale des protocoles \u00e0 \u00c9tats de Lien. Explication : Un inconv\u00e9nient majeur du protocole pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. principe fondamental du protocole OSPF Le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Donc dans le protocole OSPF, les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP) et de la qualit\u00e9 technique de la liaison entre chaque routeur.","title":"2.2 protocole OSPF"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#trouver-le-plus-court-chemin-dans-un-graphe-pondere","text":"L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exercice d'application de l'algorithme de Dijkstra (HP) Donner le plus court chemin pour aller de E \u00e0 F dans le graphe ci-dessous : correction E A B C D F Choix 0 -- -- -- -- -- E(0) . 30vE -- 40vE 10vE -- D(10) . 20vD -- 40vE . 80vD A(20) . . 60vA 30vA . 80vD C(30) . . 50vC . . 80vD B(50) . . . . . 70vB F(70) Le meilleur trajet est donc E-D-A-C-B-F. Attention ce trajet correspond \u00e0 la colonne choix (dans l'ordre) mais c'est un hasard.","title":"Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#3-exercices","text":"","title":"3. Exercices"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#extrait-du-sujet-0-bac","text":"On consid\u00e8re le r\u00e9seau suivant : On rappelle que le co\u00fbt d\u2019une liaison est donn\u00e9 par la formule suivante : \\[ \\text{co\u00fbt} = \\frac{10^8}{d} \\] Question 1 V\u00e9rifier que le co\u00fbt de la liaison entre les routeurs A et B est 0,01. La liaison entre le routeur B et D a un co\u00fbt de 5. Quel est le d\u00e9bit de cette liaison ? Question 2 Le routeur A doit transmettre un message au routeur G, en empruntant le chemin dont la somme des co\u00fbts sera la plus petite possible. D\u00e9terminer le chemin parcouru. On indiquera le raisonnement utilis\u00e9. Correction Q1 1. \\(\\text{co\u00fbt} = \\dfrac{10^8}{10 \\times 10^9}= \\dfrac{10^8}{10^{10}}= 10^{-2}=0,01\\) 2. \\(5=\\dfrac{10^8}{d}\\) donc \\(d=\\dfrac{10^8}{5}=20 \\times 10^6\\) = 20 Mb/s Q2 Le graphe pond\u00e9r\u00e9 par les co\u00fbts est : On peut y deviner le chemin de co\u00fbt minimal entre A et G, qui est A-D-E-G (co\u00fbt 1,011). Pour le justifier, on peut (non obligatoire) faire un algorithme de Dijkstra :","title":"extrait du sujet 0 - BAC"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH8_Routage/cours/#2021-sujet-metropole-1","text":"On repr\u00e9sente ci-dessous un r\u00e9seau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le r\u00e9seau local L1 est reli\u00e9 au routeur R1 et le r\u00e9seau local L2 au routeur R6. ``` Dans cet exercice, les adresses IP sont compos\u00e9es de 4 octets, soit 32 bits. Elles sont not\u00e9es X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants repr\u00e9sentent la partie \u00ab h\u00f4te \u00bb. Toutes les adresses des h\u00f4tes connect\u00e9s \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau et peuvent donc communiquer directement. L\u2019adresse IP dont tous les bits de la partie \u00ab h\u00f4te \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. On donne \u00e9galement des extraits de la table de routage des routeurs R1 \u00e0 R5 dans le tableau suivant : Question 1 Un paquet part du r\u00e9seau local L1 \u00e0 destination du r\u00e9seau local L2. 1.a. En utilisant l\u2019extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier. 1.b. A l\u2019aide des extraits de tables de routage ci-dessus, nommer les routeurs travers\u00e9s par ce paquet, lorsqu\u2019il va du r\u00e9seau L1 au r\u00e9seau L2. Question 2 La liaison entre R1 et R2 est rompue. 2.a. Sachant que ce r\u00e9seau utilise le protocole RIP (distance en nombre de sauts), donner l\u2019un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2. 2.b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifi\u00e9e(s) ? Question 3 On a r\u00e9tabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du d\u00e9bit des liaisons, on d\u00e9cide d\u2019utiliser le protocole OSPF (distance li\u00e9e au co\u00fbt minimal des liaisons) pour effectuer le routage. Le co\u00fbt des liaisons entre les routeurs est donn\u00e9 par le tableau suivant : 3.a. Le co\u00fbt C d\u2019une liaison est donn\u00e9 ici par la formule \\(C = \\dfrac{10^9}{BP}\\) o\u00f9 \\(BP\\) est la bande passante de la connexion en bps (bits par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le co\u00fbt correspondant. 3.b. D\u00e9terminer le chemin parcouru par un paquet partant du r\u00e9seau L1 et arrivant au r\u00e9seau L2, en utilisant le protocole OSPF. 3.c. Indiquer pour quel(s) routeur(s) l\u2019extrait de la table de routage sera modifi\u00e9 pour un paquet \u00e0 destination de L2, avec la m\u00e9trique OSPF. Correction 1.a. D'apr\u00e8s la table, R1 doit passer par la passerelle 86.154.10.1 qui correspond au routeur R2. 1.b. Le paquet va traverser R1, R2, R6 avant d'arriver \u00e0 L2. 2.a. RIP doit minimiser le nombre de sauts, donc les deux chemins minimaux possibles sont R1-R3-R4-R6 et R1-R3-R2-R6. 2.b. La ligne R1 sera modifi\u00e9e, il faudra partir vers R3 (et son r\u00e9seau 112.44.65.0/24). Les autres lignes n'ont pas \u00e0 \u00eatre modifi\u00e9es puisque R3 am\u00e8ne en R4 qui am\u00e8ne en R6. 3.a \\(\\dfrac{10^9}{10 \\times 10^6}=100\\) donc le co\u00fbt R2-R3 est 100. 3.b. Avec OSPF, le chemin qui minimise le co\u00fbt est le chemin R1-R2-R4-R5-R6 (co\u00fbt 103) : 3.c. Dans la table de routage initiale, il faut modifier R2 pour qu'elle envoie sur R4 (et non sur R6), mais aussi R4 pour qu'elle envoie sur R5 (et non sur R6). Sites utilis\u00e9s et sources https://glassus.github.io/terminale_nsi/T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/ https://eskool.gitlab.io/tnsi/reseaux/ https://info.blaisepascal.fr/nsi-protocoles-de-routage https://cisco.goffinet.org/ccna/ Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER.","title":"2021, sujet M\u00e9tropole 1"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/","text":"CH9 : Cryptographie \u2693\ufe0e Programme officiel 1. Chiffrement sym\u00e9trique \u2693\ufe0e 1.1 Activit\u00e9 du masque jetable \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aide Correction On consid\u00e8re la variable suivante : masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" Cr\u00e9er une fonction chiffre(message, masque) qui chiffre message en le XORant avec masque . Cette fonction doit pouvoir aussi servir \u00e0 d\u00e9chiffrer le message chiffr\u00e9. Le XOR (voir ici ) est une op\u00e9ration sym\u00e9trique : >>> 34 ^ 23 53 >>> 53 ^ 23 34 La fonction ord permet de renvoyer le code ASCII d'un caract\u00e8re. La fonction chr fait l'op\u00e9ration inverse. >>> ord ( 'A' ) 65 >>> chr ( 65 ) 'A' 1 2 3 4 5 6 7 8 masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" def chiffre ( message , masque ): message_chiffre = \"\" for i in range ( len ( message )): lettre_chiffree = chr ( ord ( message [ i ]) ^ ord ( masque [ i ])) message_chiffre += lettre_chiffree return message_chiffre 1.2 Principe du chiffrement sym\u00e9trique \u2693\ufe0e Dans un chiffrement sym\u00e9trique, c'est la m\u00eame cl\u00e9 qui va servir au chiffrement et au d\u00e9chiffrement. Qu'appelle-t-on une cl\u00e9 ? \u2693\ufe0e La cl\u00e9 est un renseignement permettant de chiffrer ou d\u00e9chiffrer un message. Cela peut \u00eatre : un nombre (dans un simple d\u00e9calage des lettres de l'alphabet, comme le chiffre de C\u00e9sar ) une phrase (dans la m\u00e9thode du masque jetable ) une image (imaginez un chiffrement o\u00f9 on effectue un XOR par les pixels d'une image, comme dans cette \u00e9nigme ) Un chiffrement est dit sym\u00e9trique lorsque la connaissance de la cl\u00e9 ayant servi au chiffrement permet de d\u00e9chiffrer le message. Par exemple, Alice chiffre son message en d\u00e9calant les lettres de 3 rangs vers la droite dans l'alphabet, Bob saura qu'il doit les d\u00e9caler de 3 rangs vers la gauche pour retrouver le message initial. Quel est l'avantage d'un chiffrement sym\u00e9trique ? \u2693\ufe0e Les chiffrements sym\u00e9triques sont souvent rapides, consommant peu de ressources et donc adapt\u00e9s au chiffrement de flux important d'informations. Comme nous le verrons, la s\u00e9curisation des donn\u00e9es transitant par le protocole https est bas\u00e9e sur un chiffrement sym\u00e9trique. Quel est l'inconv\u00e9nient d'un chiffrement sym\u00e9trique ? \u2693\ufe0e La cl\u00e9 ! Si Alice et Bob ont besoin d'utiliser un chiffrement pour se parler, comment peuvent-ils \u00e9changer leurs cl\u00e9s puisque leur canal de transmission n'est pas s\u00fbr ? Le chiffrement sym\u00e9trique impose qu'Alice et Bob aient pu se rencontrer physiquement au pr\u00e9alable pour convenir d'une cl\u00e9 secr\u00e8te, ou bien qu'ils aient r\u00e9ussi \u00e0 \u00e9tablir une connexion s\u00e9curis\u00e9e pour s'\u00e9changer cette cl\u00e9. Un chiffrement sym\u00e9trique est-il un chiffrement de mauvaise qualit\u00e9 ? \u2693\ufe0e Pas du tout ! S'il est associ\u00e9 naturellement \u00e0 des chiffrements simples et faibles (comme le d\u00e9calage de C\u00e9sar), un chiffrement sym\u00e9trique peut \u00eatre tr\u00e8s robuste... voire inviolable. C'est le cas du masque jetable. Si le masque avec lequel on effectue le XOR sur le message est aussi long que le message, alors il est impossible de retrouver le message initial. Pourquoi ? Imaginons qu'Alice veuille transmettre le message clair \"LUNDI\". Elle le chiffre avec un masque jetable (que connait aussi Bob), et Bob re\u00e7oit donc \"KHZOK\". Si Marc a intercept\u00e9 le message \"KHZOK\", m\u00eame s'il sait que la m\u00e9thode de chiffrement utilis\u00e9e est celle du masque jetable (principe de Kerckhoffs), il n'a pas d'autre choix que de tester tous les masques de 5 lettres possibles. Ce qui lui donne \\(26^5\\) possibilit\u00e9s (plus de 11 millions) pour le masque, et par cons\u00e9quent (propri\u00e9t\u00e9 de bijectivit\u00e9 du XOR) \\(26^5\\) possibilit\u00e9s pour le message \u00abd\u00e9chiffr\u00e9\u00bb... Cela signifie que Marc verra appara\u00eetre, dans sa tentative de d\u00e9chiffrage, les mots \"MARDI\", \"JEUDI\", \"JOUDI\", \"STYLO\", \"FSDJK\", \"LUNDI, \"LUNDA\"... Il n'a aucune possibilit\u00e9 de savoir o\u00f9 est le bon message original parmi toutes les propositions (on parle de s\u00e9curit\u00e9 s\u00e9mantique ). Principe de Kerckhoffs : la s\u00e9curit\u00e9 d'un syst\u00e8me de chiffrement ne doit reposer que sur la s\u00e9curit\u00e9 de la cl\u00e9, et non pas sur la connaissance de l'algorithme de chiffrement. Cet algorithme peut m\u00eame \u00eatre public (ce qui est pratiquement toujours le cas). Quels sont les chiffrements sym\u00e9triques modernes ? \u2693\ufe0e L'algorithme de chiffrement sym\u00e9trique le plus utilis\u00e9 actuellement est le chiffrement AES , pour Advanced Encryption Standard. chiffrement par bloc de 128 bits, r\u00e9partis dans une matrice de 16 octets (matrice carr\u00e9e de taille 4). ces 128 bits sont transform\u00e9s par des rotations, multiplications, transpositions, [...] de la matrice initiale, en faisant intervenir dans ces transformations une cl\u00e9 de 128, 192 ou 256 bits. pour l'AES-256 (avec une cl\u00e9 de 256 bits), l'attaque par force brute n\u00e9cessiterait 2^256 op\u00e9rations, soit un nombre \u00e0 78 chiffres... il n'existe pas d'attaque connue efficace \u00e0 ce jour. Les seules attaques sont des attaques sur des faiblesses d'impl\u00e9mentation, ou par canal auxiliaire . 2. Chiffrement asym\u00e9trique \u2693\ufe0e Invent\u00e9 par Whitfield Diffie et Martin Hellman en 1976, le chiffrement asym\u00e9trique vient r\u00e9soudre l'inconv\u00e9nient essentiel du chiffrement sym\u00e9trique : le n\u00e9cessaire partage d'un secret (la cl\u00e9) avant l'\u00e9tablissement de la communication s\u00e9curis\u00e9e. 2.1 Principe du chiffrement asym\u00e9trique \u2693\ufe0e Le principe de base est l'existence d'une cl\u00e9 publique , appel\u00e9e \u00e0 \u00eatre distribu\u00e9e largement, et d'une cl\u00e9 priv\u00e9e , qui ne quitte jamais son propri\u00e9taire. 2.2 Le r\u00f4le interchangeable des cl\u00e9s publiques et priv\u00e9es \u2693\ufe0e L'illustration pr\u00e9c\u00e9dente associe : une image de cadenas \u00e0 la cl\u00e9 publique (car on s'en sert pour chiffrer les messages) une image de cl\u00e9 \u00e0 la cl\u00e9 priv\u00e9e (car on s'en sert pour d\u00e9chiffrer les messages) Concr\u00e8tement, (nous le verrons dans l'application par le chiffrement RSA), la cl\u00e9 priv\u00e9e et la cl\u00e9 publique sont deux nombres aux r\u00f4les identiques. Appelons-les A et B : il est impossible de trouver A en fonction de B. R\u00e9ciproquement, si on conna\u00eet A, il est impossible d'en d\u00e9duire B. si on chiffre un message avec A, on peut le d\u00e9chiffrer avec B. R\u00e9ciproquement, si on chiffre avec B, on peut d\u00e9chiffrer le message gr\u00e2ce \u00e0 A. on peut donc chiffrer avec une cl\u00e9 publique et d\u00e9chiffrer avec la cl\u00e9 priv\u00e9e associ\u00e9e (ce qui est fait dans l'exemple pr\u00e9c\u00e9dent). Mais on peut aussi chiffrer avec la cl\u00e9 priv\u00e9e, et d\u00e9chiffrer avec la cl\u00e9 publique associ\u00e9e. A et B ont donc des r\u00f4les interchangeables (chacun peut \u00eatre un cadenas, chacun peut \u00eatre une cl\u00e9), et ce n'est qu'en connaissant A et B qu'on peut d\u00e9chiffrer le message. Nous allons donc maintenant adopter une nouvelle convention infographique : Consid\u00e9rons ce message : Si ce message est chiffr\u00e9 avec la cl\u00e9 publique d'Alice, le message sera : Si on d\u00e9chiffre ce message avec la cl\u00e9 priv\u00e9e d'Alice, il deviendra et donc puisque l'application de la cl\u00e9 priv\u00e9e sur la cl\u00e9 publique, ou bien de la cl\u00e9 publique sur la cl\u00e9 priv\u00e9e, permet de retrouver le message en clair. De mani\u00e8re graphique, la connaissance des deux moiti\u00e9s du disque qui s'assemblent permet de les faire disparaitre, peu importe qu'on ait commenc\u00e9 par chiffrer avec la cl\u00e9 publique ou avec la cl\u00e9 priv\u00e9e. 2.3 Communication authentifi\u00e9e. \u2693\ufe0e Dans la situation du 2.1, Alice (qui a distribu\u00e9 largement sa cl\u00e9 publique) ne peut pas s'assurer que le message vient bien de Bob. Il peut avoir \u00e9t\u00e9 cr\u00e9\u00e9 par Marc, qui signe \u00abBob\u00bb et usurpe ainsi son identit\u00e9. Le protocole que nous allons d\u00e9crire ci-dessous permet : d'emp\u00eacher qu'un message intercept\u00e9 soit d\u00e9chiffr\u00e9 (ce qui \u00e9tait d\u00e9j\u00e0 le cas dans le 2.1) mais aussi de s'assurer que chaque personne est bien celle qu'elle pr\u00e9tend \u00eatre : on r\u00e9sout le probl\u00e8me d'authentification . En r\u00e9sum\u00e9 : Alice est s\u00fbre que seul Bob pourra d\u00e9chiffrer le message qu'elle envoie. Bob est s\u00fbr que le message qu'il re\u00e7oit vient bien d'Alice. 2.3 Un exemple de chiffrement asym\u00e9trique : le chiffrement RSA \u2693\ufe0e 2.3.1 Histoire \u2693\ufe0e Lorsqu'en 1976 Diffie et Hellman (chercheurs \u00e0 Stanford) pr\u00e9sentent le concept de chiffrement asym\u00e9trique (souvent appel\u00e9 cryptographie \u00e0 cl\u00e9s publiques ), ils en proposent uniquement un mod\u00e8le th\u00e9orique, n'ayant pas trouv\u00e9 une r\u00e9elle impl\u00e9mentation de leur protocole. Trois chercheurs du MIT (Boston), Ron Rivest, Adi Shamir et Len Adleman se penchent alors sur ce protocole, convaincus qu'il est en effet impossible d'en trouver une impl\u00e9mentation pratique. En 1977, au cours de leurs recherches, ils d\u00e9montrent en fait l'inverse de ce qu'ils cherchaient : ils cr\u00e9ent le premier protocole concret de chiffrement asym\u00e9trique : le chiffrement RSA . Au m\u00eame moment \u00e0 Londres, Clifford Cocks, (chercheur au tr\u00e8s secret GCHQ ) apprend que Rivest Shamir et Adleman viennent de d\u00e9couvrir ce que lui-m\u00eame a d\u00e9couvert 3 ans auparavant mais qui est rest\u00e9 class\u00e9 Secret D\u00e9fense. Il est le v\u00e9ritable inventeur du RSA... mais le reste du monde ne l'apprendra qu'en 1997 au moment de la d\u00e9classification de cette information. 2.3.1 Description \u2693\ufe0e Le chiffrement RSA est bas\u00e9 sur l'arithm\u00e9tique modulaire . Faire des calculs modulo un entier \\(n\\) , c'est ne garder que le reste de la division euclidienne par \\(n\\) . Le fait que 15 soit \u00e9gal \u00e0 1 modulo 7 (car \\(15=2 \\times 7+1\\) ) s'\u00e9crira \\(15 \\equiv 1 [7]\\) . De m\u00eame, \\(10 \\equiv 3 [7]\\) , \\(25 \\equiv 4 [7]\\) , \\(32 \\equiv 2 [10]\\) , etc. \u00c9tape 1 \u2693\ufe0e Alice choisit 2 grands nombres premiers \\(p\\) et \\(q\\) . Dans la r\u00e9alit\u00e9 ces nombres seront vraiment tr\u00e8s grands (plus de 100 chiffres). Dans notre exemple, nous prendrons \\(p = 3\\) et \\(q = 11\\) . \u00c9tape 2 \u2693\ufe0e Alice multiplie ces deux nombres \\(p\\) et \\(q\\) et obtient ainsi un nombre \\(n\\) . Il est tr\u00e8s facile pour Alice de calculer \\(n\\) en connaissant \\(p\\) et \\(q\\) , mais il extr\u00eamement difficile pour Marc de faire le travail inverse : trouver \\(p\\) et \\(q\\) en connaissant \\(n\\) prend un temps exponentiel avec la taille de \\(n\\) . C'est sur cette difficult\u00e9 (appel\u00e9e difficult\u00e9 de factorisation ) que repose la robustesse du syst\u00e8me RSA. \u00c9tape 3 \u2693\ufe0e Alice choisit un nombre \\(e\\) qui doit \u00eatre premier avec \\((p-1)(q-1)\\) . On note \\(\\phi(n)\\) le nombre \\((p-1)(q-1)\\) . Dans notre exemple, \\((p-1)(q-1) = 20\\) , Alice choisit donc \\(e = 3\\) . (mais elle aurait pu aussi choisir 7, 9, 13...). Le couple \\((e, n)\\) sera la cl\u00e9 publique d'Alice. Elle la diffuse \u00e0 qui veut lui \u00e9crire. Dans notre exemple, la cl\u00e9 publique d'Alice est \\((3, 33)\\) . \u00c9tape 4 \u2693\ufe0e Alice calcule maintenant sa cl\u00e9 priv\u00e9e : elle doit trouver un nombre d qui v\u00e9rifie l'\u00e9galit\u00e9 \\(e d \\equiv 1 [\\phi(n)]\\) . Dans notre exemple, comme \\(7 \\times 3 \\equiv 1 [20]\\) , ce nombre \\(d\\) est \u00e9gal \u00e0 7. En pratique, il existe un algorithme simple (algorithme d' Euclide \u00e9tendu ) pour trouver cette valeur \\(d\\) , appel\u00e9e inverse de e . Le couple \\((d, n)\\) sera la cl\u00e9 priv\u00e9e d'Alice. Elle ne la diffuse \u00e0 personne. Dans notre exemple, la cl\u00e9 priv\u00e9e d'Alice est \\((7, 33)\\) . \u00c9tape 5 \u2693\ufe0e Supposons que Bob veuille \u00e9crire \u00e0 Alice pour lui envoyer le nombre 4. Il poss\u00e8de la cl\u00e9 publique d'Alice, qui est \\((3, 33)\\) . Il calcule donc \\(4^3\\) modulo 33, qui vaut 31. C'est cette valeur 31 qu'il transmet \u00e0 Alice. \\[4^3 \\equiv 31 [33]\\] Si Marc intercepte cette valeur 31, m\u00eame en connaissant la cl\u00e9 publique d'Alice (3,33), il ne peut pas r\u00e9soudre l'\u00e9quation \\(x^3 \\equiv 31 [33]\\) de mani\u00e8re efficace. \u00c9tape 6 \u2693\ufe0e Alice re\u00e7oit la valeur 31. Il lui suffit alors d'\u00e9lever 31 \u00e0 la puissance 7 (sa cl\u00e9 priv\u00e9e), et de calculer le reste modulo 33 : \\(31^7 = 27512614111\\) \\(27512614111 \\equiv 4 [33]\\) Elle r\u00e9cup\u00e8re la valeur 4, qui est bien le message original de Bob. Comment \u00e7a marche ? Gr\u00e2ce au Petit Th\u00e9or\u00e8me de Fermat , on d\u00e9montre (voir ici ) assez facilement que \\(M^{ed} \\equiv M [n]\\) . Il faut remarquer que \\(M^{ed} = M^{de}\\) . On voit que les r\u00f4les de la cl\u00e9 publique et de la cl\u00e9 priv\u00e9e sont sym\u00e9triques : un message chiffr\u00e9 avec la cl\u00e9 publique se d\u00e9chiffrera en le chiffrant avec la cl\u00e9 priv\u00e9e, tout comme un message chiffr\u00e9 avec la cl\u00e9 priv\u00e9e se d\u00e9chiffrera en le chiffrant avec la cl\u00e9 publique. Animation interactive voir https://animations.interstices.info/interstices-rsa/rsa.html RSA, un syst\u00e8me inviolable ? \u2693\ufe0e Le chiffrement RSA a des d\u00e9fauts (notamment une grande consommation des ressources, due \u00e0 la manipulation de tr\u00e8s grands nombres). Mais le choix d'une cl\u00e9 publique de grande taille (actuellement 1024 ou 2048 bits) le rend pour l'instant inviolable. Actuellement, il n'existe pas d'algorithme efficace pour factoriser un nombre ayant plusieurs centaines de chiffres. Deux \u00e9v\u00e8nements pourraient faire s'\u00e9crouler la s\u00e9curit\u00e9 du RSA : la d\u00e9couverte d'un algorithme efficace de factorisation, capable de tourner sur les ordinateurs actuels. Cette annonce est r\u00e9guli\u00e8rement faite, et tout aussi r\u00e9guli\u00e8rement contredite par la communaut\u00e9 scientifique. (voir, le 05/03/2021, https://www.schneier.com/blog/archives/2021/03/no-rsa-is-not-broken.html ) l'av\u00e8nement d' ordinateurs quantiques , dont la vitesse d'ex\u00e9cution permettrait une factorisation rapide. Il est \u00e0 noter que l'algorithme de factorisation destin\u00e9 \u00e0 tourner sur un ordinateur quantique existe d\u00e9j\u00e0 : l'algorithme de Schor . 3. HTTPS : exemple d'utilisation conjointe d'un chiffrement asym\u00e9trique et d'un chiffrement sym\u00e9trique. \u2693\ufe0e 3.1 Principe g\u00e9n\u00e9ral \u2693\ufe0e Aujourd'hui, plus de 90 % du trafic sur internet est chiffr\u00e9 : les donn\u00e9es ne transitent plus en clair (protocole http ) mais de mani\u00e8re chiffr\u00e9e (protocole https ), ce qui emp\u00eache la lecture de paquets \u00e9ventuellements intercept\u00e9s. Le protocole https est la r\u00e9union de deux protocoles : le protocole TLS (Transport Layer Security, qui a succ\u00e9d\u00e9 au SSL) : ce protocole, bas\u00e9 sur du chiffrement asym\u00e9trique , va conduire \u00e0 la g\u00e9n\u00e9ration d'une cl\u00e9 identique chez le client et chez le serveur. le (bon vieux) protocole http , mais qui convoiera maintenant des donn\u00e9es chiffr\u00e9es avec la cl\u00e9 g\u00e9n\u00e9r\u00e9e \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente. Les donn\u00e9es peuvent toujours \u00eatre intercept\u00e9es, mais sont illisibles. Le chiffrement sym\u00e9trique utilis\u00e9 est actuellement le chiffrement AES. Pourquoi ne pas utiliser que le chiffrement asym\u00e9trique, RSA par exemple ? Car il est tr\u00e8s gourmand en ressources ! Le chiffrement/d\u00e9chiffrement doit \u00eatre rapide pour ne pas ralentir les communications ou l'exploitation des donn\u00e9es. Le chiffrement asym\u00e9trique est donc r\u00e9serv\u00e9 \u00e0 l'\u00e9change de cl\u00e9s (au d\u00e9but de la communication). Le chiffrement sym\u00e9trique, bien plus rapide, prend ensuite le relais pour l'ensemble de la communication. 3.2 (HP) Fonctionnement du TLS : explication du handshake \u2693\ufe0e Observons en d\u00e9tail le fonctionnement du protocole TLS , dont le r\u00f4le est de g\u00e9n\u00e9rer de mani\u00e8re s\u00e9curis\u00e9e une cl\u00e9 dont disposeront \u00e0 la fois le client et le serveur, leur permettant ainsi d'appliquer un chiffrement sym\u00e9trique \u00e0 leurs \u00e9changes. \u00e9tape 1 : le \u00abclient Hello\u00bb. Le client envoie sa version de TLS utilis\u00e9e. \u00e9tape 2 : le \u00abserver Hello\u00bb. Le serveur r\u00e9pond en renvoyant son certificat prouvant son identit\u00e9, ainsi que sa cl\u00e9 publique. \u00e9tape 3 : le client interroge l'autorit\u00e9 de certification pour valider le fait que le certificat est bien valide et que le serveur est bien celui qu'il pr\u00e9tend \u00eatre. Cette v\u00e9rification est faite gr\u00e2ce \u00e0 un m\u00e9canisme de chiffrement asym\u00e9trique. La pr\u00e9sentation du certificat \u00e0 l'autorit\u00e9 de certification peut se repr\u00e9senter comme le scan d'une pi\u00e8ce d'identit\u00e9 dans un a\u00e9roport. L'autorit\u00e9 de certification est alors l'\u00c9tat (dont la base de donn\u00e9es est interrog\u00e9e par un logiciel) qui valide que la pi\u00e8ce d'identit\u00e9 est bien un document officiel. \u00e9tape 4 : une fois v\u00e9rifi\u00e9e l'authenticit\u00e9 du serveur et que son certificat est valide, le client calcule ce qui sera la future cl\u00e9 de chiffrement sym\u00e9trique (appel\u00e9e \u00abcl\u00e9 AES\u00bb dans l'infographie). Cette cl\u00e9 est chiffr\u00e9e avec la cl\u00e9 publique du server (transmise \u00e0 l'\u00e9tape 1), ce qui assure la s\u00e9curit\u00e9 de son transfert. Le serveur d\u00e9chiffre cette cl\u00e9 gr\u00e2ce \u00e0 sa cl\u00e9 priv\u00e9e, et dispose ainsi lui aussi de la cl\u00e9. Le transmission par protocole http de donn\u00e9es chiffr\u00e9es au pr\u00e9alable avec la cl\u00e9 AES peut commencer. Remarque : en r\u00e9alit\u00e9, ce n'est pas la cl\u00e9 AES qui est transmise \u00e0 l'\u00e9tape 4, mais un nombre choisi par le client, qui permettra, avec deux autres nombres choisis par le client (\u00e9tape 1) et le serveur (\u00e9tape 2) de reconstituer la cl\u00e9 AES, qui sera donc identique c\u00f4t\u00e9 client et c\u00f4t\u00e9 serveur. Sources Page tir\u00e9e de : https://glassus.github.io/terminale_nsi/T5_Architecture_materielle/5.4_Cryptographie/cours/ Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://www.cloudflare.com/fr-fr/learning/ssl/what-happens-in-a-tls-handshake/","title":"CH9 Cryptographie - S\u00e9curisation des communications"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#ch9-cryptographie","text":"Programme officiel","title":"CH9 : Cryptographie"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#1-chiffrement-symetrique","text":"","title":"1. Chiffrement sym\u00e9trique"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#11-activite-du-masque-jetable","text":"Exercice \u00c9nonc\u00e9 Aide Correction On consid\u00e8re la variable suivante : masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" Cr\u00e9er une fonction chiffre(message, masque) qui chiffre message en le XORant avec masque . Cette fonction doit pouvoir aussi servir \u00e0 d\u00e9chiffrer le message chiffr\u00e9. Le XOR (voir ici ) est une op\u00e9ration sym\u00e9trique : >>> 34 ^ 23 53 >>> 53 ^ 23 34 La fonction ord permet de renvoyer le code ASCII d'un caract\u00e8re. La fonction chr fait l'op\u00e9ration inverse. >>> ord ( 'A' ) 65 >>> chr ( 65 ) 'A' 1 2 3 4 5 6 7 8 masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" def chiffre ( message , masque ): message_chiffre = \"\" for i in range ( len ( message )): lettre_chiffree = chr ( ord ( message [ i ]) ^ ord ( masque [ i ])) message_chiffre += lettre_chiffree return message_chiffre","title":"1.1 Activit\u00e9 du masque jetable"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#12-principe-du-chiffrement-symetrique","text":"Dans un chiffrement sym\u00e9trique, c'est la m\u00eame cl\u00e9 qui va servir au chiffrement et au d\u00e9chiffrement.","title":"1.2 Principe du chiffrement sym\u00e9trique"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#2-chiffrement-asymetrique","text":"Invent\u00e9 par Whitfield Diffie et Martin Hellman en 1976, le chiffrement asym\u00e9trique vient r\u00e9soudre l'inconv\u00e9nient essentiel du chiffrement sym\u00e9trique : le n\u00e9cessaire partage d'un secret (la cl\u00e9) avant l'\u00e9tablissement de la communication s\u00e9curis\u00e9e.","title":"2. Chiffrement asym\u00e9trique"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#21-principe-du-chiffrement-asymetrique","text":"Le principe de base est l'existence d'une cl\u00e9 publique , appel\u00e9e \u00e0 \u00eatre distribu\u00e9e largement, et d'une cl\u00e9 priv\u00e9e , qui ne quitte jamais son propri\u00e9taire.","title":"2.1 Principe du chiffrement asym\u00e9trique"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#22-le-role-interchangeable-des-cles-publiques-et-privees","text":"L'illustration pr\u00e9c\u00e9dente associe : une image de cadenas \u00e0 la cl\u00e9 publique (car on s'en sert pour chiffrer les messages) une image de cl\u00e9 \u00e0 la cl\u00e9 priv\u00e9e (car on s'en sert pour d\u00e9chiffrer les messages) Concr\u00e8tement, (nous le verrons dans l'application par le chiffrement RSA), la cl\u00e9 priv\u00e9e et la cl\u00e9 publique sont deux nombres aux r\u00f4les identiques. Appelons-les A et B : il est impossible de trouver A en fonction de B. R\u00e9ciproquement, si on conna\u00eet A, il est impossible d'en d\u00e9duire B. si on chiffre un message avec A, on peut le d\u00e9chiffrer avec B. R\u00e9ciproquement, si on chiffre avec B, on peut d\u00e9chiffrer le message gr\u00e2ce \u00e0 A. on peut donc chiffrer avec une cl\u00e9 publique et d\u00e9chiffrer avec la cl\u00e9 priv\u00e9e associ\u00e9e (ce qui est fait dans l'exemple pr\u00e9c\u00e9dent). Mais on peut aussi chiffrer avec la cl\u00e9 priv\u00e9e, et d\u00e9chiffrer avec la cl\u00e9 publique associ\u00e9e. A et B ont donc des r\u00f4les interchangeables (chacun peut \u00eatre un cadenas, chacun peut \u00eatre une cl\u00e9), et ce n'est qu'en connaissant A et B qu'on peut d\u00e9chiffrer le message. Nous allons donc maintenant adopter une nouvelle convention infographique : Consid\u00e9rons ce message : Si ce message est chiffr\u00e9 avec la cl\u00e9 publique d'Alice, le message sera : Si on d\u00e9chiffre ce message avec la cl\u00e9 priv\u00e9e d'Alice, il deviendra et donc puisque l'application de la cl\u00e9 priv\u00e9e sur la cl\u00e9 publique, ou bien de la cl\u00e9 publique sur la cl\u00e9 priv\u00e9e, permet de retrouver le message en clair. De mani\u00e8re graphique, la connaissance des deux moiti\u00e9s du disque qui s'assemblent permet de les faire disparaitre, peu importe qu'on ait commenc\u00e9 par chiffrer avec la cl\u00e9 publique ou avec la cl\u00e9 priv\u00e9e.","title":"2.2 Le r\u00f4le interchangeable des cl\u00e9s publiques et priv\u00e9es"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#23-communication-authentifiee","text":"Dans la situation du 2.1, Alice (qui a distribu\u00e9 largement sa cl\u00e9 publique) ne peut pas s'assurer que le message vient bien de Bob. Il peut avoir \u00e9t\u00e9 cr\u00e9\u00e9 par Marc, qui signe \u00abBob\u00bb et usurpe ainsi son identit\u00e9. Le protocole que nous allons d\u00e9crire ci-dessous permet : d'emp\u00eacher qu'un message intercept\u00e9 soit d\u00e9chiffr\u00e9 (ce qui \u00e9tait d\u00e9j\u00e0 le cas dans le 2.1) mais aussi de s'assurer que chaque personne est bien celle qu'elle pr\u00e9tend \u00eatre : on r\u00e9sout le probl\u00e8me d'authentification . En r\u00e9sum\u00e9 : Alice est s\u00fbre que seul Bob pourra d\u00e9chiffrer le message qu'elle envoie. Bob est s\u00fbr que le message qu'il re\u00e7oit vient bien d'Alice.","title":"2.3 Communication authentifi\u00e9e."},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#23-un-exemple-de-chiffrement-asymetrique-le-chiffrement-rsa","text":"","title":"2.3 Un exemple de chiffrement asym\u00e9trique : le chiffrement RSA"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#3-https-exemple-dutilisation-conjointe-dun-chiffrement-asymetrique-et-dun-chiffrement-symetrique","text":"","title":"3. HTTPS : exemple d'utilisation conjointe d'un chiffrement asym\u00e9trique et d'un chiffrement sym\u00e9trique."},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#31-principe-general","text":"Aujourd'hui, plus de 90 % du trafic sur internet est chiffr\u00e9 : les donn\u00e9es ne transitent plus en clair (protocole http ) mais de mani\u00e8re chiffr\u00e9e (protocole https ), ce qui emp\u00eache la lecture de paquets \u00e9ventuellements intercept\u00e9s. Le protocole https est la r\u00e9union de deux protocoles : le protocole TLS (Transport Layer Security, qui a succ\u00e9d\u00e9 au SSL) : ce protocole, bas\u00e9 sur du chiffrement asym\u00e9trique , va conduire \u00e0 la g\u00e9n\u00e9ration d'une cl\u00e9 identique chez le client et chez le serveur. le (bon vieux) protocole http , mais qui convoiera maintenant des donn\u00e9es chiffr\u00e9es avec la cl\u00e9 g\u00e9n\u00e9r\u00e9e \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente. Les donn\u00e9es peuvent toujours \u00eatre intercept\u00e9es, mais sont illisibles. Le chiffrement sym\u00e9trique utilis\u00e9 est actuellement le chiffrement AES. Pourquoi ne pas utiliser que le chiffrement asym\u00e9trique, RSA par exemple ? Car il est tr\u00e8s gourmand en ressources ! Le chiffrement/d\u00e9chiffrement doit \u00eatre rapide pour ne pas ralentir les communications ou l'exploitation des donn\u00e9es. Le chiffrement asym\u00e9trique est donc r\u00e9serv\u00e9 \u00e0 l'\u00e9change de cl\u00e9s (au d\u00e9but de la communication). Le chiffrement sym\u00e9trique, bien plus rapide, prend ensuite le relais pour l'ensemble de la communication.","title":"3.1 Principe g\u00e9n\u00e9ral"},{"location":"Architectures%20mat%C3%A9rielles%20-%20OS%20-%20R%C3%A9seaux/CH9_Cryptographie/cours/#32-hp-fonctionnement-du-tls-explication-du-handshake","text":"Observons en d\u00e9tail le fonctionnement du protocole TLS , dont le r\u00f4le est de g\u00e9n\u00e9rer de mani\u00e8re s\u00e9curis\u00e9e une cl\u00e9 dont disposeront \u00e0 la fois le client et le serveur, leur permettant ainsi d'appliquer un chiffrement sym\u00e9trique \u00e0 leurs \u00e9changes. \u00e9tape 1 : le \u00abclient Hello\u00bb. Le client envoie sa version de TLS utilis\u00e9e. \u00e9tape 2 : le \u00abserver Hello\u00bb. Le serveur r\u00e9pond en renvoyant son certificat prouvant son identit\u00e9, ainsi que sa cl\u00e9 publique. \u00e9tape 3 : le client interroge l'autorit\u00e9 de certification pour valider le fait que le certificat est bien valide et que le serveur est bien celui qu'il pr\u00e9tend \u00eatre. Cette v\u00e9rification est faite gr\u00e2ce \u00e0 un m\u00e9canisme de chiffrement asym\u00e9trique. La pr\u00e9sentation du certificat \u00e0 l'autorit\u00e9 de certification peut se repr\u00e9senter comme le scan d'une pi\u00e8ce d'identit\u00e9 dans un a\u00e9roport. L'autorit\u00e9 de certification est alors l'\u00c9tat (dont la base de donn\u00e9es est interrog\u00e9e par un logiciel) qui valide que la pi\u00e8ce d'identit\u00e9 est bien un document officiel. \u00e9tape 4 : une fois v\u00e9rifi\u00e9e l'authenticit\u00e9 du serveur et que son certificat est valide, le client calcule ce qui sera la future cl\u00e9 de chiffrement sym\u00e9trique (appel\u00e9e \u00abcl\u00e9 AES\u00bb dans l'infographie). Cette cl\u00e9 est chiffr\u00e9e avec la cl\u00e9 publique du server (transmise \u00e0 l'\u00e9tape 1), ce qui assure la s\u00e9curit\u00e9 de son transfert. Le serveur d\u00e9chiffre cette cl\u00e9 gr\u00e2ce \u00e0 sa cl\u00e9 priv\u00e9e, et dispose ainsi lui aussi de la cl\u00e9. Le transmission par protocole http de donn\u00e9es chiffr\u00e9es au pr\u00e9alable avec la cl\u00e9 AES peut commencer. Remarque : en r\u00e9alit\u00e9, ce n'est pas la cl\u00e9 AES qui est transmise \u00e0 l'\u00e9tape 4, mais un nombre choisi par le client, qui permettra, avec deux autres nombres choisis par le client (\u00e9tape 1) et le serveur (\u00e9tape 2) de reconstituer la cl\u00e9 AES, qui sera donc identique c\u00f4t\u00e9 client et c\u00f4t\u00e9 serveur. Sources Page tir\u00e9e de : https://glassus.github.io/terminale_nsi/T5_Architecture_materielle/5.4_Cryptographie/cours/ Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://www.cloudflare.com/fr-fr/learning/ssl/what-happens-in-a-tls-handshake/","title":"3.2 (HP) Fonctionnement du TLS : explication du handshake"},{"location":"Langages%20et%20programmation/sommaire/","text":"CH1 : Mise au point des programmes (BAC) CH2 : R\u00e9cursivit\u00e9 (BAC) CH11 : Modularit\u00e9 - API","title":"Sommaire"},{"location":"Langages%20et%20programmation/CH11_modularite/cours/","text":"CH11 : Modularit\u00e9 - API \u2693\ufe0e Programme officiel 1. Qu'est qu'une API ? \u2693\ufe0e Une API (en anglais \u00ab Application programming interface \u00bb) est une interface de programmation d\u2019application. Elle est destin\u00e9e \u00e0 \u00eatre utilis\u00e9e par des programmes. Le principe de ce type d\u2019interface est le m\u00eame que celui des UI (\u00ab User Interface \u00bb) ou des GUI (\u00ab Graphical User Interface \u00bb) destin\u00e9es elles \u00e0 un utilisateur humain. Compos\u00e9e de constantes, de fonctions, de classes, elle sert de lien entre un programme et les programmes qui vont l\u2019utiliser. Elle peut \u00eatre propos\u00e9e par un service web avec une documentation d\u00e9crivant l\u2019utilisation qui permettra la communication et l\u2019\u00e9change des donn\u00e9es. Il existe, par exemple, plusieurs API de g\u00e9olocalisation qui peuvent \u00eatre int\u00e9gr\u00e9es \u00e0 des programmes. Une API est tr\u00e8s souvent propos\u00e9e par une biblioth\u00e8que logicielle compos\u00e9e de fonctions destin\u00e9es \u00e0 \u00eatre utilis\u00e9es dans divers programmes. Le principe de base est que le fonctionnement interne n\u2019a pas besoin d\u2019\u00eatre connu du programme utilisateur. Cela n\u00e9cessite une documentation fournie d\u00e9crivant pr\u00e9cis\u00e9ment son l\u2019utilisation. Ainsi, lors de l\u2019\u00e9laboration d\u2019un logiciel il est possible d\u2019utiliser des parties d\u2019autres logiciels, sans conna\u00eetre leur fonctionnement interne, si l\u2019on sait comment faire interagir ces diff\u00e9rentes parties. Par exemple, pour utiliser une fonction il suffit de conna\u00eetre sa sp\u00e9cification, c\u2019est \u00e0 dire son nom, les types de ses param\u00e8tres et de la valeur qu\u2019elle retourne et sa documentation. Dans tous les cas, l\u2019utilisateur, un programme ou un humain, se contente de fournir les donn\u00e9es demand\u00e9es et obtient le r\u00e9sultat du traitement. On s'int\u00e9resse ici \u00e0 la Base Adresse Nationale qui est une API gratuite du gouvernement fran\u00e7ais permettant d'obtenir un certain nombre d'informations \u00e0 partir d'une adresse postale. 2. Interrogation de l'API \u2693\ufe0e On souhaite, gr\u00e2ce \u00e0 l'API, obtenir des informations sur l'adresse postale de l'institution Ste Marie. Pour interroger l'API, il suffit d'envoyer une requ\u00eate GET \u00e0 l'URL https://api-adresse.data.gouv.fr/search/?q=54-rue-de-l-eglise&postcode=59134 . On remarque que l'adresse postale sur laquelle on souhaite interroger l'API est indiqu\u00e9e dans l'URL. La r\u00e9ponse renvoy\u00e9e par l'API est la suivante : { \"type\" : \"FeatureCollection\" , \"version\" : \"draft\" , \"features\" : [{ \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.919014 , 50.603896 ]}, \"properties\" : { \"label\" : \"Rue de l\\u2019Eglise 59134 Beaucamps-Ligny\" , \"score\" : 0.7158977005347593 , \"id\" : \"59056_0060\" , \"name\" : \"Rue de l\\u2019Eglise\" , \"postcode\" : \"59134\" , \"citycode\" : \"59056\" , \"x\" : 694257.21 , \"y\" : 7056318.52 , \"city\" : \"Beaucamps-Ligny\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.46311 }}, { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.864853 , 50.571784 ]}, \"properties\" : { \"label\" : \"Rue de l\\u2019Eglise 59134 Wicres\" , \"score\" : 0.712733155080214 , \"id\" : \"59658_0020\" , \"name\" : \"Rue de l\\u2019Eglise\" , \"postcode\" : \"59134\" , \"citycode\" : \"59658\" , \"x\" : 690410.49 , \"y\" : 7052745.79 , \"city\" : \"Wicres\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.4283 }}, { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.884764 , 50.614966 ]}, \"properties\" : { \"label\" : \"Rue de l\\u2019Eglise 59134 Le Maisnil\" , \"score\" : 0.7101831550802139 , \"id\" : \"59371_0060\" , \"name\" : \"Rue de l\\u2019Eglise\" , \"postcode\" : \"59134\" , \"citycode\" : \"59371\" , \"x\" : 691830.32 , \"y\" : 7057555.01 , \"city\" : \"Le Maisnil\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.40025 }}, { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.86755 , 50.570217 ]}, \"properties\" : { \"label\" : \"Rue de l\\u2019Eglise et Bas Champ 59134 Wicres\" , \"score\" : 0.41261 , \"id\" : \"59658_gy8iak\" , \"name\" : \"Rue de l\\u2019Eglise et Bas Champ\" , \"postcode\" : \"59134\" , \"citycode\" : \"59658\" , \"x\" : 690601.57 , \"y\" : 7052570.87 , \"city\" : \"Wicres\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.33871 }}, { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.86596 , 50.572264 ]}, \"properties\" : { \"label\" : \"Chemin Pieton Rues (l\\u2019Eglise - Viguier) 59134 Wicres\" , \"score\" : 0.2762463636363636 , \"id\" : \"59658_k3ui6a\" , \"name\" : \"Chemin Pieton Rues (l\\u2019Eglise - Viguier)\" , \"postcode\" : \"59134\" , \"citycode\" : \"59658\" , \"x\" : 690489.13 , \"y\" : 7052799.13 , \"city\" : \"Wicres\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.33871 }}], \"attribution\" : \"BAN\" , \"licence\" : \"ETALAB-2.0\" , \"query\" : \"54-rue-de-l-eglise\" , \"filters\" : { \"postcode\" : \"59134\" }, \"limit\" : 5 } La r\u00e9ponse re\u00e7ue est au format JSON (JavaScript Object Notation). La signification des champs de la r\u00e9ponse est donn\u00e9e dans la documentation de l'API. L'interrogation de l'API peut \u00eatre r\u00e9alis\u00e9e gr\u00e2ce au code Python ci-dessous. Lors de son ex\u00e9cution, la r\u00e9ponse renvoy\u00e9e par l'API est stock\u00e9e dans la variable reponse. 1 2 3 4 import requests url = \"https://api-adresse.data.gouv.fr/search/?q=54-rue-de-l-eglise&postcode=59134\" reponse = requests . get ( url ) reponse = reponse . json () - La fonction get du module requests permet d'envoyer une requ\u00eate GET \u00e0 l'URL sp\u00e9cifi\u00e9e et ensuite de r\u00e9cup\u00e9rer la r\u00e9ponse. - La commande reponse.json() extrait de la r\u00e9ponse les donn\u00e9es encod\u00e9es dans le format JSON, qui est un format de donn\u00e9es textuelles que l'on peut traiter comme s'il s'agissait d'un dictionnaire Python. 3. Traitement de la r\u00e9ponse renvoy\u00e9e par l'API \u2693\ufe0e Il est possible de d\u00e9finir une fonction qui interroge l'API \u00e0 partir d'une adresse postale au choix, pass\u00e9e en param\u00e8tre. Premi\u00e8re fa\u00e7on : r\u00e9cup\u00e9rer l'ensemble des donn\u00e9es La fonction interroger_API_BAN prend en arguments adresse (une cha\u00eene de caract\u00e8res) et code_postal (entier ou cha\u00eene de caract\u00e8res) et renvoie reponse qui est un dictionnaire contenant toutes les donn\u00e9es renvoy\u00e9es par l'API. 1 2 3 4 5 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () return reponse Remarques : Penser \u00e0 importer le module requests ! L'utilisation d'une f-string pour l'\u00e9criture de l'URL permet d'y int\u00e9grer simplement et lisiblement les param\u00e8tres d'entr\u00e9e de la fonction. Et ici, la fonction renvoie l'ensemble des donn\u00e9es r\u00e9cup\u00e9r\u00e9es via l'API. La plupart du temps, on souhaite n\u00e9anmoins isoler les donn\u00e9es qui nous int\u00e9ressent et elles seules. Deuxi\u00e8me fa\u00e7on : renvoyer uniquement des donn\u00e9es qui nous int\u00e9ressent La fonction interroger_API_BAN prend toujours en arguments adresse (une cha\u00eene de caract\u00e8res) et code_postal (entier ou cha\u00eene de caract\u00e8res) et renvoie un couple (lat, long) (tuple) des coordonn\u00e9es g\u00e9ographiques. 1 2 3 4 5 6 7 8 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () coord = reponse [ 'features' ][ 0 ][ 'geometry' ][ 'coordinates' ] long = coord [ 0 ] lat = coord [ 1 ] return ( lat , long ) Remarques : Une fois la r\u00e9ponse de l'API transform\u00e9e en dictionnaire, il suffit de naviguer pour r\u00e9cup\u00e9rer les donn\u00e9es qui nous int\u00e9ressent, comme par exemple les coordonn\u00e9es g\u00e9ographiques de l'adresse pass\u00e9e en param\u00e8tre. reponse est un dictionnaire poss\u00e9dant huit cl\u00e9s : 'type' , 'version' , 'features' , 'attribution' , 'licence' , 'query' , 'filters' et 'limit' . reponse['features'] est un tableau contenant un ou plusieurs \u00e9l\u00e9ments de type dictionnaire : chaque dictionnaire correspond \u00e0 une adresse potentielle, la premi\u00e8re (indice 0) \u00e9tant la plus susceptible de correspondre \u00e0 notre demande. reponse['features'][0] est un dictionnaire poss\u00e9dant trois cl\u00e9s : 'type' , 'geometry' et 'properties' . reponse['features'][0]['geometry'] est un dictionnaire poss\u00e9dant deux cl\u00e9s : 'type' et 'coordinates' . reponse['features'][0]['geometry']['coordinates'] est un tableau contenant deux \u00e9l\u00e9ments de type flottant : la longitude (indice 0 ) et la latitude (indice 1 ) du lieu. Ce que vous savez maintenant Envoyer une requ\u00eate \u00e0 une API avec le module requests . S\u00e9lectionner des informations dans la r\u00e9ponse renvoy\u00e9e par une API. Consulter la documentation d'une API. 4. \u00c0 vous de faire \u2693\ufe0e 4.1 Ast\u00e9ro\u00efdes \u00e0 surveiller \u2693\ufe0e Near Earth Object Web Service ( NEOWS ) est une API par l'interm\u00e9diaire de laquelle la NASA met \u00e0 disposition des donn\u00e9es sur les ast\u00e9ro\u00efdes passant \u00e0 proximit\u00e9 de la Terre. Contrairement \u00e0 l'API Base Adresse Nationale , l'utilisation de cette API n\u00e9cessite de disposer d'une cl\u00e9 d'API , qui permet d'identifier le programme consommateur et \u00e9ventuellement de limiter le nombre de requ\u00eates autoris\u00e9es. La cl\u00e9 de d\u00e9monstration DEMO_KEY est fournie par la NASA pour tester l'API. Le nombre de requ\u00eates est n\u00e9anmoins limit\u00e9 \u00e0 30 par heure et par adresse IP et \u00e0 50 par jour et par adresse IP. Vous pouvez vous inscrire ici pour obtenir une cl\u00e9 gratuite personnelle. Notebook : ex_asteroides.ipynb 4.2 Bulletin m\u00e9t\u00e9o \u2693\ufe0e L'API OpenWeatherMap permet de r\u00e9cup\u00e9rer les donn\u00e9es m\u00e9t\u00e9orologiques d'un lieu donn\u00e9. Contrairement \u00e0 l'API Base Adresse Nationale, l'utilisation de cette API n\u00e9cessite de disposer d'une cl\u00e9 d'API , qui permet d'identifier le programme consommateur et \u00e9ventuellement de limiter le nombre de requ\u00eates autoris\u00e9es. Vous pouvez vous inscrire ici pour obtenir une cl\u00e9 gratuite personnelle. Notebook : ex_bulletin_meteo.ipynb 4.3 Composition de produits alimentaires \u2693\ufe0e L'API Open Food Facts permet de r\u00e9cup\u00e9rer des informations sur un produit alimentaire \u00e0 partir de son num\u00e9ro de code-barres. Par exemple, pour le produit dont le code-barres est 8076800376999, il suffit d'envoyer une requ\u00eate GET \u00e0 l'URL https://world.openfoodfacts.org/api/v0/product/8076800376999.json . Notebook : ex_openfoodfacts.ipynb Sources https://ntoulzac.github.io/Cours-NSI-Terminale/api/ Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER.","title":"CH11 Modularit\u00e9 - API"},{"location":"Langages%20et%20programmation/CH11_modularite/cours/#ch11-modularite-api","text":"Programme officiel","title":"CH11 : Modularit\u00e9 - API"},{"location":"Langages%20et%20programmation/CH11_modularite/cours/#1-quest-quune-api","text":"Une API (en anglais \u00ab Application programming interface \u00bb) est une interface de programmation d\u2019application. Elle est destin\u00e9e \u00e0 \u00eatre utilis\u00e9e par des programmes. Le principe de ce type d\u2019interface est le m\u00eame que celui des UI (\u00ab User Interface \u00bb) ou des GUI (\u00ab Graphical User Interface \u00bb) destin\u00e9es elles \u00e0 un utilisateur humain. Compos\u00e9e de constantes, de fonctions, de classes, elle sert de lien entre un programme et les programmes qui vont l\u2019utiliser. Elle peut \u00eatre propos\u00e9e par un service web avec une documentation d\u00e9crivant l\u2019utilisation qui permettra la communication et l\u2019\u00e9change des donn\u00e9es. Il existe, par exemple, plusieurs API de g\u00e9olocalisation qui peuvent \u00eatre int\u00e9gr\u00e9es \u00e0 des programmes. Une API est tr\u00e8s souvent propos\u00e9e par une biblioth\u00e8que logicielle compos\u00e9e de fonctions destin\u00e9es \u00e0 \u00eatre utilis\u00e9es dans divers programmes. Le principe de base est que le fonctionnement interne n\u2019a pas besoin d\u2019\u00eatre connu du programme utilisateur. Cela n\u00e9cessite une documentation fournie d\u00e9crivant pr\u00e9cis\u00e9ment son l\u2019utilisation. Ainsi, lors de l\u2019\u00e9laboration d\u2019un logiciel il est possible d\u2019utiliser des parties d\u2019autres logiciels, sans conna\u00eetre leur fonctionnement interne, si l\u2019on sait comment faire interagir ces diff\u00e9rentes parties. Par exemple, pour utiliser une fonction il suffit de conna\u00eetre sa sp\u00e9cification, c\u2019est \u00e0 dire son nom, les types de ses param\u00e8tres et de la valeur qu\u2019elle retourne et sa documentation. Dans tous les cas, l\u2019utilisateur, un programme ou un humain, se contente de fournir les donn\u00e9es demand\u00e9es et obtient le r\u00e9sultat du traitement. On s'int\u00e9resse ici \u00e0 la Base Adresse Nationale qui est une API gratuite du gouvernement fran\u00e7ais permettant d'obtenir un certain nombre d'informations \u00e0 partir d'une adresse postale.","title":"1. Qu'est qu'une API ?"},{"location":"Langages%20et%20programmation/CH11_modularite/cours/#2-interrogation-de-lapi","text":"On souhaite, gr\u00e2ce \u00e0 l'API, obtenir des informations sur l'adresse postale de l'institution Ste Marie. Pour interroger l'API, il suffit d'envoyer une requ\u00eate GET \u00e0 l'URL https://api-adresse.data.gouv.fr/search/?q=54-rue-de-l-eglise&postcode=59134 . On remarque que l'adresse postale sur laquelle on souhaite interroger l'API est indiqu\u00e9e dans l'URL. La r\u00e9ponse renvoy\u00e9e par l'API est la suivante : { \"type\" : \"FeatureCollection\" , \"version\" : \"draft\" , \"features\" : [{ \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.919014 , 50.603896 ]}, \"properties\" : { \"label\" : \"Rue de l\\u2019Eglise 59134 Beaucamps-Ligny\" , \"score\" : 0.7158977005347593 , \"id\" : \"59056_0060\" , \"name\" : \"Rue de l\\u2019Eglise\" , \"postcode\" : \"59134\" , \"citycode\" : \"59056\" , \"x\" : 694257.21 , \"y\" : 7056318.52 , \"city\" : \"Beaucamps-Ligny\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.46311 }}, { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.864853 , 50.571784 ]}, \"properties\" : { \"label\" : \"Rue de l\\u2019Eglise 59134 Wicres\" , \"score\" : 0.712733155080214 , \"id\" : \"59658_0020\" , \"name\" : \"Rue de l\\u2019Eglise\" , \"postcode\" : \"59134\" , \"citycode\" : \"59658\" , \"x\" : 690410.49 , \"y\" : 7052745.79 , \"city\" : \"Wicres\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.4283 }}, { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.884764 , 50.614966 ]}, \"properties\" : { \"label\" : \"Rue de l\\u2019Eglise 59134 Le Maisnil\" , \"score\" : 0.7101831550802139 , \"id\" : \"59371_0060\" , \"name\" : \"Rue de l\\u2019Eglise\" , \"postcode\" : \"59134\" , \"citycode\" : \"59371\" , \"x\" : 691830.32 , \"y\" : 7057555.01 , \"city\" : \"Le Maisnil\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.40025 }}, { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.86755 , 50.570217 ]}, \"properties\" : { \"label\" : \"Rue de l\\u2019Eglise et Bas Champ 59134 Wicres\" , \"score\" : 0.41261 , \"id\" : \"59658_gy8iak\" , \"name\" : \"Rue de l\\u2019Eglise et Bas Champ\" , \"postcode\" : \"59134\" , \"citycode\" : \"59658\" , \"x\" : 690601.57 , \"y\" : 7052570.87 , \"city\" : \"Wicres\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.33871 }}, { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.86596 , 50.572264 ]}, \"properties\" : { \"label\" : \"Chemin Pieton Rues (l\\u2019Eglise - Viguier) 59134 Wicres\" , \"score\" : 0.2762463636363636 , \"id\" : \"59658_k3ui6a\" , \"name\" : \"Chemin Pieton Rues (l\\u2019Eglise - Viguier)\" , \"postcode\" : \"59134\" , \"citycode\" : \"59658\" , \"x\" : 690489.13 , \"y\" : 7052799.13 , \"city\" : \"Wicres\" , \"context\" : \"59, Nord, Hauts-de-France\" , \"type\" : \"street\" , \"importance\" : 0.33871 }}], \"attribution\" : \"BAN\" , \"licence\" : \"ETALAB-2.0\" , \"query\" : \"54-rue-de-l-eglise\" , \"filters\" : { \"postcode\" : \"59134\" }, \"limit\" : 5 } La r\u00e9ponse re\u00e7ue est au format JSON (JavaScript Object Notation). La signification des champs de la r\u00e9ponse est donn\u00e9e dans la documentation de l'API. L'interrogation de l'API peut \u00eatre r\u00e9alis\u00e9e gr\u00e2ce au code Python ci-dessous. Lors de son ex\u00e9cution, la r\u00e9ponse renvoy\u00e9e par l'API est stock\u00e9e dans la variable reponse. 1 2 3 4 import requests url = \"https://api-adresse.data.gouv.fr/search/?q=54-rue-de-l-eglise&postcode=59134\" reponse = requests . get ( url ) reponse = reponse . json () - La fonction get du module requests permet d'envoyer une requ\u00eate GET \u00e0 l'URL sp\u00e9cifi\u00e9e et ensuite de r\u00e9cup\u00e9rer la r\u00e9ponse. - La commande reponse.json() extrait de la r\u00e9ponse les donn\u00e9es encod\u00e9es dans le format JSON, qui est un format de donn\u00e9es textuelles que l'on peut traiter comme s'il s'agissait d'un dictionnaire Python.","title":"2. Interrogation de l'API"},{"location":"Langages%20et%20programmation/CH11_modularite/cours/#3-traitement-de-la-reponse-renvoyee-par-lapi","text":"Il est possible de d\u00e9finir une fonction qui interroge l'API \u00e0 partir d'une adresse postale au choix, pass\u00e9e en param\u00e8tre. Premi\u00e8re fa\u00e7on : r\u00e9cup\u00e9rer l'ensemble des donn\u00e9es La fonction interroger_API_BAN prend en arguments adresse (une cha\u00eene de caract\u00e8res) et code_postal (entier ou cha\u00eene de caract\u00e8res) et renvoie reponse qui est un dictionnaire contenant toutes les donn\u00e9es renvoy\u00e9es par l'API. 1 2 3 4 5 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () return reponse Remarques : Penser \u00e0 importer le module requests ! L'utilisation d'une f-string pour l'\u00e9criture de l'URL permet d'y int\u00e9grer simplement et lisiblement les param\u00e8tres d'entr\u00e9e de la fonction. Et ici, la fonction renvoie l'ensemble des donn\u00e9es r\u00e9cup\u00e9r\u00e9es via l'API. La plupart du temps, on souhaite n\u00e9anmoins isoler les donn\u00e9es qui nous int\u00e9ressent et elles seules. Deuxi\u00e8me fa\u00e7on : renvoyer uniquement des donn\u00e9es qui nous int\u00e9ressent La fonction interroger_API_BAN prend toujours en arguments adresse (une cha\u00eene de caract\u00e8res) et code_postal (entier ou cha\u00eene de caract\u00e8res) et renvoie un couple (lat, long) (tuple) des coordonn\u00e9es g\u00e9ographiques. 1 2 3 4 5 6 7 8 def interroger_API_BAN ( adresse , code_postal ): url = f \"https://api-adresse.data.gouv.fr/search/?q= { adresse } &postcode= { code_postal } \" reponse = requests . get ( url ) reponse = reponse . json () coord = reponse [ 'features' ][ 0 ][ 'geometry' ][ 'coordinates' ] long = coord [ 0 ] lat = coord [ 1 ] return ( lat , long ) Remarques : Une fois la r\u00e9ponse de l'API transform\u00e9e en dictionnaire, il suffit de naviguer pour r\u00e9cup\u00e9rer les donn\u00e9es qui nous int\u00e9ressent, comme par exemple les coordonn\u00e9es g\u00e9ographiques de l'adresse pass\u00e9e en param\u00e8tre. reponse est un dictionnaire poss\u00e9dant huit cl\u00e9s : 'type' , 'version' , 'features' , 'attribution' , 'licence' , 'query' , 'filters' et 'limit' . reponse['features'] est un tableau contenant un ou plusieurs \u00e9l\u00e9ments de type dictionnaire : chaque dictionnaire correspond \u00e0 une adresse potentielle, la premi\u00e8re (indice 0) \u00e9tant la plus susceptible de correspondre \u00e0 notre demande. reponse['features'][0] est un dictionnaire poss\u00e9dant trois cl\u00e9s : 'type' , 'geometry' et 'properties' . reponse['features'][0]['geometry'] est un dictionnaire poss\u00e9dant deux cl\u00e9s : 'type' et 'coordinates' . reponse['features'][0]['geometry']['coordinates'] est un tableau contenant deux \u00e9l\u00e9ments de type flottant : la longitude (indice 0 ) et la latitude (indice 1 ) du lieu. Ce que vous savez maintenant Envoyer une requ\u00eate \u00e0 une API avec le module requests . S\u00e9lectionner des informations dans la r\u00e9ponse renvoy\u00e9e par une API. Consulter la documentation d'une API.","title":"3. Traitement de la r\u00e9ponse renvoy\u00e9e par l'API"},{"location":"Langages%20et%20programmation/CH11_modularite/cours/#4-a-vous-de-faire","text":"","title":"4. \u00c0 vous de faire"},{"location":"Langages%20et%20programmation/CH11_modularite/cours/#41-asteroides-a-surveiller","text":"Near Earth Object Web Service ( NEOWS ) est une API par l'interm\u00e9diaire de laquelle la NASA met \u00e0 disposition des donn\u00e9es sur les ast\u00e9ro\u00efdes passant \u00e0 proximit\u00e9 de la Terre. Contrairement \u00e0 l'API Base Adresse Nationale , l'utilisation de cette API n\u00e9cessite de disposer d'une cl\u00e9 d'API , qui permet d'identifier le programme consommateur et \u00e9ventuellement de limiter le nombre de requ\u00eates autoris\u00e9es. La cl\u00e9 de d\u00e9monstration DEMO_KEY est fournie par la NASA pour tester l'API. Le nombre de requ\u00eates est n\u00e9anmoins limit\u00e9 \u00e0 30 par heure et par adresse IP et \u00e0 50 par jour et par adresse IP. Vous pouvez vous inscrire ici pour obtenir une cl\u00e9 gratuite personnelle. Notebook : ex_asteroides.ipynb","title":"4.1 Ast\u00e9ro\u00efdes \u00e0 surveiller"},{"location":"Langages%20et%20programmation/CH11_modularite/cours/#42-bulletin-meteo","text":"L'API OpenWeatherMap permet de r\u00e9cup\u00e9rer les donn\u00e9es m\u00e9t\u00e9orologiques d'un lieu donn\u00e9. Contrairement \u00e0 l'API Base Adresse Nationale, l'utilisation de cette API n\u00e9cessite de disposer d'une cl\u00e9 d'API , qui permet d'identifier le programme consommateur et \u00e9ventuellement de limiter le nombre de requ\u00eates autoris\u00e9es. Vous pouvez vous inscrire ici pour obtenir une cl\u00e9 gratuite personnelle. Notebook : ex_bulletin_meteo.ipynb","title":"4.2 Bulletin m\u00e9t\u00e9o"},{"location":"Langages%20et%20programmation/CH11_modularite/cours/#43-composition-de-produits-alimentaires","text":"L'API Open Food Facts permet de r\u00e9cup\u00e9rer des informations sur un produit alimentaire \u00e0 partir de son num\u00e9ro de code-barres. Par exemple, pour le produit dont le code-barres est 8076800376999, il suffit d'envoyer une requ\u00eate GET \u00e0 l'URL https://world.openfoodfacts.org/api/v0/product/8076800376999.json . Notebook : ex_openfoodfacts.ipynb Sources https://ntoulzac.github.io/Cours-NSI-Terminale/api/ Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER.","title":"4.3 Composition de produits alimentaires"},{"location":"Langages%20et%20programmation/CH1_map/cours/","text":"CH1 : Mise au point des programmes - Gestion des bugs \u2693\ufe0e Programme officiel \"La mise au point du programme doit permettre au programme de r\u00e9pondre \u00e0 une sp\u00e9cification, durant cette phase, le programmeur se doit de savoir r\u00e9pondre aux causes typiques de bugs.\" 1. Conventions syntaxiques \u2693\ufe0e La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits : 1.1 Les espaces \u2693\ufe0e \u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/ 1.2 Les conventions de nommage \u2693\ufe0e \u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. (cf : cours de Mme Desmarest) # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass 2. Les erreurs courantes en Python - Savoir lire ses erreurs et corriger son code \u2693\ufe0e Lorsqu'on ex\u00e9cute un programme, il peut fonctionner comme pr\u00e9vu, mais il peut \u00e9galement \"planter\", ou bien ne plus s'arr\u00eater (boucler ind\u00e9finiment). Les sources possibles d'erreurs dans un programme sont nombreuses. En fonction des erreurs rencontr\u00e9es, Python affiche des erreurs sp\u00e9cifiques qui vous aident \u00e0 comprendre quel est le probl\u00e8me dans votre programme. 2.1 Analyser le traceback \u2693\ufe0e Le traceback est l\u2019ensemble des lignes a\ufb00ich\u00e9es par l\u2019interpr\u00e9teur Python lorsqu\u2019une exception est lev\u00e9e. Comprendre le traceback est tr\u00e8s utile pour trouver rapidement une faute et l\u2019expliquer. Voici un exemple de traceback a\ufb00ich\u00e9 lors de l\u2019ex\u00e9cution d\u2019un code: 1 2 3 4 5 6 7 8 def moyenne ( t ): n = len ( t ) s = 0 for i in range ( n ): s = s + t [ i ] return s / n print ( moyenne ([])) >>> % Run moyenne . py Traceback ( most recent call last ): File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 8 , in < module > print ( moyenne ([])) File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 6 , in moyenne return s / n ZeroDivisionError : division by zero Ce traceback est constitu\u00e9 d\u2019une liste de lignes en d\u00e9faut (il y en a 2 ici), puis d\u2019un message qui pr\u00e9cise letype d\u2019exception (c\u2019est la derni\u00e8re ligne). En lisant le traceback de haut en bas, on avance dans le temps. Ce qui s\u2019est produit en dernier est donc \u00e0 la fin du traceback. En le lisant de haut en bas, on note (notez la correspondance entre ce qui est indiqu\u00e9 ci-dessous et le contenudu traceback) : ex\u00e9cution de la ligne 8 \u00ab print(moyenne([])) \u00bb. On entre dans la fonction moyenne qui a provoqu\u00e9 l\u2019ex\u00e9cution de la ligne 6 \u00ab return s / n \u00bb, qui a donc provoqu\u00e9 la lev\u00e9e d\u2019exceptionZeroDivisionError: division by zero La plupart du temps, la lecture des trois derni\u00e8res lignes du traceback permet de cerner le probl\u00e8me : Ici, on effectue une divison par 0. Cela s'est produit lors du renvoie du calcul de s par n. Calcul qui est fait \u00e0 la ligne 6. Cette erreur n'est lev\u00e9e uniquement parceque on a fait appel \u00e0 la fonction moyenne sur un tableau vide. La fonction par elle m\u00eame est correcte. Il faut juste faire attention et pr\u00e9ciser \u00e0 l'utilisateur que la fonction doit \u00eatre appel\u00e9e avec des tableaux non vides. Pour \u00e9viter ces erreurs, il est donc important de : - savoir lire le traceback. - pr\u00e9voir des jeux de tests. - sp\u00e9cifier la fonction pour pouvoir b\u00e9n\u00e9ficier d'une aide \u00e0 l'utilisation de celle-ci. 2.2 Quelques erreurs courantes \u2693\ufe0e Voici quelques erreurs courantes que vous devez apprendre \u00e0 reconnaitre parmi les nombreuses exceptions de Python. Type d'erreur Objet Python Erreurs courantes Exemple Erreurs de syntaxe SyntaxError Erreur de parenth\u00e8se, : manquant avant un bloc d'instruction ... len(t)) Erreurs d'indexation IndexError Acc\u00e8s \u00e0 un index non pr\u00e9sent dans une liste, ou un tuple, str... t = [2, 3] puis print(t[2]) Erreurs de nom NameError Nom de fonction ou de variable mal orthographi\u00e9. print(Bonjour) ou prin(\"Bonjour\") Erreurs d'indentation IndentationError Indentation oubli\u00e9e, ou trop grande, les blocs sont alors mal d\u00e9limit\u00e9s. Erreurs de type TypeError Op\u00e9ration impossible entre deux types(str - int). Conversion de type impossible. '3' * '5' ** Exercices :** Identifier le type d'erreur dans les exerices ci-dessous et corriger les. Question 1 code solution On d\u00e9sire afficher les \u00e9l\u00e9ments de la liste. 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 4 : print ( lst [ i ]) i = i + 1 IndexError : la liste ne contient que 3 \u00e9l\u00e9ments 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 3 : print ( lst [ i ]) i = i + 1 On rapelle qu'il est pr\u00e9f\u00e9rable de parcourir une liste (tableau) en utilisant une boucle for. Exercice 2 code solution 1 2 3 a = 2 b = \"Une fois sur \" print ( b + a ) TypeError : On ne peut pas concat\u00e9ner une chaine de caract\u00e8res avec un int. 1 2 3 a = \"2\" b = \"Une fois sur \" print ( b + a ) ou alors 1 2 3 a = 2 b = \"Une fois sur \" print ( b + str ( a )) Exercice 3 code solution Afficher la somme de tous les \u00e9l\u00e9ments de la liste. 1 2 3 4 l = [ 0 , 4 , 8 , 5 ] for v in l : s = s + v print ( s ) NameError : la variable s n'est pas initialis\u00e9e avant la boucle. L'expression s + v ne peut \u00eatre calcul\u00e9e. ` 1 2 3 4 5 l = [ 0 , 4 , 8 , 5 ] s = 0 # par exemple for v in l : s = s + v print ( s ) Exercice 4 code solution Afficher les \u00e9l\u00e9ments de la liste 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) IndentationError : il manque l'indentation avant le print. ` 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) Exercice 5 code solution Afficher la plus petite valeur contenue dans la liste 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini mini = liste [ i ] print ( mini ) SyntaxError : il manque : dans la condition (ligne 4) 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini : mini = liste [ i ] print ( mini ) Remarques Attention, si l'interpr\u00e9teur Python ne renvoie pas d'erreur, cela ne signifie pas pour autant que votre code est correct. Dans l'exemple de la fonction moyenne qui doit renvoyer la moyenne des valeurs contenues dans un tableau, la fonction fait correctement le travail mais elle ne fonctionne pas sur une liste vide, ou sur une liste qui ne contiendrait pas uniquement des valeurs num\u00e9riques. D'autres erreurs peuvent \u00eatre non affich\u00e9es dans l'interpr\u00e9teur. Par exemple : des instructions conditionnelles qui oublient des cas, des mauvaises conditions ... des boucles qui ne se terminent pas : cas de la boucle while des effets de bords : on modifie une variable globale \u00e0 l'int\u00e9rieur d'une fonction. Il est donc important avant de coder de sp\u00e9cifier une fonction, de docummenter si n\u00e9cessaire une partie du code, de pr\u00e9voir des jeux de tests. Tester, debugger, font partie des bonnes pratiques du programmeur. \u00c7a s'appelle mettre au point du code. 3. Documenter et sp\u00e9cifier \u2693\ufe0e 3.1 Commenter son code ? (ou pas) \u2693\ufe0e Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires. 3.2 Le cas particulier des docstrings \u2693\ufe0e 3.2.1 Que sont les docstrings ? \u2693\ufe0e Les docstrings sont des commentaires normalis\u00e9s pour les fonctions, qui peuvent \u00eatre consult\u00e9s en console. Exemples : Nous connaissons la fonction len() qui permet par exemple de conna\u00eetre la longueur d'une liste pass\u00e9e en param\u00e8tre. Si nous tapons en console la commande print(len.__doc__) , nous aurons la description de cette fonction. >>> len . __doc__ 'Return the number of items in a container.' Il est aussi possible d'acc\u00e9der \u00e0 la docstring d'une fonction f par la commande help(f) : >>> help ( len ) Help on built - in function len in module builtins : len ( obj , / ) Return the number of items in a container . De m\u00eame pour la fonction range : >>> print ( range . __doc__ ) range ( stop ) -> range object range ( start , stop [, step ]) -> range object Return an object that produces a sequence of integers from start ( inclusive ) to stop ( exclusive ) by step . range ( i , j ) produces i , i + 1 , i + 2 , ... , j - 1. start defaults to 0 , and stop is omitted ! range ( 4 ) produces 0 , 1 , 2 , 3. These are exactly the valid indices for a list of 4 elements . When step is given , it specifies the increment ( or decrement ) . Le r\u00e9sultat de la commande help(range) est trop long pour \u00eatre repris ici, mais on y retrouve bien la docstring de la fonction range . 3.2.2 Cr\u00e9er ses propres docstrings \u2693\ufe0e Il suffit pour cela de commencer la fonction \u00e0 documenter par une ou plusieurs phrases entre triples quotes : def capital_apres_n_annees ( capital , taux , nombre_annees ) : \"\"\" Renvoie le capital apr\u00e8s n ann\u00e9es. input : capital : valeur initiale (float) taux : taux d'int\u00e9r\u00eat (float) (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d'ann\u00e9es de placement du capital (int) output : capital apr\u00e8s n ann\u00e9es (float) \"\"\" return capital * ( 1 + taux ) ** nombre_annees Ainsi, un utilisateur pourra trouver en console le mode d'emploi de notre fonction : >>> help ( capital_apres_n_annees ) Help on function capital_apres_n_annees in module __main__ : capital_apres_n_annees ( capital , taux , nombre_annees ) Renvoie le capital apr\u00e8s n ann\u00e9es . capital : valeur initiale taux : taux d 'int\u00e9r\u00eat exprim\u00e9 en nombre d\u00e9cimal (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d 'ann\u00e9es de placement du capital Comme on le voit, tout cela est tr\u00e8s \u00abverbeux\u00bb. Cela peut nous para\u00eetre largement superflu puisque nos codes d\u00e9passent rarement quelques dizaines de lignes et sont lus par rarement plus de 2 personnes. Mais dans la vraie vie des d\u00e9veloppeurs, il est primordial qu'un code soit clair et document\u00e9. \u00c0 retenir des commentaires quand cela est nec\u00e9ssaire des noms de variable explicites une sp\u00e9cification des fonctions avec une docstring sous le mod\u00e8le suivant : def ma_fonction (): \"\"\" que renvoie ma_fonction input : arguments, type output : valeur de sortie, type \"\"\" votre code 4. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code \u2693\ufe0e La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici . 5. Les tests \u2693\ufe0e 5.1 Pourquoi des tests ? \u2693\ufe0e Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok 5.2 Revoil\u00e0 les assert \u2693\ufe0e Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00e9nonc\u00e9 solution \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste d'entiers liste , suppos\u00e9e non vide, pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) . def test_maxi (): assert maxi ([ 5 ]) == 5 assert maxi ([ - 1 , 5 , 4 , 0 ]) == 5 assert maxi ([ 8 , 7 , 6 , 2 ]) == 8 assert maxi ([ - 1 , - 5 , 0 ]) == 0 def maxi ( liste ): \"\"\" revoie le maximum d'une liste d'entier non vide input : liste (list) d'entiers output : maximum (int) \"\"\" maximum = liste [ 0 ] for elt in liste : if elt > maximum : maximum = elt return maximum 5.3 Le module doctest \u2693\ufe0e Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. On peut, au lieu d'utiliser doctest dans la console Python, placer \u00e0 la fin du fichier le code suivant : if __name__ == '__main__' : import doctest doctest . testmod () Le resultat des tests, si ils ne passent pas, se fera dans l'interpr\u00e9teur \u00e0 chaque execution du code. 5.3 \u00c0 propos des tests \u2693\ufe0e Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...","title":"CH1 Mise au point des programmes"},{"location":"Langages%20et%20programmation/CH1_map/cours/#ch1-mise-au-point-des-programmes-gestion-des-bugs","text":"Programme officiel \"La mise au point du programme doit permettre au programme de r\u00e9pondre \u00e0 une sp\u00e9cification, durant cette phase, le programmeur se doit de savoir r\u00e9pondre aux causes typiques de bugs.\"","title":"CH1 : Mise au point des programmes - Gestion des bugs"},{"location":"Langages%20et%20programmation/CH1_map/cours/#1-conventions-syntaxiques","text":"La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits :","title":"1. Conventions syntaxiques"},{"location":"Langages%20et%20programmation/CH1_map/cours/#11-les-espaces","text":"\u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/","title":"1.1 Les espaces"},{"location":"Langages%20et%20programmation/CH1_map/cours/#12-les-conventions-de-nommage","text":"\u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. (cf : cours de Mme Desmarest) # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass","title":"1.2 Les conventions de nommage"},{"location":"Langages%20et%20programmation/CH1_map/cours/#2-les-erreurs-courantes-en-python-savoir-lire-ses-erreurs-et-corriger-son-code","text":"Lorsqu'on ex\u00e9cute un programme, il peut fonctionner comme pr\u00e9vu, mais il peut \u00e9galement \"planter\", ou bien ne plus s'arr\u00eater (boucler ind\u00e9finiment). Les sources possibles d'erreurs dans un programme sont nombreuses. En fonction des erreurs rencontr\u00e9es, Python affiche des erreurs sp\u00e9cifiques qui vous aident \u00e0 comprendre quel est le probl\u00e8me dans votre programme.","title":"2. Les erreurs courantes en Python - Savoir lire ses erreurs et corriger son code"},{"location":"Langages%20et%20programmation/CH1_map/cours/#21-analyser-le-traceback","text":"Le traceback est l\u2019ensemble des lignes a\ufb00ich\u00e9es par l\u2019interpr\u00e9teur Python lorsqu\u2019une exception est lev\u00e9e. Comprendre le traceback est tr\u00e8s utile pour trouver rapidement une faute et l\u2019expliquer. Voici un exemple de traceback a\ufb00ich\u00e9 lors de l\u2019ex\u00e9cution d\u2019un code: 1 2 3 4 5 6 7 8 def moyenne ( t ): n = len ( t ) s = 0 for i in range ( n ): s = s + t [ i ] return s / n print ( moyenne ([])) >>> % Run moyenne . py Traceback ( most recent call last ): File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 8 , in < module > print ( moyenne ([])) File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 6 , in moyenne return s / n ZeroDivisionError : division by zero Ce traceback est constitu\u00e9 d\u2019une liste de lignes en d\u00e9faut (il y en a 2 ici), puis d\u2019un message qui pr\u00e9cise letype d\u2019exception (c\u2019est la derni\u00e8re ligne). En lisant le traceback de haut en bas, on avance dans le temps. Ce qui s\u2019est produit en dernier est donc \u00e0 la fin du traceback. En le lisant de haut en bas, on note (notez la correspondance entre ce qui est indiqu\u00e9 ci-dessous et le contenudu traceback) : ex\u00e9cution de la ligne 8 \u00ab print(moyenne([])) \u00bb. On entre dans la fonction moyenne qui a provoqu\u00e9 l\u2019ex\u00e9cution de la ligne 6 \u00ab return s / n \u00bb, qui a donc provoqu\u00e9 la lev\u00e9e d\u2019exceptionZeroDivisionError: division by zero La plupart du temps, la lecture des trois derni\u00e8res lignes du traceback permet de cerner le probl\u00e8me : Ici, on effectue une divison par 0. Cela s'est produit lors du renvoie du calcul de s par n. Calcul qui est fait \u00e0 la ligne 6. Cette erreur n'est lev\u00e9e uniquement parceque on a fait appel \u00e0 la fonction moyenne sur un tableau vide. La fonction par elle m\u00eame est correcte. Il faut juste faire attention et pr\u00e9ciser \u00e0 l'utilisateur que la fonction doit \u00eatre appel\u00e9e avec des tableaux non vides. Pour \u00e9viter ces erreurs, il est donc important de : - savoir lire le traceback. - pr\u00e9voir des jeux de tests. - sp\u00e9cifier la fonction pour pouvoir b\u00e9n\u00e9ficier d'une aide \u00e0 l'utilisation de celle-ci.","title":"2.1 Analyser le traceback"},{"location":"Langages%20et%20programmation/CH1_map/cours/#22-quelques-erreurs-courantes","text":"Voici quelques erreurs courantes que vous devez apprendre \u00e0 reconnaitre parmi les nombreuses exceptions de Python. Type d'erreur Objet Python Erreurs courantes Exemple Erreurs de syntaxe SyntaxError Erreur de parenth\u00e8se, : manquant avant un bloc d'instruction ... len(t)) Erreurs d'indexation IndexError Acc\u00e8s \u00e0 un index non pr\u00e9sent dans une liste, ou un tuple, str... t = [2, 3] puis print(t[2]) Erreurs de nom NameError Nom de fonction ou de variable mal orthographi\u00e9. print(Bonjour) ou prin(\"Bonjour\") Erreurs d'indentation IndentationError Indentation oubli\u00e9e, ou trop grande, les blocs sont alors mal d\u00e9limit\u00e9s. Erreurs de type TypeError Op\u00e9ration impossible entre deux types(str - int). Conversion de type impossible. '3' * '5' ** Exercices :** Identifier le type d'erreur dans les exerices ci-dessous et corriger les. Question 1 code solution On d\u00e9sire afficher les \u00e9l\u00e9ments de la liste. 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 4 : print ( lst [ i ]) i = i + 1 IndexError : la liste ne contient que 3 \u00e9l\u00e9ments 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 3 : print ( lst [ i ]) i = i + 1 On rapelle qu'il est pr\u00e9f\u00e9rable de parcourir une liste (tableau) en utilisant une boucle for. Exercice 2 code solution 1 2 3 a = 2 b = \"Une fois sur \" print ( b + a ) TypeError : On ne peut pas concat\u00e9ner une chaine de caract\u00e8res avec un int. 1 2 3 a = \"2\" b = \"Une fois sur \" print ( b + a ) ou alors 1 2 3 a = 2 b = \"Une fois sur \" print ( b + str ( a )) Exercice 3 code solution Afficher la somme de tous les \u00e9l\u00e9ments de la liste. 1 2 3 4 l = [ 0 , 4 , 8 , 5 ] for v in l : s = s + v print ( s ) NameError : la variable s n'est pas initialis\u00e9e avant la boucle. L'expression s + v ne peut \u00eatre calcul\u00e9e. ` 1 2 3 4 5 l = [ 0 , 4 , 8 , 5 ] s = 0 # par exemple for v in l : s = s + v print ( s ) Exercice 4 code solution Afficher les \u00e9l\u00e9ments de la liste 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) IndentationError : il manque l'indentation avant le print. ` 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) Exercice 5 code solution Afficher la plus petite valeur contenue dans la liste 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini mini = liste [ i ] print ( mini ) SyntaxError : il manque : dans la condition (ligne 4) 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini : mini = liste [ i ] print ( mini ) Remarques Attention, si l'interpr\u00e9teur Python ne renvoie pas d'erreur, cela ne signifie pas pour autant que votre code est correct. Dans l'exemple de la fonction moyenne qui doit renvoyer la moyenne des valeurs contenues dans un tableau, la fonction fait correctement le travail mais elle ne fonctionne pas sur une liste vide, ou sur une liste qui ne contiendrait pas uniquement des valeurs num\u00e9riques. D'autres erreurs peuvent \u00eatre non affich\u00e9es dans l'interpr\u00e9teur. Par exemple : des instructions conditionnelles qui oublient des cas, des mauvaises conditions ... des boucles qui ne se terminent pas : cas de la boucle while des effets de bords : on modifie une variable globale \u00e0 l'int\u00e9rieur d'une fonction. Il est donc important avant de coder de sp\u00e9cifier une fonction, de docummenter si n\u00e9cessaire une partie du code, de pr\u00e9voir des jeux de tests. Tester, debugger, font partie des bonnes pratiques du programmeur. \u00c7a s'appelle mettre au point du code.","title":"2.2 Quelques erreurs courantes"},{"location":"Langages%20et%20programmation/CH1_map/cours/#3-documenter-et-specifier","text":"","title":"3. Documenter et sp\u00e9cifier"},{"location":"Langages%20et%20programmation/CH1_map/cours/#31-commenter-son-code-ou-pas","text":"Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires.","title":"3.1 Commenter son code ? (ou pas)"},{"location":"Langages%20et%20programmation/CH1_map/cours/#32-le-cas-particulier-des-docstrings","text":"","title":"3.2 Le cas particulier des docstrings"},{"location":"Langages%20et%20programmation/CH1_map/cours/#4-la-programmation-defensive-des-assert-pour-securiser-le-code","text":"La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici .","title":"4. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code"},{"location":"Langages%20et%20programmation/CH1_map/cours/#5-les-tests","text":"","title":"5. Les tests"},{"location":"Langages%20et%20programmation/CH1_map/cours/#51-pourquoi-des-tests","text":"Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok","title":"5.1 Pourquoi des tests ?"},{"location":"Langages%20et%20programmation/CH1_map/cours/#52-revoila-les-assert","text":"Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00e9nonc\u00e9 solution \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste d'entiers liste , suppos\u00e9e non vide, pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) . def test_maxi (): assert maxi ([ 5 ]) == 5 assert maxi ([ - 1 , 5 , 4 , 0 ]) == 5 assert maxi ([ 8 , 7 , 6 , 2 ]) == 8 assert maxi ([ - 1 , - 5 , 0 ]) == 0 def maxi ( liste ): \"\"\" revoie le maximum d'une liste d'entier non vide input : liste (list) d'entiers output : maximum (int) \"\"\" maximum = liste [ 0 ] for elt in liste : if elt > maximum : maximum = elt return maximum","title":"5.2 Revoil\u00e0 les assert"},{"location":"Langages%20et%20programmation/CH1_map/cours/#53-le-module-doctest","text":"Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. On peut, au lieu d'utiliser doctest dans la console Python, placer \u00e0 la fin du fichier le code suivant : if __name__ == '__main__' : import doctest doctest . testmod () Le resultat des tests, si ils ne passent pas, se fera dans l'interpr\u00e9teur \u00e0 chaque execution du code.","title":"5.3 Le module doctest"},{"location":"Langages%20et%20programmation/CH1_map/cours/#53-a-propos-des-tests","text":"Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...","title":"5.3 \u00c0 propos des tests"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/","text":"CH2 : La r\u00e9cursivit\u00e9 \u2693\ufe0e Programme officiel 1. Premi\u00e8re approche \u2693\ufe0e 1.1. D\u00e9finition \u2693\ufe0e Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition. 1.2 Un tr\u00e8s mauvais exemple \u2693\ufe0e C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : >>> prems () La sortie en console sera celle-ci : un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie . 1.3 La mauvaise r\u00e9putation \u2693\ufe0e Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association. 2. La r\u00e9cursivit\u00e9, \u00e7a marche ! \u2693\ufe0e Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat. 2.1 La r\u00e9cursivit\u00e9 en BD : \u2693\ufe0e Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb : 2.2 Enfin un bon exemple \u2693\ufe0e Exemple fondateur n\u00b01 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: $$ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1$$ Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp() . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec() . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 ) 3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9 \u2693\ufe0e 3.1 Notion de pile \u2693\ufe0e Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile, seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci : 3.2 Limitation de la taille de la pile \u2693\ufe0e Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? mystere ( 2962 ) --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ). 4. Exemples de r\u00e9cursivit\u00e9 double \u2693\ufe0e 4.1 La suite de Fibonnaci \u2693\ufe0e Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonnaci. 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois... 4.2 Comparaison des performances \u2693\ufe0e Exercice \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonnaci. 1 2 3 4 5 6 7 8 def fibo_imperatif ( n ): a = 0 b = 1 for k in range ( n - 1 ): t = b b = a + b a = t return b Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . % timeit fibo_imperatif ( 20 ) 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit fibo_recursif ( 20 ) 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef) 5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle \u2693\ufe0e Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )","title":"CH2 La r\u00e9cursivit\u00e9"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#ch2-la-recursivite","text":"Programme officiel","title":"CH2 : La r\u00e9cursivit\u00e9"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#1-premiere-approche","text":"","title":"1. Premi\u00e8re approche"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#11-definition","text":"Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition.","title":"1.1. D\u00e9finition"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#12-un-tres-mauvais-exemple","text":"C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : >>> prems () La sortie en console sera celle-ci : un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie .","title":"1.2 Un tr\u00e8s mauvais exemple"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#13-la-mauvaise-reputation","text":"Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association.","title":"1.3 La mauvaise r\u00e9putation"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#2-la-recursivite-ca-marche","text":"Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat.","title":"2. La r\u00e9cursivit\u00e9, \u00e7a marche !"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#21-la-recursivite-en-bd","text":"Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb :","title":"2.1 La r\u00e9cursivit\u00e9 en BD :"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#22-enfin-un-bon-exemple","text":"Exemple fondateur n\u00b01 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: $$ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1$$ Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp() . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec() . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 )","title":"2.2 Enfin un bon exemple"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#3-le-mecanisme-interne-de-la-recursivite","text":"","title":"3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#31-notion-de-pile","text":"Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile, seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci :","title":"3.1 Notion de pile"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#32-limitation-de-la-taille-de-la-pile","text":"Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? mystere ( 2962 ) --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ).","title":"3.2 Limitation de la taille de la pile"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#4-exemples-de-recursivite-double","text":"","title":"4. Exemples de r\u00e9cursivit\u00e9 double"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#41-la-suite-de-fibonnaci","text":"Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonnaci. 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois...","title":"4.1 La suite de Fibonnaci"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#42-comparaison-des-performances","text":"Exercice \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonnaci. 1 2 3 4 5 6 7 8 def fibo_imperatif ( n ): a = 0 b = 1 for k in range ( n - 1 ): t = b b = a + b a = t return b Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . % timeit fibo_imperatif ( 20 ) 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) % timeit fibo_recursif ( 20 ) 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef)","title":"4.2 Comparaison des performances"},{"location":"Langages%20et%20programmation/CH2_recursivite/cours/#5-annexe-dessins-recursifs-grace-au-module-turtle","text":"Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )","title":"5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle"},{"location":"Structures%20de%20donn%C3%A9es/sommaire/","text":"CH3 : Type de donn\u00e9es abstrait - Listes - Dictionnaires (BAC) CH6 : Piles et Files (BAC) CH7 : Graphes et parcours de graphes","title":"Sommaire"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/","text":"CH3 : Structures de donn\u00e9es - Listes et dictionnaires \u2693\ufe0e Programme officiel Le langage Python dispose, comme tous les langages de haut niveau, d'un ensemble de types simples et de types structur\u00e9s vus dans le programme de premi\u00e8re : nombres, bool\u00e9ens, cha\u00eenes de caract\u00e8res, tuples, tableaux, dictionnaires ... Ces types de bases sont appell\u00e9s types concrets . Cette ann\u00e9e, comme nous allons manipuler des donn\u00e9es plus complexes que des simples nombres, on va cr\u00e9er des structures de donn\u00e9es plus complexes. Pour d\u00e9finir ces structures, on utilise des types abstraits de donn\u00e9es . 1. Type abstrait de donn\u00e9es \u2693\ufe0e 1.1 Interface \u2693\ufe0e Un type abstrait est caract\u00e9ris\u00e9 par une interface de programmation . L'interface, c'est l'ensemble des op\u00e9rations ou primitives qui vont permettre de manipuler les donn\u00e9es. On distingue : - les constructeurs qui permettent de cr\u00e9er une nouvelle structure de donn\u00e9es. - les op\u00e9rateurs qui permettent de modifier la structure. On peut par exemple ajouter ou retirer des donn\u00e9es. - les accesseurs qui donnent des informations sur la structure. Par exemple, donner le nombre d'\u00e9l\u00e9ments dans la structure. - les it\u00e9rateurs qui permettent d'\u00e9num\u00e9rer les \u00e9l\u00e9ments de la structure. 1.2 Impl\u00e9mentation \u2693\ufe0e Impl\u00e9menter un type abstrait, c'est coder les diff\u00e9rentes op\u00e9rations qui r\u00e9pondent \u00e0 sp\u00e9cification de l'interface. Il est possible de r\u00e9aliser plusieurs impl\u00e9mentations diff\u00e9rentes pour r\u00e9pondre \u00e0 la m\u00eame sp\u00e9cification. Certaines impl\u00e9mentation vont \u00eatre plus rapides, moins gourmandes en espace m\u00e9moire, plus adapt\u00e9es \u00e0 la taille des donn\u00e9es ... Du concret pour mieux comprendre : INTERFACE vs IMPL\u00c9MENTATION On peut choisir comme image une machine \u00e0 caf\u00e9 \u00e0 capsule, dans laquelle on peut distinguer : L'interface On distinge ici : les boutons, le levier, les petites lumi\u00e8res ... C'est la partie utilisateur . L'impl\u00e9mentation Sur ce sch\u00e9ma apparaissent : les \u00e9lectrovannes, la pompe, le bloc de chauffe, voire le d\u00e9roulement des op\u00e9rations ... C'est la partie constructeur . Pas besoin de savoir comment fonctionne la machine \u00e0 l'int\u00e9rieur (impl\u00e9mentation), pour se faire un caf\u00e9 (interface)... Dans notre programme de terminale, on va pr\u00e9senter plusieurs types abstraits comme : les listes (Ne pas confondre avec le type list de Python), les piles, les files ... On va apprendre \u00e0 utiliser ces types, puis on les impl\u00e9mentera de diff\u00e9rentes fa\u00e7on. 1.3 Exemple des tableaux \u2693\ufe0e En premi\u00e8re, on utilise des objets de type list pour manipuler des donn\u00e9es. Le type list est un type concret du langage Python. Par abus de langage on appelle cela des listes mais en fait ce sont des tableaux dynamiques . L'interface de ce type serait : Op\u00e9rations Exemple(s) complexit\u00e9 Constructeurs l = [] ou l = list() O(1) accesseurs len(l) O(1) l[i] O(1) op\u00e9rateurs l[i] = x O(1) l.append(x) O(1) l.insert(i, x) O(n) l.pop() O(1) del l[i] O(n) it\u00e9rateurs for elt in l O(n) Exercice 1 \u00c9nonc\u00e9 Solution Donner le contenu de la variable l apr\u00e8s avoir executer les instructions ci-dessous : >>> l = list () >>> l . append ( 4 ) >>> l . append ( 6 ) >>> l . insert ( 0 , 6 ) >>> l . pop () >>> l [ 0 ] = 2 >>> l . append ( 3 ) [ 2 , 4 , 3 ] L\u00e0 encore pas besoin de comprendre comment cela fonction. Il suffit juste d'utiliser l'interface. 1.4 Exemples de types abstraits \u2693\ufe0e Voici les diff\u00e9rents types abstraits que l'on va \u00e9tudier cette ann\u00e9e. En informatique comme dans la vie courante, il est conseill\u00e9 d'adapter sa mani\u00e8re de stocker et de traiter des donn\u00e9es en fonction de la nature de celles-ci : Le serveur d'un caf\u00e9, charg\u00e9 de transporter les boissons du comptoir aux tables des clients, n'utilisera pas un sac en plastique pour faire le transport : il pr\u00e9f\u00e8rera un plateau. Le chercheur de champignons, lui, n'utilisera pas un plateau pour stocker ses trouvailles : il pr\u00e9f\u00e8rera un panier. Pour stocker des chaussettes, on pr\u00e9f\u00e8rera les entasser dans un tiroir (apr\u00e8s les avoir appair\u00e9es), plut\u00f4t que de les suspendre \u00e0 des cintres. De m\u00eame en informatique, pour chaque type de donn\u00e9es, pour chaque utilisation pr\u00e9vue, une structure particuli\u00e8re de donn\u00e9es se rev\u00e8lera (peut-\u00eatre) plus adapt\u00e9e qu'une autre. Int\u00e9ressons nous par exemple aux donn\u00e9es lin\u00e9aires . Ce sont des donn\u00e9es qui ne comportent pas de hi\u00e9rarchie : toutes les donn\u00e9es sont de la m\u00eame nature et ont le m\u00eame r\u00f4le. Par exemple, un relev\u00e9 mensuel de temp\u00e9ratures, la liste des \u00e9l\u00e8ves d'une classe, un historique d'op\u00e9rations bancaires... Ces donn\u00e9es sont \u00abplates\u00bb, n'ont pas de sous-domaines : la structure de liste para\u00eet parfaitement adapt\u00e9e. Lorsque les donn\u00e9es de cette liste sont en fait des couples (comme dans le cas d'une liste de noms/num\u00e9ros de t\u00e9l\u00e9phone), alors la structure la plus adapt\u00e9e est sans doute celle du dictionnaire . Les listes et les dictionnaires sont donc des exemples de structures de donn\u00e9es lin\u00e9aires . 2. Les listes \u2693\ufe0e 2.1 D\u00e9finitions g\u00e9n\u00e9rales \u2693\ufe0e Une liste est un ensemble ordonn\u00e9 d'objets. G\u00e9n\u00e9ralement, ces donn\u00e9es seront de m\u00eame type, mais ce n'est pas structurellement obligatoire. Lorsque l'impl\u00e9mentation de la liste fait appara\u00eetre une cha\u00eene de valeurs, chacune pointant vers la suivante, on dit que la liste est une liste cha\u00een\u00e9e . L'interface minimale d'une liste est : constructeur : creer_liste() qui retourne une liste vide. accesseur : liste_vide(l) qui retourne True si la liste l est vide. op\u00e9rateur : inserer(e, l) qui ins\u00e8re l'\u00e9l\u00e9ment e dans la liste l et retourne une nouvelle liste. accesseur : tete(l) qui retourne l'\u00e9l\u00e9ment en t\u00eate de liste (si elle n'est pas vide). accesseur : queue(l) qui retourne la liste priv\u00e9e de son premier \u00e9l\u00e9ment (la t\u00eate)(si elle n'est pas vide). it\u00e9rateur : elements_liste(l) qui retourne un tableau contenant les \u00e9l\u00e9ments de la liste l , que l'on peut ensuite \u00e9num\u00e9rer avec une boucle for. 2.2 Exemple d'impl\u00e9mentation par des tuples \u2693\ufe0e On peut impl\u00e9menter une liste en Python en utilisant des tuples. Une liste sera repr\u00e9sent\u00e9e par un tuple (tete, queue) . tete est le premier \u00e9l\u00e9ment de la liste et queue est le reste de la liste, qui est elle m\u00eame une liste. C'est r\u00e9cursif. On peut utiliser la liste de la mani\u00e8re suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> liste = creer_liste () >>> liste = inserer ( \"Alice\" , liste ) >>> liste = inserer ( \"Bob\" , liste ) >>> liste = inserer ( \"Charlie\" , liste ) >>> print ( tete ( liste )) Charlie >>> print ( queue ( liste )) ( \"Bob\" , ( \"Alice\" , ())) >>> for elt in elements_liste ( liste ): print ( elt ) Charlie Bob Alice L'\u00e9tat de la liste apr\u00e8s la ligne 4 est : ( \"Charlie\" , ( \"Bob\" , ( \"Alice\" , ()))) Soit : Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier listes_cours.py . Le constructeur : cr\u00e9ation de la liste \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction creer_liste qui ne prend pas d'argument et qui renvoie un tuple. def creer_liste (): return () Un accesseur : savoir si la liste est vide \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction liste_vide qui prend en argument une liste et qui renvoie True si la liste est vide. def liste_vide ( liste ): return liste == () Un op\u00e9rateur : insertion d'un \u00e9l\u00e9ment \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction inserer qui prend en argument un \u00e9l\u00e9ment et une liste et qui renvoie la liste. L'\u00e9l\u00e9ment est ajout\u00e9 en t\u00eate de liste et la liste vient en queue. def inserer ( elt , liste ): return ( elt , liste ) Des accesseurs : \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er deux fonctions : tete qui prend en argument une liste et qui renvoie l'\u00e9l\u00e9ment en t\u00eate de liste. queue qui prend en argument une liste et qui renvoie la liste priv\u00e9e de sa t\u00eate. V\u00e9rifier pour les deux fonctions que la liste pass\u00e9e en argument n'est pas vide avec un assert . def tete ( liste ): assert not liste_vide ( liste ), \"liste vide\" return liste [ 0 ] def queue ( liste ): assert not liste_vide ( liste ), 'liste vide' return liste [ 1 ] Un it\u00e9rateur : lister les \u00e9l\u00e9ments pr\u00e9sents dans la liste \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction elements_liste qui prend en argument une liste et qui renvoie un tableau contenant les \u00e9l\u00e9ments de la liste. La fonction doit retourner un tableau. Utiliser une boucle while pour parcourir la liste. def elements_liste ( liste ): tab_iter = [] while not liste_vide ( liste ): tab_iter . append ( tete ( liste )) liste = queue ( liste ) return tab_iter \u00c9tendre l'interface \u2693\ufe0e On peut ajouter un accesseur taille qui retourne le nombre d'\u00e9l\u00e9ments de la liste. Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction taille qui prend en argument une liste et qui renvoie le nombre d'\u00e9l\u00e9ments de la liste. def taille ( liste ): nb = 0 while not liste_vide ( liste ): nb = nb + 1 liste = queue ( liste ) return nb 2.3 Autre impl\u00e9mentation et utilisation des listes \u2693\ufe0e Travail \u00e0 r\u00e9aliser sur le notebook TD_listes.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 listes.py avec l'impl\u00e9mentation utilisant la POO. 3. Les dictionnaires \u2693\ufe0e 3.1 tableau associatif \u2693\ufe0e Les dictionnaires ont d\u00e9j\u00e0 \u00e9t\u00e9 \u00e9tudi\u00e9s en classe de premi\u00e8re. Pour rappel, ce type de donn\u00e9es, aussi appel\u00e9 tableau associatif , permet de stocker des valeurs et d'y acc\u00e9der au moyen d'une cl\u00e9 , contrairement au tableau qui permet d'acc\u00e9der \u00e0 une donn\u00e9e au moyen d'un indice . On parle d'association cl\u00e9: valeur . Le langage Python fournit directement le type structur\u00e9 dict qui impl\u00e9mente un dictionnaire. Constructeur : d = dict() ou d = {} , cr\u00e9ation d'un dictionnaire nomm\u00e9 d . op\u00e9rateur : d[cle] = valeur , ajouter une association cle: valeur dans d . accesseur : d[cle] , lire la valeur associ\u00e9e \u00e0 cle dans d . it\u00e9rateur : for cle in d , \u00e9num\u00e8rer toutes les cl\u00e9s de d . Exemple >>> dico = dict () >>> dico [ \"nom\" ] = \"Jannel\" >>> dico [ \"prenom\" ] = \"David\" >>> print ( f : \" {dico[\"nom\"]} {dico[\"prenom\"]} \" ) Jannel David La recherche dans un dictionnaire est optimis\u00e9e pour s'effectuer sur les cl\u00e9s et non sur les valeurs. Par exemple avec le dictionnaire que nous avons cr\u00e9\u00e9 pr\u00e9c\u00e9demment dans l'exemple, la commande \"Nom\" in dico renverra True alors que \"Jannel\" in dico renverra False . Dans un dictionnaire, les cl\u00e9s et les valeurs ne jouent donc pas du tout le m\u00eame r\u00f4le et ne sont pas interchangeables. 3.2 Tables de hachage et cl\u00e9s \u2693\ufe0e Une cl\u00e9 peut \u00eatre d'un autre type que cha\u00eene de caract\u00e8re, du moment que c'est un objet non mutable , c'est \u00e0 dire qui ne peut pas \u00eatre modifi\u00e9. Une cl\u00e9 ne peut pas \u00eatre une liste par exemple car une liste est un objet mutable que l'on peut modifier, par exemple au travers de la m\u00e9thode .append(). Regardons ce qui se passe si on essaye de d\u00e9finir une cl\u00e9 de type list pour un dictionnaire : >>> dico [[ 2 , 1 ]] = \"blablabla ...\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unhashable type : 'list' Le type list n'est pas pas hashable . Mais qu'est-ce que le hachage ? 3.3 Impl\u00e9mentation d'un type dictionnaire \u00e0 l'aide d'une table de hachage \u2693\ufe0e Pr\u00e9sentation du probl\u00e8me \u2693\ufe0e Ici on ne veut pas utiliser directement le type dict de Python. Une impl\u00e9mentation simple consiste \u00e0 cr\u00e9er une liste de tuples (cle, valeur) . Le probl\u00e8me de cette impl\u00e9mentation est dans l'efficacit\u00e9 de la recherche d'une cl\u00e9. On doit parcourir la totalit\u00e9 de la liste au pire des cas et donc la compl\u00e9xit\u00e9 est lin\u00e9aire O(n). Une impl\u00e9mentation plus efficace est donc de continuer \u00e0 utiliser un tableau et \u00e0 transformer la cl\u00e9 en un indice \u00e0 l'aide d'une fonction de hachage. \u00c7a a l'avantage de trouver directement une cl\u00e9 dans le tableau. La fonction de hachage transforme la cl\u00e9 en un indice et il suffit donc de lire la donn\u00e9e stock\u00e9e dans le tableau \u00e0 l'indice correspondant. La complexit\u00e9 de la recherche est donc O(1). Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier table_hachage_cours.py . La fonction de hachage \u2693\ufe0e Si on prend pour cl\u00e9 une chaine de caract\u00e8re, une fonction de hachage peut consister \u00e0 additionner le code ascii de chaque caract\u00e8re, modulo la taille du tableau. HTAILLE = 109 # taille de la table de hachage def hachage ( cle ): code = 0 for car in cle : code = code + ord ( car ) return code % HTAILLE Question Question R\u00e9ponse Quel soucis peut appa\u00eetre avec une telle fonction de hachage ? Il est possible que deux cl\u00e9s diff\u00e9rentes aient le m\u00eame code de hachage. On appelle cela une collision . Une m\u00e9thode pour traiter ces collisions, consiste \u00e0 stocker dans chaque \u00e9l\u00e9ment de la table de hachage, une liste des tuples (cle, valeur) qui on le m\u00eame code de hachage. C'est cette impl\u00e9mentation qui vous est propos\u00e9e ci-dessous. Vous pouvez tester la fonction en prenant HTAILLE = 7 et deux cl\u00e9s comme \"Alice\" et \"Bob\". La fonction renvoie 2 pour les deux cl\u00e9s. Le constructeur : Cr\u00e9ation du dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction creer_dico qui ne prend pas d'argument et qui renvoie un tableau contenant HTAILLE cases remplies avec None . def creer_dico (): return [ None ] * HTAILLE Un op\u00e9rateur : Ajouter une entr\u00e9e dans le dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction ajouter qui prend en arguments dico , cle et valeur et qui ajoute le couple (cle, valeur) dans le dictionnaire dico . Utiliser les op\u00e9rations sp\u00e9cifi\u00e9es dans l'interface des listes donn\u00e9es en cours. L'interface et ses op\u00e9rations doivent \u00eatre import\u00e9es dans votre fichier. Les entr\u00e9es de la table de hachage \u00e9tant des listes, il faut penser \u00e0 cr\u00e9er une nouvelle liste si elle n'existe pas avant d'ajouter le tuple au dictionnaire. def ajouter_cle ( dico , cle , valeur ): h = hachage ( cle ) if dico [ h ] == None : dico [ h ] = creer_liste () dico [ h ] = inserer (( cle , valeur ), dico [ h ]) return dico Un accesseur : lire la valeur associ\u00e9e \u00e0 un cl\u00e9 du dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction valeur_cle qui prend en arguments dico et cle . Et qui retourne la valeur associ\u00e9e \u00e0 la cl\u00e9 dans le dictionnaire dico . V\u00e9rifier que le r\u00e9sultat de la fonction de hachage, appliqu\u00e9e \u00e0 la cl\u00e9, correspond \u00e0 une liste sinon retourner None . La fonction elements_liste permet de r\u00e9cup\u00e9rer une liste de tous les tuples pr\u00e9sents dans une liste. def valeur_cle ( dico , cle ): h = hachage ( cle ) if dico [ h ] == None : return None else : for ( c , v ) in elements_liste ( dico [ h ]): if c == cle : return v return None Un it\u00e9rateur : lister les cl\u00e9s pr\u00e9sentes dans un dictionnaire \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction cle_dico qui prend en arguments dico . Et qui retourne la liste des cl\u00e9s pr\u00e9sentes dans le dictionnaire dico . La fonction doit retourner un tableau de cl\u00e9s. La fonction elements_liste permet de r\u00e9cup\u00e9rer une liste de tous les tuples (cle, valeur) pr\u00e9sents dans une liste. def cles_dico ( dico ): tab_cles = [] for h in range ( len ( dico )): if dico [ h ] != None : for ( c , v ) in elements_liste ( dico [ h ]): tab_cles . append ( c ) return tab_cles \u00c9tendre l'interface : \u2693\ufe0e L'objectif est d'ajouter une fonction permettant de connaitre le nombre d'\u00e9l\u00e9ments (couples) pr\u00e9sents dans le dictionnaire. Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction taille qui prend en arguments dico . Et qui retourne le nombre d'\u00e9l\u00e9ments pr\u00e9sents dans le dictionnaire dico . Une fa\u00e7on de proc\u00e9der est de compter le nombre de cl\u00e9s pr\u00e9sentes dans le tableau renvoy\u00e9 par l'it\u00e9rateur cle_dico . def taille ( dico ): return len ( cles_dico ( dico )) Utiliser l'interface : \u2693\ufe0e Cr\u00e9er une fonction moyenne qui retourne la moyenne des notes pr\u00e9sentes dans un dictionnaire ou les cl\u00e9s seraient des noms d'\u00e9l\u00e8ves et la valeur associ\u00e9e la note. Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction moyenne qui prend en arguments dico . Et qui retourne la moyenne des valeurs pr\u00e9sentes dans le dictionnaire dico . Tester si le dictionnaire n'est pas vide. Utiliser les fonctions cle_dico , valeur_cle et taille pour calculer la moyenne. def moyenne ( dico ): assert cles_dico ( dico ) != [], \"dictionnaire vide\" total = 0 for cle in cles_dico ( dico ): total = total + valeur_cle ( dico , cle ) return total / taille ( dico )","title":"CH3 Structures de donn\u00e9es - Listes et dictionnaires"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#ch3-structures-de-donnees-listes-et-dictionnaires","text":"Programme officiel Le langage Python dispose, comme tous les langages de haut niveau, d'un ensemble de types simples et de types structur\u00e9s vus dans le programme de premi\u00e8re : nombres, bool\u00e9ens, cha\u00eenes de caract\u00e8res, tuples, tableaux, dictionnaires ... Ces types de bases sont appell\u00e9s types concrets . Cette ann\u00e9e, comme nous allons manipuler des donn\u00e9es plus complexes que des simples nombres, on va cr\u00e9er des structures de donn\u00e9es plus complexes. Pour d\u00e9finir ces structures, on utilise des types abstraits de donn\u00e9es .","title":"CH3 : Structures de donn\u00e9es - Listes et dictionnaires"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#1-type-abstrait-de-donnees","text":"","title":"1. Type abstrait de donn\u00e9es"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#11-interface","text":"Un type abstrait est caract\u00e9ris\u00e9 par une interface de programmation . L'interface, c'est l'ensemble des op\u00e9rations ou primitives qui vont permettre de manipuler les donn\u00e9es. On distingue : - les constructeurs qui permettent de cr\u00e9er une nouvelle structure de donn\u00e9es. - les op\u00e9rateurs qui permettent de modifier la structure. On peut par exemple ajouter ou retirer des donn\u00e9es. - les accesseurs qui donnent des informations sur la structure. Par exemple, donner le nombre d'\u00e9l\u00e9ments dans la structure. - les it\u00e9rateurs qui permettent d'\u00e9num\u00e9rer les \u00e9l\u00e9ments de la structure.","title":"1.1 Interface"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#12-implementation","text":"Impl\u00e9menter un type abstrait, c'est coder les diff\u00e9rentes op\u00e9rations qui r\u00e9pondent \u00e0 sp\u00e9cification de l'interface. Il est possible de r\u00e9aliser plusieurs impl\u00e9mentations diff\u00e9rentes pour r\u00e9pondre \u00e0 la m\u00eame sp\u00e9cification. Certaines impl\u00e9mentation vont \u00eatre plus rapides, moins gourmandes en espace m\u00e9moire, plus adapt\u00e9es \u00e0 la taille des donn\u00e9es ... Du concret pour mieux comprendre : INTERFACE vs IMPL\u00c9MENTATION On peut choisir comme image une machine \u00e0 caf\u00e9 \u00e0 capsule, dans laquelle on peut distinguer : L'interface On distinge ici : les boutons, le levier, les petites lumi\u00e8res ... C'est la partie utilisateur . L'impl\u00e9mentation Sur ce sch\u00e9ma apparaissent : les \u00e9lectrovannes, la pompe, le bloc de chauffe, voire le d\u00e9roulement des op\u00e9rations ... C'est la partie constructeur . Pas besoin de savoir comment fonctionne la machine \u00e0 l'int\u00e9rieur (impl\u00e9mentation), pour se faire un caf\u00e9 (interface)... Dans notre programme de terminale, on va pr\u00e9senter plusieurs types abstraits comme : les listes (Ne pas confondre avec le type list de Python), les piles, les files ... On va apprendre \u00e0 utiliser ces types, puis on les impl\u00e9mentera de diff\u00e9rentes fa\u00e7on.","title":"1.2 Impl\u00e9mentation"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#13-exemple-des-tableaux","text":"En premi\u00e8re, on utilise des objets de type list pour manipuler des donn\u00e9es. Le type list est un type concret du langage Python. Par abus de langage on appelle cela des listes mais en fait ce sont des tableaux dynamiques . L'interface de ce type serait : Op\u00e9rations Exemple(s) complexit\u00e9 Constructeurs l = [] ou l = list() O(1) accesseurs len(l) O(1) l[i] O(1) op\u00e9rateurs l[i] = x O(1) l.append(x) O(1) l.insert(i, x) O(n) l.pop() O(1) del l[i] O(n) it\u00e9rateurs for elt in l O(n) Exercice 1 \u00c9nonc\u00e9 Solution Donner le contenu de la variable l apr\u00e8s avoir executer les instructions ci-dessous : >>> l = list () >>> l . append ( 4 ) >>> l . append ( 6 ) >>> l . insert ( 0 , 6 ) >>> l . pop () >>> l [ 0 ] = 2 >>> l . append ( 3 ) [ 2 , 4 , 3 ] L\u00e0 encore pas besoin de comprendre comment cela fonction. Il suffit juste d'utiliser l'interface.","title":"1.3 Exemple des tableaux"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#14-exemples-de-types-abstraits","text":"Voici les diff\u00e9rents types abstraits que l'on va \u00e9tudier cette ann\u00e9e. En informatique comme dans la vie courante, il est conseill\u00e9 d'adapter sa mani\u00e8re de stocker et de traiter des donn\u00e9es en fonction de la nature de celles-ci : Le serveur d'un caf\u00e9, charg\u00e9 de transporter les boissons du comptoir aux tables des clients, n'utilisera pas un sac en plastique pour faire le transport : il pr\u00e9f\u00e8rera un plateau. Le chercheur de champignons, lui, n'utilisera pas un plateau pour stocker ses trouvailles : il pr\u00e9f\u00e8rera un panier. Pour stocker des chaussettes, on pr\u00e9f\u00e8rera les entasser dans un tiroir (apr\u00e8s les avoir appair\u00e9es), plut\u00f4t que de les suspendre \u00e0 des cintres. De m\u00eame en informatique, pour chaque type de donn\u00e9es, pour chaque utilisation pr\u00e9vue, une structure particuli\u00e8re de donn\u00e9es se rev\u00e8lera (peut-\u00eatre) plus adapt\u00e9e qu'une autre. Int\u00e9ressons nous par exemple aux donn\u00e9es lin\u00e9aires . Ce sont des donn\u00e9es qui ne comportent pas de hi\u00e9rarchie : toutes les donn\u00e9es sont de la m\u00eame nature et ont le m\u00eame r\u00f4le. Par exemple, un relev\u00e9 mensuel de temp\u00e9ratures, la liste des \u00e9l\u00e8ves d'une classe, un historique d'op\u00e9rations bancaires... Ces donn\u00e9es sont \u00abplates\u00bb, n'ont pas de sous-domaines : la structure de liste para\u00eet parfaitement adapt\u00e9e. Lorsque les donn\u00e9es de cette liste sont en fait des couples (comme dans le cas d'une liste de noms/num\u00e9ros de t\u00e9l\u00e9phone), alors la structure la plus adapt\u00e9e est sans doute celle du dictionnaire . Les listes et les dictionnaires sont donc des exemples de structures de donn\u00e9es lin\u00e9aires .","title":"1.4 Exemples de types abstraits"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#2-les-listes","text":"","title":"2. Les listes"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#21-definitions-generales","text":"Une liste est un ensemble ordonn\u00e9 d'objets. G\u00e9n\u00e9ralement, ces donn\u00e9es seront de m\u00eame type, mais ce n'est pas structurellement obligatoire. Lorsque l'impl\u00e9mentation de la liste fait appara\u00eetre une cha\u00eene de valeurs, chacune pointant vers la suivante, on dit que la liste est une liste cha\u00een\u00e9e . L'interface minimale d'une liste est : constructeur : creer_liste() qui retourne une liste vide. accesseur : liste_vide(l) qui retourne True si la liste l est vide. op\u00e9rateur : inserer(e, l) qui ins\u00e8re l'\u00e9l\u00e9ment e dans la liste l et retourne une nouvelle liste. accesseur : tete(l) qui retourne l'\u00e9l\u00e9ment en t\u00eate de liste (si elle n'est pas vide). accesseur : queue(l) qui retourne la liste priv\u00e9e de son premier \u00e9l\u00e9ment (la t\u00eate)(si elle n'est pas vide). it\u00e9rateur : elements_liste(l) qui retourne un tableau contenant les \u00e9l\u00e9ments de la liste l , que l'on peut ensuite \u00e9num\u00e9rer avec une boucle for.","title":"2.1 D\u00e9finitions g\u00e9n\u00e9rales"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#22-exemple-dimplementation-par-des-tuples","text":"On peut impl\u00e9menter une liste en Python en utilisant des tuples. Une liste sera repr\u00e9sent\u00e9e par un tuple (tete, queue) . tete est le premier \u00e9l\u00e9ment de la liste et queue est le reste de la liste, qui est elle m\u00eame une liste. C'est r\u00e9cursif. On peut utiliser la liste de la mani\u00e8re suivante : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> liste = creer_liste () >>> liste = inserer ( \"Alice\" , liste ) >>> liste = inserer ( \"Bob\" , liste ) >>> liste = inserer ( \"Charlie\" , liste ) >>> print ( tete ( liste )) Charlie >>> print ( queue ( liste )) ( \"Bob\" , ( \"Alice\" , ())) >>> for elt in elements_liste ( liste ): print ( elt ) Charlie Bob Alice L'\u00e9tat de la liste apr\u00e8s la ligne 4 est : ( \"Charlie\" , ( \"Bob\" , ( \"Alice\" , ()))) Soit : Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier listes_cours.py .","title":"2.2 Exemple d'impl\u00e9mentation par des tuples"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#23-autre-implementation-et-utilisation-des-listes","text":"Travail \u00e0 r\u00e9aliser sur le notebook TD_listes.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 listes.py avec l'impl\u00e9mentation utilisant la POO.","title":"2.3 Autre impl\u00e9mentation et utilisation des listes"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#3-les-dictionnaires","text":"","title":"3. Les dictionnaires"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#31-tableau-associatif","text":"Les dictionnaires ont d\u00e9j\u00e0 \u00e9t\u00e9 \u00e9tudi\u00e9s en classe de premi\u00e8re. Pour rappel, ce type de donn\u00e9es, aussi appel\u00e9 tableau associatif , permet de stocker des valeurs et d'y acc\u00e9der au moyen d'une cl\u00e9 , contrairement au tableau qui permet d'acc\u00e9der \u00e0 une donn\u00e9e au moyen d'un indice . On parle d'association cl\u00e9: valeur . Le langage Python fournit directement le type structur\u00e9 dict qui impl\u00e9mente un dictionnaire. Constructeur : d = dict() ou d = {} , cr\u00e9ation d'un dictionnaire nomm\u00e9 d . op\u00e9rateur : d[cle] = valeur , ajouter une association cle: valeur dans d . accesseur : d[cle] , lire la valeur associ\u00e9e \u00e0 cle dans d . it\u00e9rateur : for cle in d , \u00e9num\u00e8rer toutes les cl\u00e9s de d . Exemple >>> dico = dict () >>> dico [ \"nom\" ] = \"Jannel\" >>> dico [ \"prenom\" ] = \"David\" >>> print ( f : \" {dico[\"nom\"]} {dico[\"prenom\"]} \" ) Jannel David La recherche dans un dictionnaire est optimis\u00e9e pour s'effectuer sur les cl\u00e9s et non sur les valeurs. Par exemple avec le dictionnaire que nous avons cr\u00e9\u00e9 pr\u00e9c\u00e9demment dans l'exemple, la commande \"Nom\" in dico renverra True alors que \"Jannel\" in dico renverra False . Dans un dictionnaire, les cl\u00e9s et les valeurs ne jouent donc pas du tout le m\u00eame r\u00f4le et ne sont pas interchangeables.","title":"3.1 tableau associatif"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#32-tables-de-hachage-et-cles","text":"Une cl\u00e9 peut \u00eatre d'un autre type que cha\u00eene de caract\u00e8re, du moment que c'est un objet non mutable , c'est \u00e0 dire qui ne peut pas \u00eatre modifi\u00e9. Une cl\u00e9 ne peut pas \u00eatre une liste par exemple car une liste est un objet mutable que l'on peut modifier, par exemple au travers de la m\u00e9thode .append(). Regardons ce qui se passe si on essaye de d\u00e9finir une cl\u00e9 de type list pour un dictionnaire : >>> dico [[ 2 , 1 ]] = \"blablabla ...\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unhashable type : 'list' Le type list n'est pas pas hashable . Mais qu'est-ce que le hachage ?","title":"3.2 Tables de hachage et cl\u00e9s"},{"location":"Structures%20de%20donn%C3%A9es/CH3_TDA/cours/#33-implementation-dun-type-dictionnaire-a-laide-dune-table-de-hachage","text":"","title":"3.3 Impl\u00e9mentation d'un type dictionnaire \u00e0 l'aide d'une table de hachage"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/","text":"CH4 : Piles et files \u2693\ufe0e Programme officiel 1. Les piles \u2693\ufe0e 1.1 Qu'est ce qu'une pile ? \u2693\ufe0e Une structure de pile (penser \u00e0 une pile d'assiette) est associ\u00e9e \u00e0 la m\u00e9thode LIFO (Last In, First Out) : les \u00e9l\u00e9ments sont empil\u00e9s les uns au-dessus des autres, et on ne peut toujours d\u00e9piler que l'\u00e9l\u00e9ment du haut de la pile. Le dernier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 \u00eatre sorti. Son interface minimale est : creer_pile() : constructeur qui retourne une pile vide. pile_vide(p) : accesseur qui retourne Vrai si la pile p est vide. empiler(e, p) : op\u00e9rateur qui ajoute l'\u00e9l\u00e9ment e au sommet de la pile p. depiler(p) : op\u00e9rateur qui retire et retourne le sommet de la pile p (si elle n'est pas vide). sommet(p) : accesseur qui retourne le sommet de la pile p (si elle n'est pas vide). elements_pile(p) : it\u00e9rateur qui \u00e9num\u00e8re les \u00e9l\u00e9ments contenus dans la pile p. Exercice : Utilisation de l'interface \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la pile p et la valeur \u00e9ventuellement renvoy\u00e9e. 1. p = creer_pile () 2. p = empiler ( 3 , p ) 3. p = empiler ( 5 , p ) 4. pile_vide ( p ) 4. p = empiler ( 1 , p ) 5. depiler ( p ) 6. depiler ( p ) 7. p = empiler ( 9 , p ) 8. depiler ( p ) 9. depiler ( p ) 10. pile_vide ( p ) 1. p = None # \u00e0 ce stade on a aucune connaissance de l'impl\u00e9mentation utilis\u00e9e 2. p = 3 3. p = 3 , 5 4. Faux 4. p = 3 , 5 , 1 5. p = 3 , 5 et on renvoie 1 6. p = 3 et on renvoie 5 7. p = 3 , 9 8. p = 3 et on renvoie 9 9. p = None et on renvoie 3 10. Vrai 1.2 Exemples d'utilisation de piles en informatique \u2693\ufe0e lors de l'ex\u00e9cution d'une fonction r\u00e9cursive, le processeur empile successivement les appels \u00e0 traiter : seule l'instruction du haut de la pile peut \u00eatre trait\u00e9e. dans un navigateur internet, la liste des pages parcourues est stock\u00e9e sous forme de pile : la fonction \u00abBack\u00bb permet de \u00abd\u00e9piler\u00bb peu \u00e0 peu les pages pr\u00e9c\u00e9demment parcourues : 1.3 Exemple d'impl\u00e9mentation \u2693\ufe0e Une impl\u00e9mentation possible consiste \u00e0 utiliser les tableaux dynamiques (type list de Python). Pour r\u00e9aliser notre impl\u00e9mentation, on utilisera les m\u00e9thodes append , pop ... Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier piles_cours.py . Le constructeur : cr\u00e9ation de la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction creer_pile qui ne prend pas d'argument et qui renvoie un tableau vide (type list ). def creer_pile (): return [] Un accesseur : savoir si la pile est vide \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction pile_vide qui prend en argument une pile et qui renvoie True si la pile est vide. def pile_vide ( pile ): return pile == [] Un op\u00e9rateur : ajout d'un \u00e9l\u00e9ment au sommet de la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction empiler qui prend en argument un \u00e9l\u00e9ment et une liste et place cet \u00e9l\u00e9ment au sommet de la pile. La fonction ne renvoie rien. C'est une proc\u00e9dure. def empiler ( elt , pile ): pile . append ( elt ) Un op\u00e9rateur : retirer un \u00e9l\u00e9ment du sommet de la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction depiler qui prend en argument une pile, retire et retourne le sommet de la pile p (si elle n'est pas vide). V\u00e9rifier que la pile pass\u00e9e en argument n'est pas vide avec un assert . def depiler ( pile ): assert not pile_vide ( pile ), \"pile vide\" sommet = pile . pop () return sommet Un accesseur : Conna\u00eetre le sommet de la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction sommet qui prend en argument une pile et renvoie simplement l'\u00e9l\u00e9ment situ\u00e9 au sommet de la pile (si elle n'est pas vide). V\u00e9rifier que la pile pass\u00e9e en argument n'est pas vide avec un assert . La pile ne doit pas \u00eatre modifi\u00e9e. def sommet ( pile ): assert not pile_vide ( pile ), \"pile vide\" return pile [ - 1 ] Un it\u00e9rateur : lister les \u00e9l\u00e9ments pr\u00e9sents dans la pile \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction elements_pile qui prend en argument une pile et qui renvoie un tableau contenant les \u00e9l\u00e9ments de la pile. Attention, le tableau doit contenir les \u00e9l\u00e9ments parcourus du sommet \u00e0 la base de la pile. Vous pouvez regarder la documentation de la fonction range ( help(range) ). def elements_pile ( pile ): tab_elt = [] for i in range ( len ( pile ) - 1 , - 1 , - 1 ): tab_elt . append ( pile [ i ]) return tab_elt \u00c9tendre l'interface \u2693\ufe0e On peut ajouter un accesseur taille qui retourne le nombre d'\u00e9l\u00e9ments de la pile. Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction taille qui prend en argument une pile et qui renvoie le nombre d'\u00e9l\u00e9ments de la pile. def taille ( pile ): return len ( pile ) 1.4 TD - Impl\u00e9mentation utilisant la POO et utilisation des piles \u2693\ufe0e Travail \u00e0 r\u00e9aliser sur le notebook TD_piles.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 piles.py avec l'impl\u00e9mentation utilisant la POO. 1.5 TP - R\u00e9alisation d'une calculatrice \u2693\ufe0e Dans les ann\u00e9es 90, les calculatrices HP \u00e9taient tr\u00e8s r\u00e9put\u00e9es dans le milieu scientifique pour la richesse de leures fonctionnalit\u00e9s. Elles poss\u00e9daient une autre particularit\u00e9 : elles utilisaient la notation dite \"polonaise invers\u00e9e\" NPI pour effectuer les calculs. Cela signifie que l'on entrait d'abord les \u00e9l\u00e9ments pour faire le calcul puis ensuite l'op\u00e9rateur. Par exemple, pour effectuer l'op\u00e9ration 4 + 3 on entrait successivement 4 puis 3 et enfin +. On peut donner encore d'autres exemples : pour calculer (2+3)*11 , on entrera la chaine de caract\u00e8re \" 2 3 + 11 * \". On aurait d'ailleurs le m\u00eame r\u00e9sultat avec la chaine de caract\u00e8re \" 11 2 3 + * \" qui repr\u00e9senterait 11*(2+3) . L'algorithme pour calculer le r\u00e9sultat d'un calcul en notation polonaise invers\u00e9 utilise une pile. On proc\u00e9de de la fa\u00e7on suivante. Pour chaque \u00e9l\u00e9ment de l'expression : si c'est un nombre on le place dans la pile. si c'est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux nombres au sommet de la pile et on leur applique l'op\u00e9rateur (le premier sommet est \u00e0 droite de l'op\u00e9rateur, ce qui est important pour les soustractions et les divisions). Vous allez r\u00e9aliser une calculatrice NPI \u00e0 partir de la classe de pile que nous avons fait pr\u00e9cedemment. Travail \u00e0 faire Consignes Code \u00e0 compl\u00e9ter Pour faire une calculatrice NPI, vous compl\u00e9terez la fonction calcule qui prend en entr\u00e9e une chaine de caract\u00e8re not\u00e9e expression qui est une expression en notation polonaise invers\u00e9e, et qui renvoi en sortie la valeur du r\u00e9sultat. Si la chaine est bien form\u00e9e, la pile ne contient plus qu'un seul \u00e9l\u00e9ment qui est le r\u00e9sultat. Si la chaine est mal form\u00e9e, la fonction doit renvoyer None . Pour faciliter votre travail, la chaine est s\u00e9par\u00e9e en \u00e9lements dans un tableau gr\u00e2ce \u00e0 split, et il n'y a plus qu'\u00e0 boucler sur le tableau. Des assertions ont \u00e9t\u00e9 fournies pour vous aider \u00e0 v\u00e9rifier votre travail. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class cellule : \"\"\" Classe qui mod\u00e9lise une cellule dans une structure lin\u00e9aire \"\"\" def __init__ ( self , element ): self . contenu = element self . suivant = None class pile : \"\"\" Classe qui impl\u00e9mente une pile\"\"\" def __init__ ( self ): self . sommet = None def estVide ( self ): return self . sommet == None def empile ( self , element ): nouveau = cellule ( element ) nouveau . suivant = self . sommet self . sommet = nouveau def depile ( self ): valeur = self . sommet . contenu self . sommet = self . sommet . suivant return valeur def affiche ( self ): pointeur = self . sommet while pointeur != None : print ( pointeur . contenu ) pointeur = pointeur . suivant def calcule ( expression ): valeur = None tableau = expression . split () ### Mettez votre code ici return valeur assert calcule ( '2 3 + 11 *' ) == 55 , \"erreur sur le premier calcul\" assert calcule ( '2 5 * 7 +' ) == 17 , \"erreur sur le second calcul\" assert calcule ( '8 2 / 4 - ' ) == 0 , \"erreur sur le troisi\u00e8me calcul\" assert calcule ( '1 2 3 4 + * +' ) == 15 , \"erreur sur le quatri\u00e8me calcul\" assert calcule ( \"1 2 3 + \" ) == None , \" chaine mal form\u00e9e mais valeur retourn\u00e9e\" 2. Les files \u2693\ufe0e Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier files_cours.py . 2.1 Qu'est ce qu'une file ? \u2693\ufe0e Une structure de file (penser \u00e0 une file d'attente) est associ\u00e9e \u00e0 la m\u00e9thode FIFO (First In, First Out) : les \u00e9l\u00e9ments sont enfil\u00e9s les uns \u00e0 la suite des autres, et on ne peut toujours d\u00e9filer que l'\u00e9l\u00e9ment en t\u00eate de la file. Le premier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 en sortir. Sinon \u00e7a r\u00e2le dans la file d'attente. Son interface minimale est : creer_file : constructeur qui retourne une file vide. file_vide(f) : accesseur qui retourne vrai si la file f est vide. enfiler(e, f) : op\u00e9rateur qui ajoute l'\u00e9l\u00e9ment e \u00e0 la fin de la file f. defiler(f) : op\u00e9rateur qui retire l'\u00e9l\u00e9ment plac\u00e9 en t\u00eate de file (si elle n'est pas vide). tete_file(f) : accesseur qui retourne l'\u00e9l\u00e9ment plac\u00e9 en t\u00eate de la file f (si elle n'est pas vide). elements_file(f) : it\u00e9rateur qui \u00e9num\u00e8re les \u00e9l\u00e9ments de la file f. Exercice : Utilisation de l'interface \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la file f et la valeur \u00e9ventuellement renvoy\u00e9e. La convention choisie est : on enfilera \u00e0 droite et on d\u00e9filera \u00e0 gauche . 1. f = creer_file () 2. enfiler ( 3 , f ) 3. enfiler ( 5 , f ) 4. file_vide ( f ) 5. enfiler ( 1 , f ) 6. defiler ( f ) 7. defile ( f ) 8. enfiler ( 9 , f ) 9. defiler ( f ) 10. defiler ( f ) 11. file_vide ( f ) 1. f = # d\u00e9pend de l'impl\u00e9mentation utilis\u00e9e 2. f = 3 3. f = 3 , 5 4. faux 5. f = 3 , 5 , 1 6. valeur renvoy\u00e9e : 3 , f = 5 , 1 7. valeur renvoy\u00e9e : 5 , f = 1 8. f = 1 , 9 9. valeur renvoy\u00e9e : 1 , f = 9 10. valeur renvoy\u00e9e : 9 , f = 11. vrai 2.2 Exemples d'utilisation de files en informatique \u2693\ufe0e Serveurs d'impression : Spoolers qui traitent ainsi les requ\u00eates dans l'ordre dans lequel elles arrivent, et les ins\u00e8rent dans une file d'attente (dite aussi queue ou spool ). Certains moteurs multit\u00e2ches dans un OS , qui doivent accorder du temps-machine \u00e0 chaque t\u00e2che, sans en privil\u00e9gier aucune. 2.3 Exemple d'impl\u00e9m\u00e9ntation \u2693\ufe0e Comme pour les piles, une impl\u00e9mentation possible consiste \u00e0 utiliser les tableaux dynamiques (type list de Python). Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier files_cours.py . Le constructeur : cr\u00e9ation de la file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction creer_file qui ne prend pas d'argument et qui renvoie un tableau vide (type list ). def creer_file (): return [] Un accesseur : savoir si la file est vide \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction file_vide qui prend en argument une file et qui renvoie True si la file est vide. def file_vide ( file ): return file == [] Un op\u00e9rateur : ajout d'un \u00e9l\u00e9ment en queue de file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction enfiler qui prend en argument un \u00e9l\u00e9ment et une liste et place cet \u00e9l\u00e9ment en queue de file. La fonction ne renvoie rien. C'est une proc\u00e9dure. def enfiler ( elt , file ): file . append ( elt ) Un op\u00e9rateur : retirer un \u00e9l\u00e9ment de la file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction defiler qui prend en argument une file, retire et retourne la t\u00eate de la file f (si elle n'est pas vide). V\u00e9rifier que la file pass\u00e9e en argument n'est pas vide avec un assert . def defiler ( file ): assert not file_vide ( file ), \"file vide\" tete = file . pop ( 0 ) return tete Un accesseur : Conna\u00eetre la tete de la file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aides Solution Cr\u00e9er une fonction tete_file qui prend en argument une file et renvoie simplement l'\u00e9l\u00e9ment situ\u00e9 en t\u00eate de la file (si elle n'est pas vide). V\u00e9rifier que la file pass\u00e9e en argument n'est pas vide avec un assert . La file ne doit pas \u00eatre modifi\u00e9e. def tete_file ( file ): assert not file_vide ( file ), \"file vide\" return file [ 0 ] Un it\u00e9rateur : lister les \u00e9l\u00e9ments pr\u00e9sents dans la file \u2693\ufe0e Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction elements_file qui prend en argument une file et qui renvoie un tableau contenant les \u00e9l\u00e9ments de la file. Attention, le tableau doit contenir les \u00e9l\u00e9ments parcourus de la queue \u00e0 la t\u00eate de la file. def elements_file ( file ): return file \u00c9tendre l'interface \u2693\ufe0e On peut ajouter un accesseur taille qui retourne le nombre d'\u00e9l\u00e9ments de la file. Exercice \u00c9nonc\u00e9 Solution Cr\u00e9er une fonction taille qui prend en argument une file et qui renvoie le nombre d'\u00e9l\u00e9ments de la file. def taille ( file ): return len ( file ) 2.4 TD - Impl\u00e9mentation utilisant la POO et utilisation des files \u2693\ufe0e Travail \u00e0 r\u00e9aliser \u00e0 partir du TD_files.pdf en cr\u00e9ant un notebook not\u00e9 : TD_files.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 files.py avec l'impl\u00e9mentation utilisant la POO.","title":"CH4 Piles et files"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#ch4-piles-et-files","text":"Programme officiel","title":"CH4 : Piles et files"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#1-les-piles","text":"","title":"1. Les piles"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#11-quest-ce-quune-pile","text":"Une structure de pile (penser \u00e0 une pile d'assiette) est associ\u00e9e \u00e0 la m\u00e9thode LIFO (Last In, First Out) : les \u00e9l\u00e9ments sont empil\u00e9s les uns au-dessus des autres, et on ne peut toujours d\u00e9piler que l'\u00e9l\u00e9ment du haut de la pile. Le dernier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 \u00eatre sorti. Son interface minimale est : creer_pile() : constructeur qui retourne une pile vide. pile_vide(p) : accesseur qui retourne Vrai si la pile p est vide. empiler(e, p) : op\u00e9rateur qui ajoute l'\u00e9l\u00e9ment e au sommet de la pile p. depiler(p) : op\u00e9rateur qui retire et retourne le sommet de la pile p (si elle n'est pas vide). sommet(p) : accesseur qui retourne le sommet de la pile p (si elle n'est pas vide). elements_pile(p) : it\u00e9rateur qui \u00e9num\u00e8re les \u00e9l\u00e9ments contenus dans la pile p. Exercice : Utilisation de l'interface \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la pile p et la valeur \u00e9ventuellement renvoy\u00e9e. 1. p = creer_pile () 2. p = empiler ( 3 , p ) 3. p = empiler ( 5 , p ) 4. pile_vide ( p ) 4. p = empiler ( 1 , p ) 5. depiler ( p ) 6. depiler ( p ) 7. p = empiler ( 9 , p ) 8. depiler ( p ) 9. depiler ( p ) 10. pile_vide ( p ) 1. p = None # \u00e0 ce stade on a aucune connaissance de l'impl\u00e9mentation utilis\u00e9e 2. p = 3 3. p = 3 , 5 4. Faux 4. p = 3 , 5 , 1 5. p = 3 , 5 et on renvoie 1 6. p = 3 et on renvoie 5 7. p = 3 , 9 8. p = 3 et on renvoie 9 9. p = None et on renvoie 3 10. Vrai","title":"1.1 Qu'est ce qu'une pile ?"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#12-exemples-dutilisation-de-piles-en-informatique","text":"lors de l'ex\u00e9cution d'une fonction r\u00e9cursive, le processeur empile successivement les appels \u00e0 traiter : seule l'instruction du haut de la pile peut \u00eatre trait\u00e9e. dans un navigateur internet, la liste des pages parcourues est stock\u00e9e sous forme de pile : la fonction \u00abBack\u00bb permet de \u00abd\u00e9piler\u00bb peu \u00e0 peu les pages pr\u00e9c\u00e9demment parcourues :","title":"1.2 Exemples d'utilisation de piles en informatique"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#13-exemple-dimplementation","text":"Une impl\u00e9mentation possible consiste \u00e0 utiliser les tableaux dynamiques (type list de Python). Pour r\u00e9aliser notre impl\u00e9mentation, on utilisera les m\u00e9thodes append , pop ... Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier piles_cours.py .","title":"1.3 Exemple d'impl\u00e9mentation"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#14-td-implementation-utilisant-la-poo-et-utilisation-des-piles","text":"Travail \u00e0 r\u00e9aliser sur le notebook TD_piles.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 piles.py avec l'impl\u00e9mentation utilisant la POO.","title":"1.4 TD - Impl\u00e9mentation utilisant la POO et utilisation des piles"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#15-tp-realisation-dune-calculatrice","text":"Dans les ann\u00e9es 90, les calculatrices HP \u00e9taient tr\u00e8s r\u00e9put\u00e9es dans le milieu scientifique pour la richesse de leures fonctionnalit\u00e9s. Elles poss\u00e9daient une autre particularit\u00e9 : elles utilisaient la notation dite \"polonaise invers\u00e9e\" NPI pour effectuer les calculs. Cela signifie que l'on entrait d'abord les \u00e9l\u00e9ments pour faire le calcul puis ensuite l'op\u00e9rateur. Par exemple, pour effectuer l'op\u00e9ration 4 + 3 on entrait successivement 4 puis 3 et enfin +. On peut donner encore d'autres exemples : pour calculer (2+3)*11 , on entrera la chaine de caract\u00e8re \" 2 3 + 11 * \". On aurait d'ailleurs le m\u00eame r\u00e9sultat avec la chaine de caract\u00e8re \" 11 2 3 + * \" qui repr\u00e9senterait 11*(2+3) . L'algorithme pour calculer le r\u00e9sultat d'un calcul en notation polonaise invers\u00e9 utilise une pile. On proc\u00e9de de la fa\u00e7on suivante. Pour chaque \u00e9l\u00e9ment de l'expression : si c'est un nombre on le place dans la pile. si c'est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux nombres au sommet de la pile et on leur applique l'op\u00e9rateur (le premier sommet est \u00e0 droite de l'op\u00e9rateur, ce qui est important pour les soustractions et les divisions). Vous allez r\u00e9aliser une calculatrice NPI \u00e0 partir de la classe de pile que nous avons fait pr\u00e9cedemment. Travail \u00e0 faire Consignes Code \u00e0 compl\u00e9ter Pour faire une calculatrice NPI, vous compl\u00e9terez la fonction calcule qui prend en entr\u00e9e une chaine de caract\u00e8re not\u00e9e expression qui est une expression en notation polonaise invers\u00e9e, et qui renvoi en sortie la valeur du r\u00e9sultat. Si la chaine est bien form\u00e9e, la pile ne contient plus qu'un seul \u00e9l\u00e9ment qui est le r\u00e9sultat. Si la chaine est mal form\u00e9e, la fonction doit renvoyer None . Pour faciliter votre travail, la chaine est s\u00e9par\u00e9e en \u00e9lements dans un tableau gr\u00e2ce \u00e0 split, et il n'y a plus qu'\u00e0 boucler sur le tableau. Des assertions ont \u00e9t\u00e9 fournies pour vous aider \u00e0 v\u00e9rifier votre travail. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class cellule : \"\"\" Classe qui mod\u00e9lise une cellule dans une structure lin\u00e9aire \"\"\" def __init__ ( self , element ): self . contenu = element self . suivant = None class pile : \"\"\" Classe qui impl\u00e9mente une pile\"\"\" def __init__ ( self ): self . sommet = None def estVide ( self ): return self . sommet == None def empile ( self , element ): nouveau = cellule ( element ) nouveau . suivant = self . sommet self . sommet = nouveau def depile ( self ): valeur = self . sommet . contenu self . sommet = self . sommet . suivant return valeur def affiche ( self ): pointeur = self . sommet while pointeur != None : print ( pointeur . contenu ) pointeur = pointeur . suivant def calcule ( expression ): valeur = None tableau = expression . split () ### Mettez votre code ici return valeur assert calcule ( '2 3 + 11 *' ) == 55 , \"erreur sur le premier calcul\" assert calcule ( '2 5 * 7 +' ) == 17 , \"erreur sur le second calcul\" assert calcule ( '8 2 / 4 - ' ) == 0 , \"erreur sur le troisi\u00e8me calcul\" assert calcule ( '1 2 3 4 + * +' ) == 15 , \"erreur sur le quatri\u00e8me calcul\" assert calcule ( \"1 2 3 + \" ) == None , \" chaine mal form\u00e9e mais valeur retourn\u00e9e\"","title":"1.5 TP - R\u00e9alisation d'une calculatrice"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#2-les-files","text":"Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier files_cours.py .","title":"2. Les files"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#21-quest-ce-quune-file","text":"Une structure de file (penser \u00e0 une file d'attente) est associ\u00e9e \u00e0 la m\u00e9thode FIFO (First In, First Out) : les \u00e9l\u00e9ments sont enfil\u00e9s les uns \u00e0 la suite des autres, et on ne peut toujours d\u00e9filer que l'\u00e9l\u00e9ment en t\u00eate de la file. Le premier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 en sortir. Sinon \u00e7a r\u00e2le dans la file d'attente. Son interface minimale est : creer_file : constructeur qui retourne une file vide. file_vide(f) : accesseur qui retourne vrai si la file f est vide. enfiler(e, f) : op\u00e9rateur qui ajoute l'\u00e9l\u00e9ment e \u00e0 la fin de la file f. defiler(f) : op\u00e9rateur qui retire l'\u00e9l\u00e9ment plac\u00e9 en t\u00eate de file (si elle n'est pas vide). tete_file(f) : accesseur qui retourne l'\u00e9l\u00e9ment plac\u00e9 en t\u00eate de la file f (si elle n'est pas vide). elements_file(f) : it\u00e9rateur qui \u00e9num\u00e8re les \u00e9l\u00e9ments de la file f. Exercice : Utilisation de l'interface \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la file f et la valeur \u00e9ventuellement renvoy\u00e9e. La convention choisie est : on enfilera \u00e0 droite et on d\u00e9filera \u00e0 gauche . 1. f = creer_file () 2. enfiler ( 3 , f ) 3. enfiler ( 5 , f ) 4. file_vide ( f ) 5. enfiler ( 1 , f ) 6. defiler ( f ) 7. defile ( f ) 8. enfiler ( 9 , f ) 9. defiler ( f ) 10. defiler ( f ) 11. file_vide ( f ) 1. f = # d\u00e9pend de l'impl\u00e9mentation utilis\u00e9e 2. f = 3 3. f = 3 , 5 4. faux 5. f = 3 , 5 , 1 6. valeur renvoy\u00e9e : 3 , f = 5 , 1 7. valeur renvoy\u00e9e : 5 , f = 1 8. f = 1 , 9 9. valeur renvoy\u00e9e : 1 , f = 9 10. valeur renvoy\u00e9e : 9 , f = 11. vrai","title":"2.1 Qu'est ce qu'une file ?"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#22-exemples-dutilisation-de-files-en-informatique","text":"Serveurs d'impression : Spoolers qui traitent ainsi les requ\u00eates dans l'ordre dans lequel elles arrivent, et les ins\u00e8rent dans une file d'attente (dite aussi queue ou spool ). Certains moteurs multit\u00e2ches dans un OS , qui doivent accorder du temps-machine \u00e0 chaque t\u00e2che, sans en privil\u00e9gier aucune.","title":"2.2 Exemples d'utilisation de files en informatique"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#23-exemple-dimplementation","text":"Comme pour les piles, une impl\u00e9mentation possible consiste \u00e0 utiliser les tableaux dynamiques (type list de Python). Les diff\u00e9rentes \u00e9tapes de l'impl\u00e9mentation de l'interface sont \u00e0 r\u00e9aliser en compl\u00e9tant le fichier files_cours.py .","title":"2.3 Exemple d'impl\u00e9m\u00e9ntation"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/cours/#24-td-implementation-utilisant-la-poo-et-utilisation-des-files","text":"Travail \u00e0 r\u00e9aliser \u00e0 partir du TD_files.pdf en cr\u00e9ant un notebook not\u00e9 : TD_files.ypnb Il vous est conseill\u00e9 de faire et conserver un fichier (module) nomm\u00e9 files.py avec l'impl\u00e9mentation utilisant la POO.","title":"2.4 TD - Impl\u00e9mentation utilisant la POO et utilisation des files"},{"location":"Structures%20de%20donn%C3%A9es/CH4_piles_files/exercices/","text":"","title":"Exercices"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/","text":"CH7 : Les graphes \u2693\ufe0e Programme officiel 1. Qu'est ce qu'un graphe ? \u2693\ufe0e 1.1 Des exemples de graphes \u2693\ufe0e Le graphe est une structure de donn\u00e9es tr\u00e8s utilis\u00e9e pour repr\u00e9senter les liens et les interactions entre des objets, les personnes, les villes, les ordinateurs ... En effet, nous verrons qu'il existe de nombreuses vari\u00e9t\u00e9s de graphes permettant ainsi de d\u00e9crire des situations diverses, tout en conservant, une m\u00eame repr\u00e9sentation et donc des m\u00eames m\u00e9thodes pour les manipuler par informatique. Exemple 1 : Le r\u00e9seau social Exemple 2 : Le r\u00e9seau routier Exemple 3 : R\u00e9seau informatique 1.2 D\u00e9finition \u2693\ufe0e D\u00e9finition Un graphe G est une structure de donn\u00e9es non lin\u00e9aire compos\u00e9e d'objets: les sommets , not\u00e9s V comme vertex ou vertice , dans laquelle certaines paires d'objets sont reli\u00e9es. des ar\u00eates , not\u00e9es E comme edge , reliant les sommets. Exemple : V = {A; B; C} et E = {(A, B); (A, C); C} G = (V , E) est un graphe de sommets A, B et C o\u00f9 A et B sont reli\u00e9s, A et C sont reli\u00e9s, et C est connect\u00e9 \u00e0 lui-m\u00eame. 1.3 Repr\u00e9sentation sagitale d'un graphe \u2693\ufe0e La repr\u00e9sentation sagittale d\u2019un graphe G = (V , E) est un sch\u00e9ma o\u00f9 les \u00e9l\u00e9ments de V (sommets) sont repr\u00e9sent\u00e9s par des disques et o\u00f9 les \u00e9l\u00e9ments de E (ar\u00eates) sont repr\u00e9sent\u00e9s par des traits. Exemple : Repr\u00e9sentation du graphe G = {V = {A; B; C} ; E = {(A, B); (A, C); C}} Remarque Aucune r\u00e8gle dicte la fa\u00e7on dont il faut disposer les ar\u00eates relient les sommets. Les deux repr\u00e9sentations du graphe ci-dessous sont identiques. 2. Vocabulaire sur les graphes \u2693\ufe0e 2.1 Graphes non-orient\u00e9s, orient\u00e9s, pond\u00e9r\u00e9s \u2693\ufe0e Graphes non orient\u00e9s et orient\u00e9s \u2693\ufe0e \u00c0 savoir On distingue les graphes non orient\u00e9s, o\u00f9 les ar\u00eates relient deux sommets de mani\u00e8re sym\u00e9trique et les graphes orient\u00e9s, o\u00f9 les ar\u00eates, alors appel\u00e9s arcs, relient deux sommets de mani\u00e8re asym\u00e9trique. Graphes pond\u00e9r\u00e9s \u2693\ufe0e \u00c0 savoir On dit qu\u2019un graphe est pond\u00e9r\u00e9 quand ses ar\u00eates ou ses arcs sont coupl\u00e9s avec des nombres. Ces nombres sont appel\u00e9s des poids. Exemple : Parcours d\u2019un livreur : les ar\u00eates repr\u00e9sentent le temps qu\u2019il met pour aller d\u2019un sommet \u00e0 l\u2019autre. 2.2 Complexit\u00e9 et morphologie \u2693\ufe0e Voici du vocabulaire pour qu'on puisse tous parler de la m\u00eame chose. ordre \u2693\ufe0e \u00c0 savoir L' ordre d'un graphe correspond au nombre de ses sommets. taille \u2693\ufe0e \u00c0 savoir La taille est le nombre de ses ar\u00eates ou arcs. degr\u00e9 \u2693\ufe0e \u00c0 savoir Le degr\u00e9 d'un sommet est le nombre d'ar\u00eates qui relient ce sommet \u00e0 d'autres sommets. Remarque Pour un graphe orient\u00e9, le degr\u00e9 entrant d'un sommet est le nombre d'arcs entrants et le degr\u00e9 sortant est le nombre d'arcs sortants. densit\u00e9 \u2693\ufe0e \u00c0 conna\u00eetre La densit\u00e9 D d'un graphe est une indication de sa connectivit\u00e9 et indique s'il y a beaucoup ou peu d'ar\u00eates. \\(D = \\dfrac{E}{V \\times (V-1)}\\) pour un graphe non orient\u00e9. \\(D = \\dfrac{2 \\times E}{V \\times (V-1)}\\) pour un graphe orient\u00e9. Remarque D = 1 pour un graphe complet et 0 pour un graphe sans aucune ar\u00eate. Plus D se rapproche de 1 et plus le graphe est dense. Et plus D se rapproche de 0, plus le graphe est creux. sommets adjacents \u2693\ufe0e \u00c0 savoir Deux sommets reli\u00e9s par une ar\u00eate sont dits adjacents. Remarques Dans un graphe non orient\u00e9, lorsque deux sommets sont adjacents, on dit qu'ils sont voisins . Dans un graphe orient\u00e9, on parle de successeurs (sommet d'arriv\u00e9e) et de pr\u00e9d\u00e9cesseurs (sommet de d\u00e9part). cha\u00eene ou chemin \u2693\ufe0e \u00c0 savoir Une cha\u00eene est une s\u00e9quence d'ar\u00eates cons\u00e9cutives dans un graphe non-orient\u00e9. Dans un graphe orient\u00e9 on parle de chemin . simple \u2693\ufe0e \u00c0 connaitre Un graphe est dit simple si il ne peut y avoir au plus qu'une ar\u00eate entre deux sommets (ou au plus un arc dans le m\u00eame sens pour un graphe orient\u00e9). Par exemple un compte Twitter est un graphe orient\u00e9 ou un compte ne peut pas suivre plusieyr fois le m\u00eame compte. Remarque Dans le cas contraire on parle de multi-graphe . On peut imaginer un graphe routier dans lequel deux villes peuvent \u00eatre reli\u00e9es par deux trajets diff\u00e9rents (poids diff\u00e9rents car distances \u00e0 parcourir diff\u00e9rentes) ou moyens de transport diff\u00e9rents (voiture, train ...). cyclique \u2693\ufe0e \u00c0 connaitre Un graphe est dit cyclique s\u2019il existe une cha\u00eene ou un chemin reliant n\u2019importe quel sommet \u00e0 lui-m\u00eame. Exemple : Une chaine par exemple : 1 - 4 - 5 - 2 - 1. On a bien existence d'un cycle. connexe \u2693\ufe0e \u00c0 connaitre Un graphe est dit connexe si ses sommets peuvent \u00eatre reli\u00e9s deux \u00e0 deux par une ar\u00eate ou un arc. Exemple : complet \u2693\ufe0e \u00c0 connaitre Un graphe est dit complet si deux sommets quelconques sont adjacents (reli\u00e9s par une ar\u00eate). Exemple : 3. Les graphes en programmation \u2693\ufe0e 3.1 Liste d'adjacence \u2693\ufe0e \u00c0 savoir La liste d'adjacence d'un graphe, est la liste des voisins (sommets adjacents de destination) de chaque sommet. Exemple : Liste d'adjacence du graphe : (1 -> (1; 4); 2 -> (1; 3; 4); 3 -> (4); 4 -> (3)) Remarques Lorsque le graphe est non orient\u00e9, la liste d'adjacence est une liste de voisins Lorsque le graphe est orient\u00e9, la liste d'adjacence peut \u00eatre repr\u00e9sent\u00e9e par : la liste de ses successeurs, ou bien la liste de ses pr\u00e9d\u00e9cesseurs, lorsque les probl\u00e8mes \u00e9tudi\u00e9s s'y pr\u00eatent mieux (\u00e7a arrive) impl\u00e9mentation en Python \u2693\ufe0e On utilisera le graphe pr\u00e9c\u00e9dent pour illustrer le cours. impl\u00e9mentation en utilisant un objet de type dict \u2693\ufe0e On peut utiliser un dictionnaire dans lequel les cl\u00e9s sont les sommets et les valeurs les sommets de destinations. G = { '1' : [ '1' , '4' ], '2' : [ '1' , '3' , '4' ], '3' : [ '4' ], '4' : [ '3' ]} Remarque On pourrat utiliser une liste de listes comme ci-dessous : G = [[ 1 , 4 ], [ 1 , 3 , 4 ], [ 4 ], [ 3 ]] Cela pose deux probl\u00e8mes : - l'ordre des sommets. - la complexit\u00e9 d'une recherche en O(n) (O(1) avec un dictionnaire). 3.2 Matrice d'adjacence \u2693\ufe0e Qu'est qu'une matrice ? Une matrice est un tableau de nombres. elle peut \u00eatre repr\u00e9sent\u00e9e en Python facilement : par une liste de listes en Python (par d\u00e9faut) un dictionnaire, en notant A une certaine matrice, Alors A[i][j] d\u00e9signe l'\u00e9l\u00e9ment situ\u00e9 \u00e0 la ligne i et \u00e0 la colonne j Remarque : Une matrice est dite sym\u00e9trique si pour tout i et j : A[i][j] = A[j][i]. Cela revient \u00e0 ce que les coefficients A[i][j] soient sym\u00e9triques par rapport \u00e0 la diagonale principale. \u00c0 savoir Un graphe (orient\u00e9, ou pas) peut \u00eatre repr\u00e9sent\u00e9 par une matrice d'adjacence : - tout lien depuis le sommet i vers le sommet j, est repr\u00e9sent\u00e9 par A[i][j] = 1 - Une absence de lien du sommet i vers le sommet j, est repr\u00e9sent\u00e9 par A[i][j] = 0 Exemples : \u00c0 savoir Un graphe pond\u00e9r\u00e9 (orient\u00e9, ou pas) peut \u00eatre repr\u00e9sent\u00e9 par une matrice d'adjacence : - tout lien depuis le sommet i vers le sommet j, est repr\u00e9sent\u00e9 par A[i][j] = p o\u00f9 p d\u00e9signe le poids du lien du sommet i vers le sommet j. - Une absence de lien du sommet i vers le sommet j, est repr\u00e9sent\u00e9 par A[i][j] = 0 Exemples : 3.3 Choisir une repr\u00e9sentation \u2693\ufe0e Les repr\u00e9sentations en liste d'adjacence et en matrice d'adjacence sont \u00e9quivalentes du point de vue des informations qu'elles contiennent, mais pr\u00e9sentent des avantages et des inconv\u00e9nients pour l'acc\u00e8s \u00e0 ce informations. Une liste d'adjacence permet par exemple de lister imm\u00e9diatement tous les voisins d'un sommet alors qu'avec une matrice on est oblig\u00e9 de parcourir toute la ligne correspondante. Dans des tr\u00e8s grands graphes avec peu de connectivit\u00e9 cela peut repr\u00e9senter une perte de temps. Dans ces m\u00eames graphes, une matrice stockera beaucoup de 0. Et donc utilisera beaucoup d'espace m\u00e9moire pour les cases vides de la matrice. \u00c0 l'inverse, une matrice permet de savoir imm\u00e9diatement l'existence d'un arc entre deux sommets. Avec une liste, il est n\u00e9cessaire de parcourir la liste enti\u00e8re. Le choix de la repr\u00e9sentation d\u00e9pend donc de la taille du graphe, de sa connectivit\u00e9 et des op\u00e9rations que l'on va devoir effectuer le plus souvent. 3.4 Travaux dirig\u00e9s \u2693\ufe0e Feuille de travail sur table ici . 3.5 Travaux pratiques \u2693\ufe0e 4. Parcours de graphes \u2693\ufe0e 4.1 Parcours en largeur BFS \u2693\ufe0e 4.2 Parcours en profondeur DFS \u2693\ufe0e","title":"CH7 Graphes et parcours de graphes"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#ch7-les-graphes","text":"Programme officiel","title":"CH7 : Les graphes"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#1-quest-ce-quun-graphe","text":"","title":"1. Qu'est ce qu'un graphe ?"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#11-des-exemples-de-graphes","text":"Le graphe est une structure de donn\u00e9es tr\u00e8s utilis\u00e9e pour repr\u00e9senter les liens et les interactions entre des objets, les personnes, les villes, les ordinateurs ... En effet, nous verrons qu'il existe de nombreuses vari\u00e9t\u00e9s de graphes permettant ainsi de d\u00e9crire des situations diverses, tout en conservant, une m\u00eame repr\u00e9sentation et donc des m\u00eames m\u00e9thodes pour les manipuler par informatique. Exemple 1 : Le r\u00e9seau social Exemple 2 : Le r\u00e9seau routier Exemple 3 : R\u00e9seau informatique","title":"1.1 Des exemples de graphes"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#12-definition","text":"D\u00e9finition Un graphe G est une structure de donn\u00e9es non lin\u00e9aire compos\u00e9e d'objets: les sommets , not\u00e9s V comme vertex ou vertice , dans laquelle certaines paires d'objets sont reli\u00e9es. des ar\u00eates , not\u00e9es E comme edge , reliant les sommets. Exemple : V = {A; B; C} et E = {(A, B); (A, C); C} G = (V , E) est un graphe de sommets A, B et C o\u00f9 A et B sont reli\u00e9s, A et C sont reli\u00e9s, et C est connect\u00e9 \u00e0 lui-m\u00eame.","title":"1.2 D\u00e9finition"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#13-representation-sagitale-dun-graphe","text":"La repr\u00e9sentation sagittale d\u2019un graphe G = (V , E) est un sch\u00e9ma o\u00f9 les \u00e9l\u00e9ments de V (sommets) sont repr\u00e9sent\u00e9s par des disques et o\u00f9 les \u00e9l\u00e9ments de E (ar\u00eates) sont repr\u00e9sent\u00e9s par des traits. Exemple : Repr\u00e9sentation du graphe G = {V = {A; B; C} ; E = {(A, B); (A, C); C}} Remarque Aucune r\u00e8gle dicte la fa\u00e7on dont il faut disposer les ar\u00eates relient les sommets. Les deux repr\u00e9sentations du graphe ci-dessous sont identiques.","title":"1.3 Repr\u00e9sentation sagitale d'un graphe"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#2-vocabulaire-sur-les-graphes","text":"","title":"2. Vocabulaire sur les graphes"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#21-graphes-non-orientes-orientes-ponderes","text":"","title":"2.1 Graphes non-orient\u00e9s, orient\u00e9s, pond\u00e9r\u00e9s"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#graphes-non-orientes-et-orientes","text":"\u00c0 savoir On distingue les graphes non orient\u00e9s, o\u00f9 les ar\u00eates relient deux sommets de mani\u00e8re sym\u00e9trique et les graphes orient\u00e9s, o\u00f9 les ar\u00eates, alors appel\u00e9s arcs, relient deux sommets de mani\u00e8re asym\u00e9trique.","title":"Graphes non orient\u00e9s et orient\u00e9s"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#graphes-ponderes","text":"\u00c0 savoir On dit qu\u2019un graphe est pond\u00e9r\u00e9 quand ses ar\u00eates ou ses arcs sont coupl\u00e9s avec des nombres. Ces nombres sont appel\u00e9s des poids. Exemple : Parcours d\u2019un livreur : les ar\u00eates repr\u00e9sentent le temps qu\u2019il met pour aller d\u2019un sommet \u00e0 l\u2019autre.","title":"Graphes pond\u00e9r\u00e9s"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#22-complexite-et-morphologie","text":"Voici du vocabulaire pour qu'on puisse tous parler de la m\u00eame chose.","title":"2.2 Complexit\u00e9 et morphologie"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#ordre","text":"\u00c0 savoir L' ordre d'un graphe correspond au nombre de ses sommets.","title":"ordre"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#taille","text":"\u00c0 savoir La taille est le nombre de ses ar\u00eates ou arcs.","title":"taille"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#degre","text":"\u00c0 savoir Le degr\u00e9 d'un sommet est le nombre d'ar\u00eates qui relient ce sommet \u00e0 d'autres sommets. Remarque Pour un graphe orient\u00e9, le degr\u00e9 entrant d'un sommet est le nombre d'arcs entrants et le degr\u00e9 sortant est le nombre d'arcs sortants.","title":"degr\u00e9"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#densite","text":"\u00c0 conna\u00eetre La densit\u00e9 D d'un graphe est une indication de sa connectivit\u00e9 et indique s'il y a beaucoup ou peu d'ar\u00eates. \\(D = \\dfrac{E}{V \\times (V-1)}\\) pour un graphe non orient\u00e9. \\(D = \\dfrac{2 \\times E}{V \\times (V-1)}\\) pour un graphe orient\u00e9. Remarque D = 1 pour un graphe complet et 0 pour un graphe sans aucune ar\u00eate. Plus D se rapproche de 1 et plus le graphe est dense. Et plus D se rapproche de 0, plus le graphe est creux.","title":"densit\u00e9"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#sommets-adjacents","text":"\u00c0 savoir Deux sommets reli\u00e9s par une ar\u00eate sont dits adjacents. Remarques Dans un graphe non orient\u00e9, lorsque deux sommets sont adjacents, on dit qu'ils sont voisins . Dans un graphe orient\u00e9, on parle de successeurs (sommet d'arriv\u00e9e) et de pr\u00e9d\u00e9cesseurs (sommet de d\u00e9part).","title":"sommets adjacents"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#chaine-ou-chemin","text":"\u00c0 savoir Une cha\u00eene est une s\u00e9quence d'ar\u00eates cons\u00e9cutives dans un graphe non-orient\u00e9. Dans un graphe orient\u00e9 on parle de chemin .","title":"cha\u00eene ou chemin"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#simple","text":"\u00c0 connaitre Un graphe est dit simple si il ne peut y avoir au plus qu'une ar\u00eate entre deux sommets (ou au plus un arc dans le m\u00eame sens pour un graphe orient\u00e9). Par exemple un compte Twitter est un graphe orient\u00e9 ou un compte ne peut pas suivre plusieyr fois le m\u00eame compte. Remarque Dans le cas contraire on parle de multi-graphe . On peut imaginer un graphe routier dans lequel deux villes peuvent \u00eatre reli\u00e9es par deux trajets diff\u00e9rents (poids diff\u00e9rents car distances \u00e0 parcourir diff\u00e9rentes) ou moyens de transport diff\u00e9rents (voiture, train ...).","title":"simple"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#cyclique","text":"\u00c0 connaitre Un graphe est dit cyclique s\u2019il existe une cha\u00eene ou un chemin reliant n\u2019importe quel sommet \u00e0 lui-m\u00eame. Exemple : Une chaine par exemple : 1 - 4 - 5 - 2 - 1. On a bien existence d'un cycle.","title":"cyclique"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#connexe","text":"\u00c0 connaitre Un graphe est dit connexe si ses sommets peuvent \u00eatre reli\u00e9s deux \u00e0 deux par une ar\u00eate ou un arc. Exemple :","title":"connexe"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#complet","text":"\u00c0 connaitre Un graphe est dit complet si deux sommets quelconques sont adjacents (reli\u00e9s par une ar\u00eate). Exemple :","title":"complet"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#3-les-graphes-en-programmation","text":"","title":"3. Les graphes en programmation"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#31-liste-dadjacence","text":"\u00c0 savoir La liste d'adjacence d'un graphe, est la liste des voisins (sommets adjacents de destination) de chaque sommet. Exemple : Liste d'adjacence du graphe : (1 -> (1; 4); 2 -> (1; 3; 4); 3 -> (4); 4 -> (3)) Remarques Lorsque le graphe est non orient\u00e9, la liste d'adjacence est une liste de voisins Lorsque le graphe est orient\u00e9, la liste d'adjacence peut \u00eatre repr\u00e9sent\u00e9e par : la liste de ses successeurs, ou bien la liste de ses pr\u00e9d\u00e9cesseurs, lorsque les probl\u00e8mes \u00e9tudi\u00e9s s'y pr\u00eatent mieux (\u00e7a arrive)","title":"3.1 Liste d'adjacence"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#implementation-en-python","text":"On utilisera le graphe pr\u00e9c\u00e9dent pour illustrer le cours.","title":"impl\u00e9mentation en Python"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#32-matrice-dadjacence","text":"Qu'est qu'une matrice ? Une matrice est un tableau de nombres. elle peut \u00eatre repr\u00e9sent\u00e9e en Python facilement : par une liste de listes en Python (par d\u00e9faut) un dictionnaire, en notant A une certaine matrice, Alors A[i][j] d\u00e9signe l'\u00e9l\u00e9ment situ\u00e9 \u00e0 la ligne i et \u00e0 la colonne j Remarque : Une matrice est dite sym\u00e9trique si pour tout i et j : A[i][j] = A[j][i]. Cela revient \u00e0 ce que les coefficients A[i][j] soient sym\u00e9triques par rapport \u00e0 la diagonale principale. \u00c0 savoir Un graphe (orient\u00e9, ou pas) peut \u00eatre repr\u00e9sent\u00e9 par une matrice d'adjacence : - tout lien depuis le sommet i vers le sommet j, est repr\u00e9sent\u00e9 par A[i][j] = 1 - Une absence de lien du sommet i vers le sommet j, est repr\u00e9sent\u00e9 par A[i][j] = 0 Exemples : \u00c0 savoir Un graphe pond\u00e9r\u00e9 (orient\u00e9, ou pas) peut \u00eatre repr\u00e9sent\u00e9 par une matrice d'adjacence : - tout lien depuis le sommet i vers le sommet j, est repr\u00e9sent\u00e9 par A[i][j] = p o\u00f9 p d\u00e9signe le poids du lien du sommet i vers le sommet j. - Une absence de lien du sommet i vers le sommet j, est repr\u00e9sent\u00e9 par A[i][j] = 0 Exemples :","title":"3.2 Matrice d'adjacence"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#33-choisir-une-representation","text":"Les repr\u00e9sentations en liste d'adjacence et en matrice d'adjacence sont \u00e9quivalentes du point de vue des informations qu'elles contiennent, mais pr\u00e9sentent des avantages et des inconv\u00e9nients pour l'acc\u00e8s \u00e0 ce informations. Une liste d'adjacence permet par exemple de lister imm\u00e9diatement tous les voisins d'un sommet alors qu'avec une matrice on est oblig\u00e9 de parcourir toute la ligne correspondante. Dans des tr\u00e8s grands graphes avec peu de connectivit\u00e9 cela peut repr\u00e9senter une perte de temps. Dans ces m\u00eames graphes, une matrice stockera beaucoup de 0. Et donc utilisera beaucoup d'espace m\u00e9moire pour les cases vides de la matrice. \u00c0 l'inverse, une matrice permet de savoir imm\u00e9diatement l'existence d'un arc entre deux sommets. Avec une liste, il est n\u00e9cessaire de parcourir la liste enti\u00e8re. Le choix de la repr\u00e9sentation d\u00e9pend donc de la taille du graphe, de sa connectivit\u00e9 et des op\u00e9rations que l'on va devoir effectuer le plus souvent.","title":"3.3 Choisir une repr\u00e9sentation"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#34-travaux-diriges","text":"Feuille de travail sur table ici .","title":"3.4 Travaux dirig\u00e9s"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#35-travaux-pratiques","text":"","title":"3.5 Travaux pratiques"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#4-parcours-de-graphes","text":"","title":"4. Parcours de graphes"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#41-parcours-en-largeur-bfs","text":"","title":"4.1 Parcours en largeur BFS"},{"location":"Structures%20de%20donn%C3%A9es/CH7_graphes/cours/#42-parcours-en-profondeur-dfs","text":"","title":"4.2 Parcours en profondeur DFS"},{"location":"xtra/end_REM/","text":"Z","title":"end REM"},{"location":"xtra/start_REM/","text":"A","title":"start REM"}]}