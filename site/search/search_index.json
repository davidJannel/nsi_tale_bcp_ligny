{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Chapitres et th\u00e8mes abord\u00e9s : \u2693\ufe0e CH1 : Mise au point des programmes - Gestion des bugs (BAC) CH2 : R\u00e9cursivit\u00e9 CH3 : Structures de donn\u00e9es - Les piles","title":"index"},{"location":"#chapitres-et-themes-abordes","text":"CH1 : Mise au point des programmes - Gestion des bugs (BAC) CH2 : R\u00e9cursivit\u00e9 CH3 : Structures de donn\u00e9es - Les piles","title":"Chapitres et th\u00e8mes abord\u00e9s :"},{"location":"a_propos/","text":"\u00c9crire de maths : \u2693\ufe0e \\[x = \\dfrac{y}{2 \\times z}\\]","title":"\u00e0 propos"},{"location":"a_propos/#ecrire-de-maths","text":"\\[x = \\dfrac{y}{2 \\times z}\\]","title":"\u00c9crire de maths :"},{"location":"CH1_map/cours/","text":"CH1 : Mise au point des programmes - Gestion des bugs \u2693\ufe0e Programme officiel \"La mise au point du programme doit permettre au programme de r\u00e9pondre \u00e0 une sp\u00e9cification, durant cette phase, le programmeur se doit de savoir r\u00e9pondre aux causes typiques de bugs.\" 1. Conventions syntaxiques \u2693\ufe0e La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits : 1.1 Les espaces \u2693\ufe0e \u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/ 1.2 Les conventions de nommage \u2693\ufe0e \u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. (cf : cours de Mme Desmarest) # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass 2. Les erreurs courantes en Python - Savoir lire ses erreurs et corriger son code \u2693\ufe0e Lorsqu'on ex\u00e9cute un programme, il peut fonctionner comme pr\u00e9vu, mais il peut \u00e9galement \"planter\", ou bien ne plus s'arr\u00eater (boucler ind\u00e9finiment). Les sources possibles d'erreurs dans un programme sont nombreuses. En fonction des erreurs rencontr\u00e9es, Python affiche des erreurs sp\u00e9cifiques qui vous aident \u00e0 comprendre quel est le probl\u00e8me dans votre programme. 2.1 Analyser le traceback \u2693\ufe0e Le traceback est l\u2019ensemble des lignes a\ufb00ich\u00e9es par l\u2019interpr\u00e9teur Python lorsqu\u2019une exception est lev\u00e9e. Comprendre le traceback est tr\u00e8s utile pour trouver rapidement une faute et l\u2019expliquer. Voici un exemple de traceback a\ufb00ich\u00e9 lors de l\u2019ex\u00e9cution d\u2019un code: 1 2 3 4 5 6 7 8 def moyenne ( t ): n = len ( t ) s = 0 for i in range ( n ): s = s + t [ i ] return s / n print ( moyenne ([])) >>> % Run moyenne . py Traceback ( most recent call last ): File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 8 , in < module > print ( moyenne ([])) File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 6 , in moyenne return s / n ZeroDivisionError : division by zero Ce traceback est constitu\u00e9 d\u2019une liste de lignes en d\u00e9faut (il y en a 2 ici), puis d\u2019un message qui pr\u00e9cise letype d\u2019exception (c\u2019est la derni\u00e8re ligne). En lisant le traceback de haut en bas, on avance dans le temps. Ce qui s\u2019est produit en dernier est donc \u00e0 la fin du traceback. En le lisant de haut en bas, on note (notez la correspondance entre ce qui est indiqu\u00e9 ci-dessous et le contenudu traceback) : ex\u00e9cution de la ligne 8 \u00ab print(moyenne([])) \u00bb. On entre dans la fonction moyenne qui a provoqu\u00e9 l\u2019ex\u00e9cution de la ligne 6 \u00ab return s / n \u00bb, qui a donc provoqu\u00e9 la lev\u00e9e d\u2019exceptionZeroDivisionError: division by zero La plupart du temps, la lecture des trois derni\u00e8res lignes du traceback permet de cerner le probl\u00e8me : Ici, on effectue une divison par 0. Cela s'est produit lors du renvoie du calcul de s par n. Calcul qui est fait \u00e0 la ligne 6. Cette erreur n'est lev\u00e9e uniquement parceque on a fait appel \u00e0 la fonction moyenne sur un tableau vide. La fonction par elle m\u00eame est correcte. Il faut juste faire attention et pr\u00e9ciser \u00e0 l'utilisateur que la fonction doit \u00eatre appel\u00e9e avec des tableaux non vides. Pour \u00e9viter ces erreurs, il est donc important de : - savoir lire le traceback. - pr\u00e9voir des jeux de tests. - sp\u00e9cifier la fonction pour pouvoir b\u00e9n\u00e9ficier d'une aide \u00e0 l'utilisation de celle-ci. 2.2 Quelques erreurs courantes \u2693\ufe0e Voici quelques erreurs courantes que vous devez apprendre \u00e0 reconnaitre parmi les nombreuses exceptions de Python. Type d'erreur Objet Python Erreurs courantes Exemple Erreurs de syntaxe SyntaxError Erreur de parenth\u00e8se, : manquant avant un bloc d'instruction ... len(t)) Erreurs d'indexation IndexError Acc\u00e8s \u00e0 un index non pr\u00e9sent dans une liste, ou un tuple, str... t = [2, 3] puis print(t[2]) Erreurs de nom NameError Nom de fonction ou de variable mal orthographi\u00e9. print(Bonjour) ou prin(\"Bonjour\") Erreurs d'indentation IndentationError Indentation oubli\u00e9e, ou trop grande, les blocs sont alors mal d\u00e9limit\u00e9s. Erreurs de type TypeError Op\u00e9ration impossible entre deux types(str - int). Conversion de type impossible. '3' * '5' ** Exercices :** Identifier le type d'erreur dans les exerices ci-dessous et corriger les. Question 1 code solution On d\u00e9sire afficher les \u00e9l\u00e9ments de la liste. 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 4 : print ( lst [ i ]) i = i + 1 IndexError : la liste ne contient que 3 \u00e9l\u00e9ments 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 3 : print ( lst [ i ]) i = i + 1 On rapelle qu'il est pr\u00e9f\u00e9rable de parcourir une liste (tableau) en utilisant une boucle for. Exercice 2 code solution 1 2 3 a = 2 b = \"Une fois sur \" print ( b + a ) TypeError : On ne peut pas concat\u00e9ner une chaine de caract\u00e8res avec un int. 1 2 3 a = \"2\" b = \"Une fois sur \" print ( b + a ) ou alors 1 2 3 a = 2 b = \"Une fois sur \" print ( b + str ( a )) Exercice 3 code solution Afficher la somme de tous les \u00e9l\u00e9ments de la liste. 1 2 3 4 l = [ 0 , 4 , 8 , 5 ] for v in l : s = s + v print ( s ) NameError : la variable s n'est pas initialis\u00e9e avant la boucle. L'expression s + v ne peut \u00eatre calcul\u00e9e. ` 1 2 3 4 5 l = [ 0 , 4 , 8 , 5 ] s = 0 # par exemple for v in l : s = s + v print ( s ) Exercice 4 code solution Afficher les \u00e9l\u00e9ments de la liste 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) IndentationError : il manque l'indentation avant le print. ` 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) Exercice 5 code solution Afficher la plus petite valeur contenue dans la liste 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini mini = liste [ i ] print ( mini ) SyntaxError : il manque : dans la condition (ligne 4) 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini : mini = liste [ i ] print ( mini ) Remarques Attention, si l'interpr\u00e9teur Python ne renvoie pas d'erreur, cela ne signifie pas pour autant que votre code est correct. Dans l'exemple de la fonction moyenne qui doit renvoyer la moyenne des valeurs contenues dans un tableau, la fonction fait correctement le travail mais elle ne fonctionne pas sur une liste vide, ou sur une liste qui ne contiendrait pas uniquement des valeurs num\u00e9riques. D'autres erreurs peuvent \u00eatre non affich\u00e9es dans l'interpr\u00e9teur. Par exemple : des instructions conditionnelles qui oublient des cas, des mauvaises conditions ... des boucles qui ne se terminent pas : cas de la boucle while des effets de bords : on modifie une variable globale \u00e0 l'int\u00e9rieur d'une fonction. Il est donc important avant de coder de sp\u00e9cifier une fonction, de docummenter si n\u00e9cessaire une partie du code, de pr\u00e9voir des jeux de tests. Tester, debugger, font partie des bonnes pratiques du programmeur. \u00c7a s'appelle mettre au point du code. 3. Documenter et sp\u00e9cifier \u2693\ufe0e 3.1 Commenter son code ? (ou pas) \u2693\ufe0e Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires. 3.2 Le cas particulier des docstrings \u2693\ufe0e 3.2.1 Que sont les docstrings ? \u2693\ufe0e Les docstrings sont des commentaires normalis\u00e9s pour les fonctions, qui peuvent \u00eatre consult\u00e9s en console. Exemples : Nous connaissons la fonction len() qui permet par exemple de conna\u00eetre la longueur d'une liste pass\u00e9e en param\u00e8tre. Si nous tapons en console la commande print(len.__doc__) , nous aurons la description de cette fonction. >>> len . __doc__ 'Return the number of items in a container.' Il est aussi possible d'acc\u00e9der \u00e0 la docstring d'une fonction f par la commande help(f) : >>> help ( len ) Help on built - in function len in module builtins : len ( obj , / ) Return the number of items in a container . De m\u00eame pour la fonction range : >>> print ( range . __doc__ ) range ( stop ) -> range object range ( start , stop [, step ]) -> range object Return an object that produces a sequence of integers from start ( inclusive ) to stop ( exclusive ) by step . range ( i , j ) produces i , i + 1 , i + 2 , ... , j - 1. start defaults to 0 , and stop is omitted ! range ( 4 ) produces 0 , 1 , 2 , 3. These are exactly the valid indices for a list of 4 elements . When step is given , it specifies the increment ( or decrement ) . Le r\u00e9sultat de la commande help(range) est trop long pour \u00eatre repris ici, mais on y retrouve bien la docstring de la fonction range . 3.2.2 Cr\u00e9er ses propres docstrings \u2693\ufe0e Il suffit pour cela de commencer la fonction \u00e0 documenter par une ou plusieurs phrases entre triples quotes : def capital_apres_n_annees ( capital , taux , nombre_annees ) : \"\"\" Renvoie le capital apr\u00e8s n ann\u00e9es. input : capital : valeur initiale (float) taux : taux d'int\u00e9r\u00eat (float) (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d'ann\u00e9es de placement du capital (int) output : capital apr\u00e8s n ann\u00e9es (float) \"\"\" return capital * ( 1 + taux ) ** nombre_annees Ainsi, un utilisateur pourra trouver en console le mode d'emploi de notre fonction : >>> help ( capital_apres_n_annees ) Help on function capital_apres_n_annees in module __main__ : capital_apres_n_annees ( capital , taux , nombre_annees ) Renvoie le capital apr\u00e8s n ann\u00e9es . capital : valeur initiale taux : taux d 'int\u00e9r\u00eat exprim\u00e9 en nombre d\u00e9cimal (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d 'ann\u00e9es de placement du capital Comme on le voit, tout cela est tr\u00e8s \u00abverbeux\u00bb. Cela peut nous para\u00eetre largement superflu puisque nos codes d\u00e9passent rarement quelques dizaines de lignes et sont lus par rarement plus de 2 personnes. Mais dans la vraie vie des d\u00e9veloppeurs, il est primordial qu'un code soit clair et document\u00e9. \u00c0 retenir des commentaires quand cela est nec\u00e9ssaire des noms de variable explicites une sp\u00e9cification des fonctions avec une docstring sous le mod\u00e8le suivant : def ma_fonction (): \"\"\" que renvoie ma_fonction input : arguments, type output : valeur de sortie, type \"\"\" votre code 4. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code \u2693\ufe0e La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici . 5. Les tests \u2693\ufe0e 5.1 Pourquoi des tests ? \u2693\ufe0e Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok 5.2 Revoil\u00e0 les assert \u2693\ufe0e Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00e9nonc\u00e9 solution \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste d'entiers liste , suppos\u00e9e non vide, pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) . def test_maxi (): assert maxi ([ 5 ]) == 5 assert maxi ([ - 1 , 5 , 4 , 0 ]) == 5 assert maxi ([ 8 , 7 , 6 , 2 ]) == 8 assert maxi ([ - 1 , - 5 , 0 ]) == 0 def maxi ( liste ): \"\"\" revoie le maximum d'une liste d'entier non vide input : liste (list) d'entiers output : maximum (int) \"\"\" maximum = liste [ 0 ] for elt in liste : if elt > maximum : maximum = elt return maximum 5.3 Le module doctest \u2693\ufe0e Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. On peut, au lieu d'utiliser doctest dans la console Python, placer \u00e0 la fin du fichier le code suivant : if __name__ == '__main__' : import doctest doctest . testmod () Le resultat des tests, si ils ne passent pas, se fera dans l'interpr\u00e9teur \u00e0 chaque execution du code. 5.3 \u00c0 propos des tests \u2693\ufe0e Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...","title":"CH1 : Mise au point des programmes"},{"location":"CH1_map/cours/#ch1-mise-au-point-des-programmes-gestion-des-bugs","text":"Programme officiel \"La mise au point du programme doit permettre au programme de r\u00e9pondre \u00e0 une sp\u00e9cification, durant cette phase, le programmeur se doit de savoir r\u00e9pondre aux causes typiques de bugs.\"","title":"CH1 : Mise au point des programmes - Gestion des bugs"},{"location":"CH1_map/cours/#1-conventions-syntaxiques","text":"La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits :","title":"1. Conventions syntaxiques"},{"location":"CH1_map/cours/#11-les-espaces","text":"\u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) # PAS BIEN a = 3 # BIEN a = 3 # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/","title":"1.1 Les espaces"},{"location":"CH1_map/cours/#12-les-conventions-de-nommage","text":"\u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. (cf : cours de Mme Desmarest) # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass","title":"1.2 Les conventions de nommage"},{"location":"CH1_map/cours/#2-les-erreurs-courantes-en-python-savoir-lire-ses-erreurs-et-corriger-son-code","text":"Lorsqu'on ex\u00e9cute un programme, il peut fonctionner comme pr\u00e9vu, mais il peut \u00e9galement \"planter\", ou bien ne plus s'arr\u00eater (boucler ind\u00e9finiment). Les sources possibles d'erreurs dans un programme sont nombreuses. En fonction des erreurs rencontr\u00e9es, Python affiche des erreurs sp\u00e9cifiques qui vous aident \u00e0 comprendre quel est le probl\u00e8me dans votre programme.","title":"2. Les erreurs courantes en Python - Savoir lire ses erreurs et corriger son code"},{"location":"CH1_map/cours/#21-analyser-le-traceback","text":"Le traceback est l\u2019ensemble des lignes a\ufb00ich\u00e9es par l\u2019interpr\u00e9teur Python lorsqu\u2019une exception est lev\u00e9e. Comprendre le traceback est tr\u00e8s utile pour trouver rapidement une faute et l\u2019expliquer. Voici un exemple de traceback a\ufb00ich\u00e9 lors de l\u2019ex\u00e9cution d\u2019un code: 1 2 3 4 5 6 7 8 def moyenne ( t ): n = len ( t ) s = 0 for i in range ( n ): s = s + t [ i ] return s / n print ( moyenne ([])) >>> % Run moyenne . py Traceback ( most recent call last ): File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 8 , in < module > print ( moyenne ([])) File \"/home/jannel/Bureau/essai_python_mkdocs.py\" , line 6 , in moyenne return s / n ZeroDivisionError : division by zero Ce traceback est constitu\u00e9 d\u2019une liste de lignes en d\u00e9faut (il y en a 2 ici), puis d\u2019un message qui pr\u00e9cise letype d\u2019exception (c\u2019est la derni\u00e8re ligne). En lisant le traceback de haut en bas, on avance dans le temps. Ce qui s\u2019est produit en dernier est donc \u00e0 la fin du traceback. En le lisant de haut en bas, on note (notez la correspondance entre ce qui est indiqu\u00e9 ci-dessous et le contenudu traceback) : ex\u00e9cution de la ligne 8 \u00ab print(moyenne([])) \u00bb. On entre dans la fonction moyenne qui a provoqu\u00e9 l\u2019ex\u00e9cution de la ligne 6 \u00ab return s / n \u00bb, qui a donc provoqu\u00e9 la lev\u00e9e d\u2019exceptionZeroDivisionError: division by zero La plupart du temps, la lecture des trois derni\u00e8res lignes du traceback permet de cerner le probl\u00e8me : Ici, on effectue une divison par 0. Cela s'est produit lors du renvoie du calcul de s par n. Calcul qui est fait \u00e0 la ligne 6. Cette erreur n'est lev\u00e9e uniquement parceque on a fait appel \u00e0 la fonction moyenne sur un tableau vide. La fonction par elle m\u00eame est correcte. Il faut juste faire attention et pr\u00e9ciser \u00e0 l'utilisateur que la fonction doit \u00eatre appel\u00e9e avec des tableaux non vides. Pour \u00e9viter ces erreurs, il est donc important de : - savoir lire le traceback. - pr\u00e9voir des jeux de tests. - sp\u00e9cifier la fonction pour pouvoir b\u00e9n\u00e9ficier d'une aide \u00e0 l'utilisation de celle-ci.","title":"2.1 Analyser le traceback"},{"location":"CH1_map/cours/#22-quelques-erreurs-courantes","text":"Voici quelques erreurs courantes que vous devez apprendre \u00e0 reconnaitre parmi les nombreuses exceptions de Python. Type d'erreur Objet Python Erreurs courantes Exemple Erreurs de syntaxe SyntaxError Erreur de parenth\u00e8se, : manquant avant un bloc d'instruction ... len(t)) Erreurs d'indexation IndexError Acc\u00e8s \u00e0 un index non pr\u00e9sent dans une liste, ou un tuple, str... t = [2, 3] puis print(t[2]) Erreurs de nom NameError Nom de fonction ou de variable mal orthographi\u00e9. print(Bonjour) ou prin(\"Bonjour\") Erreurs d'indentation IndentationError Indentation oubli\u00e9e, ou trop grande, les blocs sont alors mal d\u00e9limit\u00e9s. Erreurs de type TypeError Op\u00e9ration impossible entre deux types(str - int). Conversion de type impossible. '3' * '5' ** Exercices :** Identifier le type d'erreur dans les exerices ci-dessous et corriger les. Question 1 code solution On d\u00e9sire afficher les \u00e9l\u00e9ments de la liste. 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 4 : print ( lst [ i ]) i = i + 1 IndexError : la liste ne contient que 3 \u00e9l\u00e9ments 1 2 3 4 5 lst = [ 1 , 2 , 3 ] i = 0 while i < 3 : print ( lst [ i ]) i = i + 1 On rapelle qu'il est pr\u00e9f\u00e9rable de parcourir une liste (tableau) en utilisant une boucle for. Exercice 2 code solution 1 2 3 a = 2 b = \"Une fois sur \" print ( b + a ) TypeError : On ne peut pas concat\u00e9ner une chaine de caract\u00e8res avec un int. 1 2 3 a = \"2\" b = \"Une fois sur \" print ( b + a ) ou alors 1 2 3 a = 2 b = \"Une fois sur \" print ( b + str ( a )) Exercice 3 code solution Afficher la somme de tous les \u00e9l\u00e9ments de la liste. 1 2 3 4 l = [ 0 , 4 , 8 , 5 ] for v in l : s = s + v print ( s ) NameError : la variable s n'est pas initialis\u00e9e avant la boucle. L'expression s + v ne peut \u00eatre calcul\u00e9e. ` 1 2 3 4 5 l = [ 0 , 4 , 8 , 5 ] s = 0 # par exemple for v in l : s = s + v print ( s ) Exercice 4 code solution Afficher les \u00e9l\u00e9ments de la liste 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) IndentationError : il manque l'indentation avant le print. ` 1 2 3 t = [ 4 , 8 , 9 , 2 , 5 ] for elt in t : print ( elt ) Exercice 5 code solution Afficher la plus petite valeur contenue dans la liste 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini mini = liste [ i ] print ( mini ) SyntaxError : il manque : dans la condition (ligne 4) 1 2 3 4 5 6 liste = [ 8 , 9 , 5 , 1 , 6 ] mini = liste [ 0 ] for i in range ( len ( liste )): if liste [ i ] < mini : mini = liste [ i ] print ( mini ) Remarques Attention, si l'interpr\u00e9teur Python ne renvoie pas d'erreur, cela ne signifie pas pour autant que votre code est correct. Dans l'exemple de la fonction moyenne qui doit renvoyer la moyenne des valeurs contenues dans un tableau, la fonction fait correctement le travail mais elle ne fonctionne pas sur une liste vide, ou sur une liste qui ne contiendrait pas uniquement des valeurs num\u00e9riques. D'autres erreurs peuvent \u00eatre non affich\u00e9es dans l'interpr\u00e9teur. Par exemple : des instructions conditionnelles qui oublient des cas, des mauvaises conditions ... des boucles qui ne se terminent pas : cas de la boucle while des effets de bords : on modifie une variable globale \u00e0 l'int\u00e9rieur d'une fonction. Il est donc important avant de coder de sp\u00e9cifier une fonction, de docummenter si n\u00e9cessaire une partie du code, de pr\u00e9voir des jeux de tests. Tester, debugger, font partie des bonnes pratiques du programmeur. \u00c7a s'appelle mettre au point du code.","title":"2.2 Quelques erreurs courantes"},{"location":"CH1_map/cours/#3-documenter-et-specifier","text":"","title":"3. Documenter et sp\u00e9cifier"},{"location":"CH1_map/cours/#31-commenter-son-code-ou-pas","text":"Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires.","title":"3.1 Commenter son code ? (ou pas)"},{"location":"CH1_map/cours/#32-le-cas-particulier-des-docstrings","text":"","title":"3.2 Le cas particulier des docstrings"},{"location":"CH1_map/cours/#4-la-programmation-defensive-des-assert-pour-securiser-le-code","text":"La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici .","title":"4. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code"},{"location":"CH1_map/cours/#5-les-tests","text":"","title":"5. Les tests"},{"location":"CH1_map/cours/#51-pourquoi-des-tests","text":"Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : >>> test_valeur_absolue () ok ok ok","title":"5.1 Pourquoi des tests ?"},{"location":"CH1_map/cours/#52-revoila-les-assert","text":"Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00e9nonc\u00e9 solution \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste d'entiers liste , suppos\u00e9e non vide, pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) . def test_maxi (): assert maxi ([ 5 ]) == 5 assert maxi ([ - 1 , 5 , 4 , 0 ]) == 5 assert maxi ([ 8 , 7 , 6 , 2 ]) == 8 assert maxi ([ - 1 , - 5 , 0 ]) == 0 def maxi ( liste ): \"\"\" revoie le maximum d'une liste d'entier non vide input : liste (list) d'entiers output : maximum (int) \"\"\" maximum = liste [ 0 ] for elt in liste : if elt > maximum : maximum = elt return maximum","title":"5.2 Revoil\u00e0 les assert"},{"location":"CH1_map/cours/#53-le-module-doctest","text":"Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. On peut, au lieu d'utiliser doctest dans la console Python, placer \u00e0 la fin du fichier le code suivant : if __name__ == '__main__' : import doctest doctest . testmod () Le resultat des tests, si ils ne passent pas, se fera dans l'interpr\u00e9teur \u00e0 chaque execution du code.","title":"5.3 Le module doctest"},{"location":"CH1_map/cours/#53-a-propos-des-tests","text":"Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...","title":"5.3 \u00c0 propos des tests"}]}